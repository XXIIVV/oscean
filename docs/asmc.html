

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How to Use Inline Assembly Language in C Code &mdash; gcc 6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="gcc 6 documentation" href="index.html" />
    <link rel="up" title="Extensions to the C Language Family" href="extensions-to-the-c-language-family.html" />
    <link rel="next" title="Alternate Keywords" href="alternate-keywords.html" />
    <link rel="prev" title="When is a Volatile Object Accessed?" href="when-is-a-volatile-object-accessed?.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="alternate-keywords.html" title="Alternate Keywords"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="when-is-a-volatile-object-accessed?.html" title="When is a Volatile Object Accessed?"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" accesskey="U">Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">How to Use Inline Assembly Language in C Code</a><ul>
<li><a class="reference internal" href="#basic-asm-assembler-instructions-without-operands">Basic Asm - Assembler Instructions Without Operands</a></li>
<li><a class="reference internal" href="#qualifiers">Qualifiers</a></li>
<li><a class="reference internal" href="#parameters">Parameters</a></li>
<li><a class="reference internal" href="#remarks">Remarks</a></li>
<li><a class="reference internal" href="#extended-asm-assembler-instructions-with-c-expression-operands">Extended Asm - Assembler Instructions with C Expression Operands</a></li>
<li><a class="reference internal" href="#id1">Qualifiers</a></li>
<li><a class="reference internal" href="#id2">Parameters</a></li>
<li><a class="reference internal" href="#id3">Remarks</a><ul>
<li><a class="reference internal" href="#volatile">Volatile</a></li>
<li><a class="reference internal" href="#assembler-template">Assembler Template</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-format-strings">Special format strings</a><ul>
<li><a class="reference internal" href="#output-operands">Output Operands</a></li>
<li><a class="reference internal" href="#input-operands">Input Operands</a></li>
<li><a class="reference internal" href="#clobbers">Clobbers</a></li>
<li><a class="reference internal" href="#goto-labels">Goto Labels</a></li>
<li><a class="reference internal" href="#x86-operand-modifiers">x86 Operand Modifiers</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#simple-constraints">Simple Constraints</a></li>
<li><a class="reference internal" href="#multiple-alternative-constraints">Multiple Alternative Constraints</a></li>
<li><a class="reference internal" href="#constraint-modifier-characters">Constraint Modifier Characters</a></li>
<li><a class="reference internal" href="#constraints-for-particular-machines">Constraints for Particular Machines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlling-names-used-in-assembler-code">Controlling Names Used in Assembler Code</a></li>
<li><a class="reference internal" href="#variables-in-specified-registers">Variables in Specified Registers</a><ul>
<li><a class="reference internal" href="#defining-global-register-variables">Defining Global Register Variables</a></li>
<li><a class="reference internal" href="#specifying-registers-for-local-variables">Specifying Registers for Local Variables</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="when-is-a-volatile-object-accessed?.html"
                        title="previous chapter">When is a Volatile Object Accessed?</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="alternate-keywords.html"
                        title="next chapter">Alternate Keywords</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/how-to-use-inline-assembly-language-in-c-code.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="how-to-use-inline-assembly-language-in-c-code">
<span id="using-assembly-language-with-c"></span><h1>How to Use Inline Assembly Language in C Code<a class="headerlink" href="#how-to-use-inline-assembly-language-in-c-code" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><p id="index-3">The <tt class="docutils literal"><span class="pre">asm</span></tt> keyword allows you to embed assembler instructions
within C code.  GCC provides two forms of inline <tt class="docutils literal"><span class="pre">asm</span></tt>
statements.  A <em class="dfn">basic ``asm``</em> statement is one with no
operands (see <a class="reference internal" href="#basic-asm"><em>Basic Asm - Assembler Instructions Without Operands</em></a>), while an <em class="dfn">extended ``asm``</em>
statement (see <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>) includes one or more operands.
The extended form is preferred for mixing C and assembly language
within a function, but to include assembly language at
top level you must use basic <tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>You can also use the <tt class="docutils literal"><span class="pre">asm</span></tt> keyword to override the assembler name
for a C symbol, or to place a C variable in a specific register.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="basic-asm-assembler-instructions-without-operands">
<span id="basic-asm"></span><h2>Basic Asm - Assembler Instructions Without Operands<a class="headerlink" href="#basic-asm-assembler-instructions-without-operands" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><p id="index-5">A basic <tt class="docutils literal"><span class="pre">asm</span></tt> statement has the following syntax:</p>
<div class="highlight-c++"><pre>asm [ volatile ] ( ``AssemblerInstructions`` )</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">asm</span></tt> keyword is a GNU extension.
When writing code that can be compiled with <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-ansi"><em class="xref std std-option">-ansi</em></a> and the
various <a class="reference internal" href="options-controlling-the-preprocessor.html#cmdoption-std"><em class="xref std std-option">-std</em></a> options, use <tt class="docutils literal"><span class="pre">__asm__</span></tt> instead of
<tt class="docutils literal"><span class="pre">asm</span></tt> (see <a class="reference internal" href="alternate-keywords.html#alternate-keywords"><em>Alternate Keywords</em></a>).</p>
</div>
<div class="section" id="qualifiers">
<h2>Qualifiers<a class="headerlink" href="#qualifiers" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">volatile</span></tt></dt>
<dd>The optional <tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier has no effect.
All basic <tt class="docutils literal"><span class="pre">asm</span></tt> blocks are implicitly volatile.</dd>
</dl>
</div>
<div class="section" id="parameters">
<h2>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">AssemblerInstructions</span></tt></dt>
<dd><p class="first">This is a literal string that specifies the assembler code. The string can
contain any instructions recognized by the assembler, including directives.
GCC does not parse the assembler instructions themselves and
does not know what they mean or even whether they are valid assembler input.</p>
<p class="last">You may place multiple assembler instructions together in a single <tt class="docutils literal"><span class="pre">asm</span></tt>
string, separated by the characters normally used in assembly code for the
system. A combination that works in most places is a newline to break the
line, plus a tab character (written as <tt class="samp docutils literal"><span class="pre">nt</span></tt>).
Some assemblers allow semicolons as a line separator. However,
note that some assembler dialects use semicolons to start a comment.</p>
</dd>
</dl>
</div>
<div class="section" id="remarks">
<h2>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h2>
<p>Using extended <tt class="docutils literal"><span class="pre">asm</span></tt> typically produces smaller, safer, and more
efficient code, and in most cases it is a better solution than basic
<tt class="docutils literal"><span class="pre">asm</span></tt>.  However, there are two situations where only basic <tt class="docutils literal"><span class="pre">asm</span></tt>
can be used:</p>
<ul class="simple">
<li>Extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements have to be inside a C
function, so to write inline assembly language at file scope (&#8216;top-level&#8217;),
outside of C functions, you must use basic <tt class="docutils literal"><span class="pre">asm</span></tt>.
You can use this technique to emit assembler directives,
define assembly language macros that can be invoked elsewhere in the file,
or write entire functions in assembly language.</li>
<li>Functions declared
with the <tt class="docutils literal"><span class="pre">naked</span></tt> attribute also require basic <tt class="docutils literal"><span class="pre">asm</span></tt>
(see <a class="reference internal" href="declaring-attributes-of-functions.html#function-attributes"><em>Declaring Attributes of Functions</em></a>).</li>
</ul>
<p>Safely accessing C data and calling functions from basic <tt class="docutils literal"><span class="pre">asm</span></tt> is more
complex than it may appear. To access C data, it is better to use extended
<tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>Do not expect a sequence of <tt class="docutils literal"><span class="pre">asm</span></tt> statements to remain perfectly
consecutive after compilation. If certain instructions need to remain
consecutive in the output, put them in a single multi-instruction <tt class="docutils literal"><span class="pre">asm</span></tt>
statement. Note that GCC&#8217;s optimizers can move <tt class="docutils literal"><span class="pre">asm</span></tt> statements
relative to other code, including across jumps.</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> statements may not perform jumps into other <tt class="docutils literal"><span class="pre">asm</span></tt> statements.
GCC does not know about these jumps, and therefore cannot take
account of them when deciding how to optimize. Jumps from <tt class="docutils literal"><span class="pre">asm</span></tt> to C
labels are only supported in extended <tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>Under certain circumstances, GCC may duplicate (or remove duplicates of) your
assembly code when optimizing. This can lead to unexpected duplicate
symbol errors during compilation if your assembly code defines symbols or
labels.</p>
<p>Since GCC does not parse the <tt class="docutils literal"><span class="pre">AssemblerInstructions</span></tt>, it has no
visibility of any symbols it references. This may result in GCC discarding
those symbols as unreferenced.</p>
<p>The compiler copies the assembler instructions in a basic <tt class="docutils literal"><span class="pre">asm</span></tt>
verbatim to the assembly language output file, without
processing dialects or any of the <tt class="samp docutils literal"><span class="pre">%</span></tt> operators that are available with
extended <tt class="docutils literal"><span class="pre">asm</span></tt>. This results in minor differences between basic
<tt class="docutils literal"><span class="pre">asm</span></tt> strings and extended <tt class="docutils literal"><span class="pre">asm</span></tt> templates. For example, to refer to
registers you might use <tt class="samp docutils literal"><span class="pre">%eax</span></tt> in basic <tt class="docutils literal"><span class="pre">asm</span></tt> and
<tt class="samp docutils literal"><span class="pre">%%eax</span></tt> in extended <tt class="docutils literal"><span class="pre">asm</span></tt>.</p>
<p>On targets such as x86 that support multiple assembler dialects,
all basic <tt class="docutils literal"><span class="pre">asm</span></tt> blocks use the assembler dialect specified by the
<a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-masm"><em class="xref std std-option">-masm</em></a> command-line option (see <a class="reference internal" href="hardware-models-and-configurations.html#x86-options"><em>x86 Options</em></a>).
Basic <tt class="docutils literal"><span class="pre">asm</span></tt> provides no
mechanism to provide different assembler strings for different dialects.</p>
<p>Here is an example of basic <tt class="docutils literal"><span class="pre">asm</span></tt> for i386:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/* Note that this code will not compile with -masm=intel */</span>
<span class="cp">#define DebugBreak() asm(&quot;int $3&quot;)</span>
</pre></div>
</div>
</div>
<div class="section" id="extended-asm-assembler-instructions-with-c-expression-operands">
<span id="extended-asm"></span><h2>Extended Asm - Assembler Instructions with C Expression Operands<a class="headerlink" href="#extended-asm-assembler-instructions-with-c-expression-operands" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-6"></span><p id="index-7">With extended <tt class="docutils literal"><span class="pre">asm</span></tt> you can read and write C variables from
assembler and perform jumps from assembler code to C labels.
Extended <tt class="docutils literal"><span class="pre">asm</span></tt> syntax uses colons (<tt class="samp docutils literal"><span class="pre">:</span></tt>) to delimit
the operand parameters after the assembler template:</p>
<div class="highlight-c++"><pre>asm [volatile] ( ``AssemblerTemplate``
                 : ``OutputOperands``
                 [ : ``InputOperands``
                 [ : ``Clobbers`` ] ])

asm [volatile] goto ( ``AssemblerTemplate``
                      :
                      : ``InputOperands``
                      : ``Clobbers``
                      : ``GotoLabels``)</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">asm</span></tt> keyword is a GNU extension.
When writing code that can be compiled with <a class="reference internal" href="options-controlling-c-dialect.html#cmdoption-ansi"><em class="xref std std-option">-ansi</em></a> and the
various <a class="reference internal" href="options-controlling-the-preprocessor.html#cmdoption-std"><em class="xref std std-option">-std</em></a> options, use <tt class="docutils literal"><span class="pre">__asm__</span></tt> instead of
<tt class="docutils literal"><span class="pre">asm</span></tt> (see <a class="reference internal" href="alternate-keywords.html#alternate-keywords"><em>Alternate Keywords</em></a>).</p>
</div>
<div class="section" id="id1">
<h2>Qualifiers<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">volatile</span></tt></dt>
<dd>The typical use of extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements is to manipulate input
values to produce output values. However, your <tt class="docutils literal"><span class="pre">asm</span></tt> statements may
also produce side effects. If so, you may need to use the <tt class="docutils literal"><span class="pre">volatile</span></tt>
qualifier to disable certain optimizations. See <a class="reference internal" href="#volatile"><em>Volatile</em></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">goto</span></tt></dt>
<dd>This qualifier informs the compiler that the <tt class="docutils literal"><span class="pre">asm</span></tt> statement may
perform a jump to one of the labels listed in the <tt class="docutils literal"><span class="pre">GotoLabels</span></tt>.
See <a class="reference internal" href="#gotolabels"><em>Goto Labels</em></a>.</dd>
</dl>
</div>
<div class="section" id="id2">
<h2>Parameters<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt></dt>
<dd>This is a literal string that is the template for the assembler code. It is a
combination of fixed text and tokens that refer to the input, output,
and goto parameters. See <a class="reference internal" href="#assemblertemplate"><em>Assembler Template</em></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">OutputOperands</span></tt></dt>
<dd>A comma-separated list of the C variables modified by the instructions in the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt>.  An empty list is permitted.  See <a class="reference internal" href="#outputoperands"><em>Output Operands</em></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">InputOperands</span></tt></dt>
<dd>A comma-separated list of C expressions read by the instructions in the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt>.  An empty list is permitted.  See <a class="reference internal" href="#inputoperands"><em>Input Operands</em></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">Clobbers</span></tt></dt>
<dd>A comma-separated list of registers or other values changed by the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt>, beyond those listed as outputs.
An empty list is permitted.  See <a class="reference internal" href="#clobbers"><em>Clobbers</em></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">GotoLabels</span></tt></dt>
<dd><p class="first">When you are using the <tt class="docutils literal"><span class="pre">goto</span></tt> form of <tt class="docutils literal"><span class="pre">asm</span></tt>, this section contains
the list of all C labels to which the code in the
<tt class="docutils literal"><span class="pre">AssemblerTemplate</span></tt> may jump.
See <a class="reference internal" href="#gotolabels"><em>Goto Labels</em></a>.</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> statements may not perform jumps into other <tt class="docutils literal"><span class="pre">asm</span></tt> statements,
only to the listed <tt class="docutils literal"><span class="pre">GotoLabels</span></tt>.
GCC&#8217;s optimizers do not know about other jumps; therefore they cannot take
account of them when deciding how to optimize.</p>
<p class="last">The total number of input + output + goto operands is limited to 30.</p>
</dd>
</dl>
</div>
<div class="section" id="id3">
<h2>Remarks<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">asm</span></tt> statement allows you to include assembly instructions directly
within C code. This may help you to maximize performance in time-sensitive
code or to access assembly instructions that are not readily available to C
programs.</p>
<p>Note that extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements must be inside a function. Only
basic <tt class="docutils literal"><span class="pre">asm</span></tt> may be outside functions (see <a class="reference internal" href="#basic-asm"><em>Basic Asm - Assembler Instructions Without Operands</em></a>).
Functions declared with the <tt class="docutils literal"><span class="pre">naked</span></tt> attribute also require basic
<tt class="docutils literal"><span class="pre">asm</span></tt> (see <a class="reference internal" href="declaring-attributes-of-functions.html#function-attributes"><em>Declaring Attributes of Functions</em></a>).</p>
<p>While the uses of <tt class="docutils literal"><span class="pre">asm</span></tt> are many and varied, it may help to think of an
<tt class="docutils literal"><span class="pre">asm</span></tt> statement as a series of low-level instructions that convert input
parameters to output parameters. So a simple (if not particularly useful)
example for i386 using <tt class="docutils literal"><span class="pre">asm</span></tt> might look like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dst</span><span class="p">;</span>

<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;mov %1, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
    <span class="s">&quot;add $1, %0&quot;</span>
    <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">src</span><span class="p">));</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
</pre></div>
</div>
<p>This code copies <tt class="docutils literal"><span class="pre">src</span></tt> to <tt class="docutils literal"><span class="pre">dst</span></tt> and add 1 to <tt class="docutils literal"><span class="pre">dst</span></tt>.</p>
<div class="section" id="volatile">
<span id="id4"></span><h3>Volatile<a class="headerlink" href="#volatile" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-8"></span><p id="index-9">GCC&#8217;s optimizers sometimes discard <tt class="docutils literal"><span class="pre">asm</span></tt> statements if they determine
there is no need for the output variables. Also, the optimizers may move
code out of loops if they believe that the code will always return the same
result (i.e. none of its input values change between calls). Using the
<tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier disables these optimizations. <tt class="docutils literal"><span class="pre">asm</span></tt> statements
that have no output operands, including <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statements,
are implicitly volatile.</p>
<p>This i386 code demonstrates a case that does not use (or require) the
<tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier. If it is performing assertion checking, this code
uses <tt class="docutils literal"><span class="pre">asm</span></tt> to perform the validation. Otherwise, <tt class="docutils literal"><span class="pre">dwRes</span></tt> is
unreferenced by any code. As a result, the optimizers can discard the
<tt class="docutils literal"><span class="pre">asm</span></tt> statement, which in turn removes the need for the entire
<tt class="docutils literal"><span class="pre">DoCheck</span></tt> routine. By omitting the <tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier when it
isn&#8217;t needed you allow the optimizers to produce the most efficient code
possible.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">DoCheck</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">dwSomeValue</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">dwRes</span><span class="p">;</span>

   <span class="c1">// Assumes dwSomeValue is not zero.</span>
   <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %1,%0&quot;</span>
     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dwRes</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">dwSomeValue</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>

   <span class="n">assert</span><span class="p">(</span><span class="n">dwRes</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The next example shows a case where the optimizers can recognize that the input
(<tt class="docutils literal"><span class="pre">dwSomeValue</span></tt>) never changes during the execution of the function and can
therefore move the <tt class="docutils literal"><span class="pre">asm</span></tt> outside the loop to produce more efficient code.
Again, using <tt class="docutils literal"><span class="pre">volatile</span></tt> disables this type of optimization.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">do_print</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">dwSomeValue</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">dwRes</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// Assumes dwSomeValue is not zero.</span>
      <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %1,%0&quot;</span>
        <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">dwRes</span><span class="p">)</span>
        <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">dwSomeValue</span><span class="p">)</span>
        <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>

      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%u: %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dwSomeValue</span><span class="p">,</span> <span class="n">dwRes</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following example demonstrates a case where you need to use the
<tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier.
It uses the x86 <tt class="docutils literal"><span class="pre">rdtsc</span></tt> instruction, which reads
the computer&#8217;s time-stamp counter. Without the <tt class="docutils literal"><span class="pre">volatile</span></tt> qualifier,
the optimizers might assume that the <tt class="docutils literal"><span class="pre">asm</span></tt> block will always return the
same value and therefore optimize away the second call.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint64_t</span> <span class="n">msr</span><span class="p">;</span>

<span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span> <span class="s">&quot;rdtsc</span><span class="se">\n\t</span><span class="s">&quot;</span>    <span class="c1">// Returns the time in EDX:EAX.</span>
        <span class="s">&quot;shl $32, %%rdx</span><span class="se">\n\t</span><span class="s">&quot;</span>  <span class="c1">// Shift the upper bits left.</span>
        <span class="s">&quot;or %%rdx, %0&quot;</span>        <span class="c1">// &#39;Or&#39; in the lower bits.</span>
        <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span>
        <span class="o">:</span>
        <span class="o">:</span> <span class="s">&quot;rdx&quot;</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;msr: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>

<span class="c1">// Do other work...</span>

<span class="c1">// Reprint the timestamp</span>
<span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span> <span class="s">&quot;rdtsc</span><span class="se">\n\t</span><span class="s">&quot;</span>    <span class="c1">// Returns the time in EDX:EAX.</span>
        <span class="s">&quot;shl $32, %%rdx</span><span class="se">\n\t</span><span class="s">&quot;</span>  <span class="c1">// Shift the upper bits left.</span>
        <span class="s">&quot;or %%rdx, %0&quot;</span>        <span class="c1">// &#39;Or&#39; in the lower bits.</span>
        <span class="o">:</span> <span class="s">&quot;=a&quot;</span> <span class="p">(</span><span class="n">msr</span><span class="p">)</span>
        <span class="o">:</span>
        <span class="o">:</span> <span class="s">&quot;rdx&quot;</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;msr: %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msr</span><span class="p">);</span>
</pre></div>
</div>
<p>GCC&#8217;s optimizers do not treat this code like the non-volatile code in the
earlier examples. They do not move it out of loops or omit it on the
assumption that the result from a previous call is still valid.</p>
<p>Note that the compiler can move even volatile <tt class="docutils literal"><span class="pre">asm</span></tt> instructions relative
to other code, including across jump instructions. For example, on many
targets there is a system register that controls the rounding mode of
floating-point operations. Setting it with a volatile <tt class="docutils literal"><span class="pre">asm</span></tt>, as in the
following PowerPC example, does not work reliably.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">volatile</span><span class="p">(</span><span class="s">&quot;mtfsf 255, %0&quot;</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">fpenv</span><span class="p">));</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>The compiler may move the addition back before the volatile <tt class="docutils literal"><span class="pre">asm</span></tt>. To
make it work as expected, add an artificial dependency to the <tt class="docutils literal"><span class="pre">asm</span></tt> by
referencing a variable in the subsequent code, for example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&quot;mtfsf 255,%1&quot;</span> <span class="o">:</span> <span class="s">&quot;=X&quot;</span> <span class="p">(</span><span class="n">sum</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">fpenv</span><span class="p">));</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>Under certain circumstances, GCC may duplicate (or remove duplicates of) your
assembly code when optimizing. This can lead to unexpected duplicate symbol
errors during compilation if your asm code defines symbols or labels.
Using <tt class="samp docutils literal"><span class="pre">%=</span></tt>
(see <a class="reference internal" href="#assemblertemplate"><em>Assembler Template</em></a>) may help resolve this problem.</p>
</div>
<div class="section" id="assembler-template">
<span id="assemblertemplate"></span><h3>Assembler Template<a class="headerlink" href="#assembler-template" title="Permalink to this headline">¶</a></h3>
<p id="index-10">An assembler template is a literal string containing assembler instructions.
The compiler replaces tokens in the template that refer
to inputs, outputs, and goto labels,
and then outputs the resulting string to the assembler. The
string can contain any instructions recognized by the assembler, including
directives. GCC does not parse the assembler instructions
themselves and does not know what they mean or even whether they are valid
assembler input. However, it does count the statements
(see <em class="xref std std-ref">size-of-an-asm</em>).</p>
<p>You may place multiple assembler instructions together in a single <tt class="docutils literal"><span class="pre">asm</span></tt>
string, separated by the characters normally used in assembly code for the
system. A combination that works in most places is a newline to break the
line, plus a tab character to move to the instruction field (written as
<tt class="samp docutils literal"><span class="pre">nt</span></tt>).
Some assemblers allow semicolons as a line separator. However, note
that some assembler dialects use semicolons to start a comment.</p>
<p>Do not expect a sequence of <tt class="docutils literal"><span class="pre">asm</span></tt> statements to remain perfectly
consecutive after compilation, even when you are using the <tt class="docutils literal"><span class="pre">volatile</span></tt>
qualifier. If certain instructions need to remain consecutive in the output,
put them in a single multi-instruction asm statement.</p>
<p>Accessing data from C programs without using input/output operands (such as
by using global symbols directly from the assembler template) may not work as
expected. Similarly, calling functions directly from an assembler template
requires a detailed understanding of the target assembler and ABI.</p>
<p>Since GCC does not parse the assembler template,
it has no visibility of any
symbols it references. This may result in GCC discarding those symbols as
unreferenced unless they are also listed as input, output, or goto operands.</p>
</div>
</div>
<div class="section" id="special-format-strings">
<h2>Special format strings<a class="headerlink" href="#special-format-strings" title="Permalink to this headline">¶</a></h2>
<p>In addition to the tokens described by the input, output, and goto operands,
these tokens have special meanings in the assembler template:</p>
<dl class="docutils">
<dt><tt class="samp docutils literal"><span class="pre">%%</span></tt></dt>
<dd>Outputs a single <tt class="samp docutils literal"><span class="pre">%</span></tt> into the assembler code.</dd>
<dt><tt class="samp docutils literal"><span class="pre">%=</span></tt></dt>
<dd>Outputs a number that is unique to each instance of the <tt class="docutils literal"><span class="pre">asm</span></tt>
statement in the entire compilation. This option is useful when creating local
labels and referring to them multiple times in a single template that
generates multiple assembler instructions.</dd>
<dt><tt class="samp docutils literal"><span class="pre">%{</span></tt> <tt class="samp docutils literal"><span class="pre">%|</span></tt> <tt class="samp docutils literal"><span class="pre">%}</span></tt></dt>
<dd>Outputs <tt class="samp docutils literal"><span class="pre">{</span></tt>, <tt class="samp docutils literal"><span class="pre">|</span></tt>, and <tt class="samp docutils literal"><span class="pre">}</span></tt> characters (respectively)
into the assembler code.  When unescaped, these characters have special
meaning to indicate multiple assembler dialects, as described below.</dd>
</dl>
<p>Multiple assembler dialects in <tt class="docutils literal"><span class="pre">asm</span></tt> templatesOn targets such as x86, GCC supports multiple assembler dialects.
The <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-masm"><em class="xref std std-option">-masm</em></a> option controls which dialect GCC uses as its
default for inline assembler. The target-specific documentation for the
<a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-masm"><em class="xref std std-option">-masm</em></a> option contains the list of supported dialects, as well as the
default dialect if the option is not specified. This information may be
important to understand, since assembler code that works correctly when
compiled using one dialect will likely fail if compiled using another.
See <a class="reference internal" href="hardware-models-and-configurations.html#x86-options"><em>x86 Options</em></a>.</p>
<p>If your code needs to support multiple assembler dialects (for example, if
you are writing public headers that need to support a variety of compilation
options), use constructs of this form:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">{</span> <span class="n">dialect0</span> <span class="o">|</span> <span class="n">dialect1</span> <span class="o">|</span> <span class="n">dialect2</span><span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>This construct outputs <tt class="docutils literal"><span class="pre">dialect0</span></tt>
when using dialect #0 to compile the code,
<tt class="docutils literal"><span class="pre">dialect1</span></tt> for dialect #1, etc. If there are fewer alternatives within the
braces than the number of dialects the compiler supports, the construct
outputs nothing.</p>
<p>For example, if an x86 compiler supports two dialects
(<tt class="samp docutils literal"><span class="pre">att</span></tt>, <tt class="samp docutils literal"><span class="pre">intel</span></tt>), an
assembler template such as this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;bt{l %[Offset],%[Base] | %[Base],%[Offset]}; jc %l2&quot;</span>
</pre></div>
</div>
<p>is equivalent to one of</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;btl %[Offset],%[Base] ; jc %l2&quot;</span>   <span class="cm">/* att dialect */</span>
<span class="s">&quot;bt %[Base],%[Offset]; jc %l2&quot;</span>     <span class="cm">/* intel dialect */</span>
</pre></div>
</div>
<p>Using that same compiler, this code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;xchg{l}</span><span class="se">\t</span><span class="s">{%%}ebx, %1&quot;</span>
</pre></div>
</div>
<p>corresponds to either</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="s">&quot;xchgl</span><span class="se">\t</span><span class="s">%%ebx, %1&quot;</span>                 <span class="cm">/* att dialect */</span>
<span class="s">&quot;xchg</span><span class="se">\t</span><span class="s">ebx, %1&quot;</span>                    <span class="cm">/* intel dialect */</span>
</pre></div>
</div>
<p>There is no support for nesting dialect alternatives.</p>
<div class="section" id="output-operands">
<span id="outputoperands"></span><h3>Output Operands<a class="headerlink" href="#output-operands" title="Permalink to this headline">¶</a></h3>
<p id="index-11">An <tt class="docutils literal"><span class="pre">asm</span></tt> statement has zero or more output operands indicating the names
of C variables modified by the assembler code.</p>
<p>In this i386 example, <tt class="docutils literal"><span class="pre">old</span></tt> (referred to in the template string as
<tt class="docutils literal"><span class="pre">%0</span></tt>) and <tt class="docutils literal"><span class="pre">*Base</span></tt> (as <tt class="docutils literal"><span class="pre">%1</span></tt>) are outputs and <tt class="docutils literal"><span class="pre">Offset</span></tt>
(<tt class="docutils literal"><span class="pre">%2</span></tt>) is an input:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">old</span><span class="p">;</span>

<span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;btsl %2,%1</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="c1">// Turn on zero-based bit #Offset in Base.</span>
         <span class="s">&quot;sbb %0,%0&quot;</span>      <span class="c1">// Use the CF to calculate old.</span>
   <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="s">&quot;+rm&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">Base</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;Ir&quot;</span> <span class="p">(</span><span class="n">Offset</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>

<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</pre></div>
</div>
<p>Operands are separated by commas.  Each operand has this format:</p>
<div class="highlight-c++"><pre>[ [``asmSymbolicName``] ] ``constraint`` (``cvariablename``)</pre>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt></dt>
<dd><p class="first">Specifies a symbolic name for the operand.
Reference the name in the assembler template
by enclosing it in square brackets
(i.e. <tt class="samp docutils literal"><span class="pre">%[Value]</span></tt>). The scope of the name is the <tt class="docutils literal"><span class="pre">asm</span></tt> statement
that contains the definition. Any valid C variable name is acceptable,
including names already defined in the surrounding code. No two operands
within the same <tt class="docutils literal"><span class="pre">asm</span></tt> statement can use the same symbolic name.</p>
<p class="last">When not using an <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt>, use the (zero-based) position
of the operand
in the list of operands in the assembler template. For example if there are
three output operands, use <tt class="samp docutils literal"><span class="pre">%0</span></tt> in the template to refer to the first,
<tt class="samp docutils literal"><span class="pre">%1</span></tt> for the second, and <tt class="samp docutils literal"><span class="pre">%2</span></tt> for the third.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">constraint</span></tt></dt>
<dd><p class="first">A string constant specifying constraints on the placement of the operand;
See <em class="xref std std-ref">constraints</em>, for details.</p>
<p>Output constraints must begin with either <tt class="samp docutils literal"><span class="pre">=</span></tt> (a variable overwriting an
existing value) or <tt class="samp docutils literal"><span class="pre">+</span></tt> (when reading and writing). When using
<tt class="samp docutils literal"><span class="pre">=</span></tt>, do not assume the location contains the existing value
on entry to the <tt class="docutils literal"><span class="pre">asm</span></tt>, except
when the operand is tied to an input; see <a class="reference internal" href="#inputoperands"><em>Input Operands</em></a>.</p>
<p class="last">After the prefix, there must be one or more additional constraints
(see <em class="xref std std-ref">constraints</em>) that describe where the value resides. Common
constraints include <tt class="samp docutils literal"><span class="pre">r</span></tt> for register and <tt class="samp docutils literal"><span class="pre">m</span></tt> for memory.
When you list more than one possible location (for example, <tt class="docutils literal"><span class="pre">&quot;=rm&quot;</span></tt>),
the compiler chooses the most efficient one based on the current context.
If you list as many alternates as the <tt class="docutils literal"><span class="pre">asm</span></tt> statement allows, you permit
the optimizers to produce the best possible code.
If you must use a specific register, but your Machine Constraints do not
provide sufficient control to select the specific register you want,
local register variables may provide a solution (see <a class="reference internal" href="#local-reg-vars"><em>Specifying Registers for Local Variables</em></a>).</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">cvariablename</span></tt></dt>
<dd><p class="first">Specifies a C lvalue expression to hold the output, typically a variable name.
The enclosing parentheses are a required part of the syntax.</p>
<p class="last">When the compiler selects the registers to use to</p>
</dd>
</dl>
<p>represent the output operands, it does not use any of the clobbered registers
(see <a class="reference internal" href="#clobbers"><em>Clobbers</em></a>).</p>
<p>Output operand expressions must be lvalues. The compiler cannot check whether
the operands have data types that are reasonable for the instruction being
executed. For output expressions that are not directly addressable (for
example a bit-field), the constraint must allow a register. In that case, GCC
uses the register as the output of the <tt class="docutils literal"><span class="pre">asm</span></tt>, and then stores that
register into the output.</p>
<p>Operands using the <tt class="samp docutils literal"><span class="pre">+</span></tt> constraint modifier count as two operands
(that is, both as input and output) towards the total maximum of 30 operands
per <tt class="docutils literal"><span class="pre">asm</span></tt> statement.</p>
<p>Use the <tt class="samp docutils literal"><span class="pre">&amp;</span></tt> constraint modifier (see <a class="reference internal" href="#modifiers"><em>Constraint Modifier Characters</em></a>) on all output
operands that must not overlap an input.  Otherwise,
GCC may allocate the output operand in the same register as an unrelated
input operand, on the assumption that the assembler code consumes its
inputs before producing outputs. This assumption may be false if the assembler
code actually consists of more than one instruction.</p>
<p>The same problem can occur if one output parameter (<tt class="docutils literal"><span class="pre">a</span></tt>) allows a register
constraint and another output parameter (<tt class="docutils literal"><span class="pre">b</span></tt>) allows a memory constraint.
The code generated by GCC to access the memory address in <tt class="docutils literal"><span class="pre">b</span></tt> can contain
registers which <em>might</em> be shared by <tt class="docutils literal"><span class="pre">a</span></tt>, and GCC considers those
registers to be inputs to the asm. As above, GCC assumes that such input
registers are consumed before any outputs are written. This assumption may
result in incorrect behavior if the asm writes to <tt class="docutils literal"><span class="pre">a</span></tt> before using
<tt class="docutils literal"><span class="pre">b</span></tt>. Combining the <tt class="samp docutils literal"><span class="pre">&amp;</span></tt> modifier with the register constraint on <tt class="docutils literal"><span class="pre">a</span></tt>
ensures that modifying <tt class="docutils literal"><span class="pre">a</span></tt> does not affect the address referenced by
<tt class="docutils literal"><span class="pre">b</span></tt>. Otherwise, the location of <tt class="docutils literal"><span class="pre">b</span></tt>
is undefined if <tt class="docutils literal"><span class="pre">a</span></tt> is modified before using <tt class="docutils literal"><span class="pre">b</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> supports operand modifiers on operands (for example <tt class="samp docutils literal"><span class="pre">%k2</span></tt>
instead of simply <tt class="samp docutils literal"><span class="pre">%2</span></tt>). Typically these qualifiers are hardware
dependent. The list of supported modifiers for x86 is found at
x86Operandmodifiersx86 Operand modifiers.</p>
<p>If the C code that follows the <tt class="docutils literal"><span class="pre">asm</span></tt> makes no use of any of the output
operands, use <tt class="docutils literal"><span class="pre">volatile</span></tt> for the <tt class="docutils literal"><span class="pre">asm</span></tt> statement to prevent the
optimizers from discarding the <tt class="docutils literal"><span class="pre">asm</span></tt> statement as unneeded
(see Volatile).</p>
<p>This code makes no use of the optional <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt>. Therefore it
references the first output operand as <tt class="docutils literal"><span class="pre">%0</span></tt> (were there a second, it
would be <tt class="docutils literal"><span class="pre">%1</span></tt>, etc). The number of the first input operand is one greater
than that of the last output operand. In this i386 example, that makes
<tt class="docutils literal"><span class="pre">Mask</span></tt> referenced as <tt class="docutils literal"><span class="pre">%1</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint32_t</span> <span class="n">Mask</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">Index</span><span class="p">;</span>

  <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %1, %0&quot;</span>
     <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">Index</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">Mask</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>That code overwrites the variable <tt class="docutils literal"><span class="pre">Index</span></tt> (<tt class="samp docutils literal"><span class="pre">=</span></tt>),
placing the value in a register (<tt class="samp docutils literal"><span class="pre">r</span></tt>).
Using the generic <tt class="samp docutils literal"><span class="pre">r</span></tt> constraint instead of a constraint for a specific
register allows the compiler to pick the register to use, which can result
in more efficient code. This may not be possible if an assembler instruction
requires a specific register.</p>
<p>The following i386 example uses the <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt> syntax.
It produces the
same result as the code above, but some may consider it more readable or more
maintainable since reordering index numbers is not necessary when adding or
removing operands. The names <tt class="docutils literal"><span class="pre">aIndex</span></tt> and <tt class="docutils literal"><span class="pre">aMask</span></tt>
are only used in this example to emphasize which
names get used where.
It is acceptable to reuse the names <tt class="docutils literal"><span class="pre">Index</span></tt> and <tt class="docutils literal"><span class="pre">Mask</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint32_t</span> <span class="n">Mask</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">Index</span><span class="p">;</span>

  <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;bsfl %[aMask], %[aIndex]&quot;</span>
     <span class="o">:</span> <span class="p">[</span><span class="n">aIndex</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">Index</span><span class="p">)</span>
     <span class="o">:</span> <span class="p">[</span><span class="n">aMask</span><span class="p">]</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">Mask</span><span class="p">)</span>
     <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here are some more examples of output operands.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint32_t</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">d</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>

<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;mov %[e], %[d]&quot;</span>
   <span class="o">:</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="s">&quot;=rm&quot;</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span>
   <span class="o">:</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="s">&quot;rm&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">));</span>
</pre></div>
</div>
<p>Here, <tt class="docutils literal"><span class="pre">d</span></tt> may either be in a register or in memory. Since the compiler
might already have the current value of the <tt class="docutils literal"><span class="pre">uint32_t</span></tt> location
pointed to by <tt class="docutils literal"><span class="pre">e</span></tt>
in a register, you can enable it to choose the best location
for <tt class="docutils literal"><span class="pre">d</span></tt> by specifying both constraints.</p>
</div>
<div class="section" id="input-operands">
<span id="inputoperands"></span><h3>Input Operands<a class="headerlink" href="#input-operands" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-12"></span><p id="index-13">Input operands make values from C variables and expressions available to the
assembly code.</p>
<p>Operands are separated by commas.  Each operand has this format:</p>
<div class="highlight-c++"><pre>[ [``asmSymbolicName``] ] ``constraint`` (``cexpression``)</pre>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt></dt>
<dd><p class="first">Specifies a symbolic name for the operand.
Reference the name in the assembler template
by enclosing it in square brackets
(i.e. <tt class="samp docutils literal"><span class="pre">%[Value]</span></tt>). The scope of the name is the <tt class="docutils literal"><span class="pre">asm</span></tt> statement
that contains the definition. Any valid C variable name is acceptable,
including names already defined in the surrounding code. No two operands
within the same <tt class="docutils literal"><span class="pre">asm</span></tt> statement can use the same symbolic name.</p>
<p class="last">When not using an <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt>, use the (zero-based) position
of the operand
in the list of operands in the assembler template. For example if there are
two output operands and three inputs,
use <tt class="samp docutils literal"><span class="pre">%2</span></tt> in the template to refer to the first input operand,
<tt class="samp docutils literal"><span class="pre">%3</span></tt> for the second, and <tt class="samp docutils literal"><span class="pre">%4</span></tt> for the third.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">constraint</span></tt></dt>
<dd><p class="first">A string constant specifying constraints on the placement of the operand;
See <em class="xref std std-ref">constraints</em>, for details.</p>
<p>Input constraint strings may not begin with either <tt class="samp docutils literal"><span class="pre">=</span></tt> or <tt class="samp docutils literal"><span class="pre">+</span></tt>.
When you list more than one possible location (for example, <tt class="samp docutils literal"><span class="pre">&quot;irm&quot;</span></tt>),
the compiler chooses the most efficient one based on the current context.
If you must use a specific register, but your Machine Constraints do not
provide sufficient control to select the specific register you want,
local register variables may provide a solution (see <a class="reference internal" href="#local-reg-vars"><em>Specifying Registers for Local Variables</em></a>).</p>
<p class="last">Input constraints can also be digits (for example, <tt class="docutils literal"><span class="pre">&quot;0&quot;</span></tt>). This indicates
that the specified input must be in the same place as the output constraint
at the (zero-based) index in the output constraint list.
When using <tt class="docutils literal"><span class="pre">asmSymbolicName</span></tt> syntax for the output operands,
you may use these names (enclosed in brackets <tt class="samp docutils literal"><span class="pre">[]</span></tt>) instead of digits.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">cexpression</span></tt></dt>
<dd><p class="first">This is the C variable or expression being passed to the <tt class="docutils literal"><span class="pre">asm</span></tt> statement
as input.  The enclosing parentheses are a required part of the syntax.</p>
<p class="last">When the compiler selects the registers to use to represent the input</p>
</dd>
</dl>
<p>operands, it does not use any of the clobbered registers (see <a class="reference internal" href="#clobbers"><em>Clobbers</em></a>).</p>
<p>If there are no output operands but there are input operands, place two
consecutive colons where the output operands would go:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">__asm__</span> <span class="p">(</span><span class="s">&quot;some instructions&quot;</span>
   <span class="o">:</span> <span class="cm">/* No outputs. */</span>
   <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">Offset</span> <span class="o">/</span> <span class="mi">8</span><span class="p">));</span>
</pre></div>
</div>
<p>Warning: Do <em>not</em> modify the contents of input-only operands
(except for inputs tied to outputs). The compiler assumes that on exit from
the <tt class="docutils literal"><span class="pre">asm</span></tt> statement these operands contain the same values as they
had before executing the statement.
It is <em>not</em> possible to use clobbers
to inform the compiler that the values in these inputs are changing. One
common work-around is to tie the changing input variable to an output variable
that never gets used. Note, however, that if the code that follows the
<tt class="docutils literal"><span class="pre">asm</span></tt> statement makes no use of any of the output operands, the GCC
optimizers may discard the <tt class="docutils literal"><span class="pre">asm</span></tt> statement as unneeded
(see Volatile).</p>
<p><tt class="docutils literal"><span class="pre">asm</span></tt> supports operand modifiers on operands (for example <tt class="samp docutils literal"><span class="pre">%k2</span></tt>
instead of simply <tt class="samp docutils literal"><span class="pre">%2</span></tt>). Typically these qualifiers are hardware
dependent. The list of supported modifiers for x86 is found at
x86Operandmodifiersx86 Operand modifiers.</p>
<p>In this example using the fictitious <tt class="docutils literal"><span class="pre">combine</span></tt> instruction, the
constraint <tt class="docutils literal"><span class="pre">&quot;0&quot;</span></tt> for input operand 1 says that it must occupy the same
location as output operand 0. Only input operands may use numbers in
constraints, and they must each refer to an output operand. Only a number (or
the symbolic assembler name) in the constraint can guarantee that one operand
is in the same place as another. The mere fact that <tt class="docutils literal"><span class="pre">foo</span></tt> is the value of
both operands is not enough to guarantee that they are in the same place in
the generated assembler code.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;combine %2, %0&quot;</span>
   <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">bar</span><span class="p">));</span>
</pre></div>
</div>
<p>Here is an example using symbolic names.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;cmoveq %1, %2, %[result]&quot;</span>
   <span class="o">:</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
   <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="k">new</span><span class="p">),</span> <span class="s">&quot;[result]&quot;</span> <span class="p">(</span><span class="n">old</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="clobbers">
<span id="id5"></span><h3>Clobbers<a class="headerlink" href="#clobbers" title="Permalink to this headline">¶</a></h3>
<p id="index-14">While the compiler is aware of changes to entries listed in the output
operands, the inline <tt class="docutils literal"><span class="pre">asm</span></tt> code may modify more than just the outputs. For
example, calculations may require additional registers, or the processor may
overwrite a register as a side effect of a particular assembler instruction.
In order to inform the compiler of these changes, list them in the clobber
list. Clobber list items are either register names or the special clobbers
(listed below). Each clobber list item is a string constant
enclosed in double quotes and separated by commas.</p>
<p>Clobber descriptions may not in any way overlap with an input or output
operand. For example, you may not have an operand describing a register class
with one member when listing that register in the clobber list. Variables
declared to live in specific registers (see <a class="reference internal" href="#explicit-reg-vars"><em>Variables in Specified Registers</em></a>) and used
as <tt class="docutils literal"><span class="pre">asm</span></tt> input or output operands must have no part mentioned in the
clobber description. In particular, there is no way to specify that input
operands get modified without also specifying them as output operands.</p>
<p>When the compiler selects which registers to use to represent input and output
operands, it does not use any of the clobbered registers. As a result,
clobbered registers are available for any use in the assembler code.</p>
<p>Here is a realistic example for the VAX showing the use of clobbered
registers:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&quot;movc3 %0, %1, %2&quot;</span>
                   <span class="o">:</span> <span class="cm">/* No outputs. */</span>
                   <span class="o">:</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">from</span><span class="p">),</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">to</span><span class="p">),</span> <span class="s">&quot;g&quot;</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
                   <span class="o">:</span> <span class="s">&quot;r0&quot;</span><span class="p">,</span> <span class="s">&quot;r1&quot;</span><span class="p">,</span> <span class="s">&quot;r2&quot;</span><span class="p">,</span> <span class="s">&quot;r3&quot;</span><span class="p">,</span> <span class="s">&quot;r4&quot;</span><span class="p">,</span> <span class="s">&quot;r5&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Also, there are two special clobber arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">&quot;cc&quot;</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">&quot;cc&quot;</span></tt> clobber indicates that the assembler code modifies the flags
register. On some machines, GCC represents the condition codes as a specific
hardware register; <tt class="docutils literal"><span class="pre">&quot;cc&quot;</span></tt> serves to name this register.
On other machines, condition code handling is different,
and specifying <tt class="docutils literal"><span class="pre">&quot;cc&quot;</span></tt> has no effect. But
it is valid no matter what the target.</dd>
<dt><tt class="docutils literal"><span class="pre">&quot;memory&quot;</span></tt></dt>
<dd><p class="first">The <tt class="docutils literal"><span class="pre">&quot;memory&quot;</span></tt> clobber tells the compiler that the assembly code
performs memory
reads or writes to items other than those listed in the input and output
operands (for example, accessing the memory pointed to by one of the input
parameters). To ensure memory contains correct values, GCC may need to flush
specific register values to memory before executing the <tt class="docutils literal"><span class="pre">asm</span></tt>. Further,
the compiler does not assume that any values read from memory before an
<tt class="docutils literal"><span class="pre">asm</span></tt> remain unchanged after that <tt class="docutils literal"><span class="pre">asm</span></tt>; it reloads them as
needed.
Using the <tt class="docutils literal"><span class="pre">&quot;memory&quot;</span></tt> clobber effectively forms a read/write
memory barrier for the compiler.</p>
<p>Note that this clobber does not prevent the <em>processor</em> from doing
speculative reads past the <tt class="docutils literal"><span class="pre">asm</span></tt> statement. To prevent that, you need
processor-specific fence instructions.</p>
<p>Flushing registers to memory has performance implications and may be an issue
for time-sensitive code.  You can use a trick to avoid this if the size of
the memory being accessed is known at compile time. For example, if accessing
ten bytes of a string, use a memory input like:</p>
<p class="last"><tt class="docutils literal"><span class="pre">{&quot;m&quot;(</span> <span class="pre">({</span> <span class="pre">struct</span> <span class="pre">{</span> <span class="pre">char</span> <span class="pre">x[10];</span> <span class="pre">}</span> <span class="pre">*p</span> <span class="pre">=</span> <span class="pre">(void</span> <span class="pre">*)ptr</span> <span class="pre">;</span> <span class="pre">*p;</span> <span class="pre">})</span> <span class="pre">)}</span></tt>.</p>
</dd>
</dl>
</div>
<div class="section" id="goto-labels">
<span id="gotolabels"></span><h3>Goto Labels<a class="headerlink" href="#goto-labels" title="Permalink to this headline">¶</a></h3>
<p id="index-15"><tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> allows assembly code to jump to one or more C labels.  The
<tt class="docutils literal"><span class="pre">GotoLabels</span></tt> section in an <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statement contains
a comma-separated
list of all C labels to which the assembler code may jump. GCC assumes that
<tt class="docutils literal"><span class="pre">asm</span></tt> execution falls through to the next statement (if this is not the
case, consider using the <tt class="docutils literal"><span class="pre">__builtin_unreachable</span></tt> intrinsic after the
<tt class="docutils literal"><span class="pre">asm</span></tt> statement). Optimization of <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> may be improved by
using the <tt class="docutils literal"><span class="pre">hot</span></tt> and <tt class="docutils literal"><span class="pre">cold</span></tt> label attributes (see <em class="xref std std-ref">label&#8211;attributes</em>).</p>
<p>An <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statement cannot have outputs.
This is due to an internal restriction of
the compiler: control transfer instructions cannot have outputs.
If the assembler code does modify anything, use the <tt class="docutils literal"><span class="pre">&quot;memory&quot;</span></tt> clobber
to force the
optimizers to flush all register values to memory and reload them if
necessary after the <tt class="docutils literal"><span class="pre">asm</span></tt> statement.</p>
<p>Also note that an <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> statement is always implicitly
considered volatile.</p>
<p>To reference a label in the assembler template,
prefix it with <tt class="samp docutils literal"><span class="pre">%l</span></tt> (lowercase <tt class="samp docutils literal"><span class="pre">L</span></tt>) followed
by its (zero-based) position in <tt class="docutils literal"><span class="pre">GotoLabels</span></tt> plus the number of input
operands.  For example, if the <tt class="docutils literal"><span class="pre">asm</span></tt> has three inputs and references two
labels, refer to the first label as <tt class="samp docutils literal"><span class="pre">%l3</span></tt> and the second as <tt class="samp docutils literal"><span class="pre">%l4</span></tt>).</p>
<p>Alternately, you can reference labels using the actual C label name enclosed
in brackets.  For example, to reference a label named <tt class="docutils literal"><span class="pre">carry</span></tt>, you can
use <tt class="samp docutils literal"><span class="pre">%l[carry]</span></tt>.  The label must still be listed in the <tt class="docutils literal"><span class="pre">GotoLabels</span></tt>
section when using this approach.</p>
<p>Here is an example of <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> for i386:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="nf">goto</span> <span class="p">(</span>
    <span class="s">&quot;btl %1, %0</span><span class="se">\n\t</span><span class="s">&quot;</span>
    <span class="s">&quot;jc %l2&quot;</span>
    <span class="o">:</span> <span class="cm">/* No outputs. */</span>
    <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">&quot;cc&quot;</span>
    <span class="o">:</span> <span class="n">carry</span><span class="p">);</span>

<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">carry:</span>
<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>The following example shows an <tt class="docutils literal"><span class="pre">asm</span> <span class="pre">goto</span></tt> that uses a memory clobber.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">frob</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">asm</span> <span class="k">goto</span> <span class="p">(</span><span class="s">&quot;frob %%r5, %1; jc %l[error]; mov (%2), %%r5&quot;</span>
            <span class="o">:</span> <span class="cm">/* No outputs. */</span>
            <span class="o">:</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
            <span class="o">:</span> <span class="s">&quot;r5&quot;</span><span class="p">,</span> <span class="s">&quot;memory&quot;</span>
            <span class="o">:</span> <span class="n">error</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="nl">error:</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="x86-operand-modifiers">
<span id="x86operandmodifiers"></span><h3>x86 Operand Modifiers<a class="headerlink" href="#x86-operand-modifiers" title="Permalink to this headline">¶</a></h3>
<p>References to input, output, and goto operands in the assembler template
of extended <tt class="docutils literal"><span class="pre">asm</span></tt> statements can use
modifiers to affect the way the operands are formatted in
the code output to the assembler. For example, the
following code uses the <tt class="samp docutils literal"><span class="pre">h</span></tt> and <tt class="samp docutils literal"><span class="pre">b</span></tt> modifiers for x86:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint16_t</span>  <span class="n">num</span><span class="p">;</span>
<span class="k">asm</span> <span class="nf">volatile</span> <span class="p">(</span><span class="s">&quot;xchg %h0, %b0&quot;</span> <span class="o">:</span> <span class="s">&quot;+a&quot;</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>These modifiers generate this assembler code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">xchg</span> <span class="o">%</span><span class="n">ah</span><span class="p">,</span> <span class="o">%</span><span class="n">al</span>
</pre></div>
</div>
<p>The rest of this discussion uses the following code for illustrative purposes.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">iInt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">top:</span>

   <span class="k">asm</span> <span class="k">volatile</span> <span class="k">goto</span> <span class="p">(</span><span class="s">&quot;some assembler instructions here&quot;</span>
   <span class="o">:</span> <span class="cm">/* No outputs. */</span>
   <span class="o">:</span> <span class="s">&quot;q&quot;</span> <span class="p">(</span><span class="n">iInt</span><span class="p">),</span> <span class="s">&quot;X&quot;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
   <span class="o">:</span> <span class="cm">/* No clobbers. */</span>
   <span class="o">:</span> <span class="n">top</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With no modifiers, this is what the output from the operands would be for the
<tt class="samp docutils literal"><span class="pre">att</span></tt> and <tt class="samp docutils literal"><span class="pre">intel</span></tt> dialects of assembler:</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="24%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operand</th>
<th class="head">masm=att</th>
<th class="head">masm=intel</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">%0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">%eax</span></tt></td>
<td><tt class="docutils literal"><span class="pre">eax</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">%1</span></tt></td>
<td><tt class="docutils literal"><span class="pre">$2</span></tt></td>
<td><tt class="docutils literal"><span class="pre">2</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">%2</span></tt></td>
<td><tt class="docutils literal"><span class="pre">$.L2</span></tt></td>
<td><tt class="docutils literal"><span class="pre">OFFSET</span> <span class="pre">FLAT:.L2</span></tt></td>
</tr>
</tbody>
</table>
<p>The table below shows the list of supported modifiers and their effects.</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="75%" />
<col width="5%" />
<col width="6%" />
<col width="7%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Modifier</th>
<th class="head">Description</th>
<th class="head">Operand</th>
<th class="head">masm=att</th>
<th class="head">masm=intel</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">z</span></tt></td>
<td>Print the opcode suffix for the size of the current integer operand (one of <tt class="docutils literal"><span class="pre">b</span></tt>/<tt class="docutils literal"><span class="pre">w</span></tt>/<tt class="docutils literal"><span class="pre">l</span></tt>/<tt class="docutils literal"><span class="pre">q</span></tt>).</td>
<td><tt class="docutils literal"><span class="pre">%z0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">l</span></tt></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">b</span></tt></td>
<td>Print the QImode name of the register.</td>
<td><tt class="docutils literal"><span class="pre">%b0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">%al</span></tt></td>
<td><tt class="docutils literal"><span class="pre">al</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">h</span></tt></td>
<td>Print the QImode name for a &#8216;high&#8217; register.</td>
<td><tt class="docutils literal"><span class="pre">%h0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">%ah</span></tt></td>
<td><tt class="docutils literal"><span class="pre">ah</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">w</span></tt></td>
<td>Print the HImode name of the register.</td>
<td><tt class="docutils literal"><span class="pre">%w0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">%ax</span></tt></td>
<td><tt class="docutils literal"><span class="pre">ax</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">k</span></tt></td>
<td>Print the SImode name of the register.</td>
<td><tt class="docutils literal"><span class="pre">%k0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">%eax</span></tt></td>
<td><tt class="docutils literal"><span class="pre">eax</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">q</span></tt></td>
<td>Print the DImode name of the register.</td>
<td><tt class="docutils literal"><span class="pre">%q0</span></tt></td>
<td><tt class="docutils literal"><span class="pre">%rax</span></tt></td>
<td><tt class="docutils literal"><span class="pre">rax</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">l</span></tt></td>
<td>Print the label name with no punctuation.</td>
<td><tt class="docutils literal"><span class="pre">%l2</span></tt></td>
<td><tt class="docutils literal"><span class="pre">.L2</span></tt></td>
<td><tt class="docutils literal"><span class="pre">.L2</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">c</span></tt></td>
<td>Require a constant operand and print the constant expression with no punctuation.</td>
<td><tt class="docutils literal"><span class="pre">%c1</span></tt></td>
<td><tt class="docutils literal"><span class="pre">2</span></tt></td>
<td><tt class="docutils literal"><span class="pre">2</span></tt></td>
</tr>
</tbody>
</table>
<p id="x86floatingpointasmoperands">x86 Floating-Point <tt class="docutils literal"><span class="pre">asm</span></tt> OperandsOn x86 targets, there are several rules on the usage of stack-like registers
in the operands of an <tt class="docutils literal"><span class="pre">asm</span></tt>.  These rules apply only to the operands
that are stack-like registers:</p>
<ul>
<li><p class="first">Given a set of input registers that die in an <tt class="docutils literal"><span class="pre">asm</span></tt>, it is
necessary to know which are implicitly popped by the <tt class="docutils literal"><span class="pre">asm</span></tt>, and
which must be explicitly popped by GCC.</p>
<p>An input register that is implicitly popped by the <tt class="docutils literal"><span class="pre">asm</span></tt> must be
explicitly clobbered, unless it is constrained to match an
output operand.</p>
</li>
<li><p class="first">For any input register that is implicitly popped by an <tt class="docutils literal"><span class="pre">asm</span></tt>, it is
necessary to know how to adjust the stack to compensate for the pop.
If any non-popped input is closer to the top of the reg-stack than
the implicitly popped register, it would not be possible to know what the
stack looked like-it&#8217;s not clear how the rest of the stack &#8216;slides
up&#8217;.</p>
<p>All implicitly popped input registers must be closer to the top of
the reg-stack than any input that is not implicitly popped.</p>
<p>It is possible that if an input dies in an <tt class="docutils literal"><span class="pre">asm</span></tt>, the compiler might
use the input register for an output reload.  Consider this example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;foo&quot;</span> <span class="o">:</span> <span class="s">&quot;=t&quot;</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">b</span><span class="p">));</span>
</pre></div>
</div>
<p>This code says that input <tt class="docutils literal"><span class="pre">b</span></tt> is not popped by the <tt class="docutils literal"><span class="pre">asm</span></tt>, and that
the <tt class="docutils literal"><span class="pre">asm</span></tt> pushes a result onto the reg-stack, i.e., the stack is one
deeper after the <tt class="docutils literal"><span class="pre">asm</span></tt> than it was before.  But, it is possible that
reload may think that it can use the same register for both the input and
the output.</p>
<p>To prevent this from happening,
if any input operand uses the <tt class="samp docutils literal"><span class="pre">f</span></tt> constraint, all output register
constraints must use the <tt class="samp docutils literal"><span class="pre">&amp;</span></tt> early-clobber modifier.</p>
<p>The example above is correctly written as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;foo&quot;</span> <span class="o">:</span> <span class="s">&quot;=&amp;t&quot;</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;f&quot;</span> <span class="p">(</span><span class="n">b</span><span class="p">));</span>
</pre></div>
</div>
</li>
<li><p class="first">Some operands need to be in particular places on the stack.  All
output operands fall in this category-GCC has no other way to
know which registers the outputs appear in unless you indicate
this in the constraints.</p>
<p>Output operands must specifically indicate which register an output
appears in after an <tt class="docutils literal"><span class="pre">asm</span></tt>.  <tt class="samp docutils literal"><span class="pre">=f</span></tt> is not allowed: the operand
constraints must select a class with a single register.</p>
</li>
<li><p class="first">Output operands may not be &#8216;inserted&#8217; between existing stack registers.
Since no 387 opcode uses a read/write operand, all output operands
are dead before the <tt class="docutils literal"><span class="pre">asm</span></tt>, and are pushed by the <tt class="docutils literal"><span class="pre">asm</span></tt>.
It makes no sense to push anywhere but the top of the reg-stack.</p>
<p>Output operands must start at the top of the reg-stack: output
operands may not &#8216;skip&#8217; a register.</p>
</li>
<li><p class="first">Some <tt class="docutils literal"><span class="pre">asm</span></tt> statements may need extra stack space for internal
calculations.  This can be guaranteed by clobbering stack registers
unrelated to the inputs and outputs.</p>
</li>
</ul>
<p>This <tt class="docutils literal"><span class="pre">asm</span></tt>
takes one input, which is internally popped, and produces two outputs.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;fsincos&quot;</span> <span class="o">:</span> <span class="s">&quot;=t&quot;</span> <span class="p">(</span><span class="n">cos</span><span class="p">),</span> <span class="s">&quot;=u&quot;</span> <span class="p">(</span><span class="n">sin</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">inp</span><span class="p">));</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">asm</span></tt> takes two inputs, which are popped by the <tt class="docutils literal"><span class="pre">fyl2xp1</span></tt> opcode,
and replaces them with one output.  The <tt class="docutils literal"><span class="pre">st(1)</span></tt> clobber is necessary
for the compiler to know that <tt class="docutils literal"><span class="pre">fyl2xp1</span></tt> pops both inputs.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;fyl2xp1&quot;</span> <span class="o">:</span> <span class="s">&quot;=t&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot;u&quot;</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;st(1)&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p id="constraints">Constraints for <tt class="docutils literal"><span class="pre">asm</span></tt> Operands
.. index:: operand constraints, asm</p>
<span class="target" id="index-16"></span><p id="index-17">Here are specific details on what constraint letters you can use with
<tt class="docutils literal"><span class="pre">asm</span></tt> operands.
Constraints can say whether
an operand may be in a register, and which kinds of register; whether the
operand can be a memory reference, and which kinds of address; whether the
operand may be an immediate constant, and which possible values it may
have.  Constraints can also require two operands to match.
Side-effects aren&#8217;t allowed in operands of inline <tt class="docutils literal"><span class="pre">asm</span></tt>, unless
<tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt> constraints are used, because there is no guarantee
that the side-effects will happen exactly once in an instruction that can update
the addressing register.</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
</div>
<div class="section" id="simple-constraints">
<span id="id6"></span><h3>Simple Constraints<a class="headerlink" href="#simple-constraints" title="Permalink to this headline">¶</a></h3>
<p id="index-18">The simplest kind of constraint is a string full of letters, each of
which describes one kind of operand that is permitted.  Here are
the letters that are allowed:</p>
<dl class="docutils">
<dt>whitespace</dt>
<dd>Whitespace characters are ignored and can be inserted at any position
except the first.  This enables each alternative for different operands to
be visually aligned in the machine description even if they have different
number of constraints and modifiers.<span class="target" id="index-19"></span></dd>
<dt>m</dt>
<dd>A memory operand is allowed, with any kind of address that the machine
supports in general.
Note that the letter used for the general memory constraint can be
re-defined by a back end using the <tt class="docutils literal"><span class="pre">TARGET_MEM_CONSTRAINT</span></tt> macro.<span class="target" id="index-21"></span></dd>
<dt>o</dt>
<dd><p class="first">A memory operand is allowed, but only if the address is
<em class="dfn">offsettable</em>.  This means that adding a small integer (actually,
the width in bytes of the operand, as determined by its machine mode)
may be added to the address and the result is also a valid memory
address.</p>
<p id="index-23">For example, an address which is constant is offsettable; so is an
address that is the sum of a register and a constant (as long as a
slightly larger constant is also within the range of address-offsets
supported by the machine); but an autoincrement or autodecrement
address is not offsettable.  More complicated indirect/indexed
addresses may or may not be offsettable depending on the other
addressing modes that the machine supports.</p>
<p class="last">Note that in an output operand which can be matched by another
operand, the constraint letter <tt class="samp docutils literal"><span class="pre">o</span></tt> is valid only when accompanied
by both <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> (if the target machine has predecrement addressing)
and <tt class="samp docutils literal"><span class="pre">&gt;</span></tt> (if the target machine has preincrement addressing).</p>
</dd>
<dt>V</dt>
<dd>A memory operand that is not offsettable.  In other words, anything that
would fit the <tt class="samp docutils literal"><span class="pre">m</span></tt> constraint but not the <tt class="samp docutils literal"><span class="pre">o</span></tt> constraint.</dd>
</dl>
<dl class="docutils">
<dt>&lt;</dt>
<dd>A memory operand with autodecrement addressing (either predecrement or
postdecrement) is allowed.  In inline <tt class="docutils literal"><span class="pre">asm</span></tt> this constraint is only
allowed if the operand is used exactly once in an instruction that can
handle the side-effects.  Not using an operand with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> in constraint
string in the inline <tt class="docutils literal"><span class="pre">asm</span></tt> pattern at all or using it in multiple
instructions isn&#8217;t valid, because the side-effects wouldn&#8217;t be performed
or would be performed more than once.  Furthermore, on some targets
the operand with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> in constraint string must be accompanied by
special instruction suffixes like <tt class="docutils literal"><span class="pre">%U0</span></tt> instruction suffix on PowerPC
or <tt class="docutils literal"><span class="pre">%P0</span></tt> on IA-64.</dd>
</dl>
<dl class="docutils">
<dt>&gt;</dt>
<dd>A memory operand with autoincrement addressing (either preincrement or
postincrement) is allowed.  In inline <tt class="docutils literal"><span class="pre">asm</span></tt> the same restrictions
as for <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> apply.<span class="target" id="index-27"></span></dd>
<dt>r</dt>
<dd>A register operand is allowed provided that it is in a general
register.<span class="target" id="index-29"></span></dd>
<dt>i</dt>
<dd>An immediate integer operand (one with constant value) is allowed.
This includes symbolic constants whose values will be known only at
assembly time or later.</dd>
<dt>n</dt>
<dd>An immediate integer operand with a known numeric value is allowed.
Many systems cannot support assembly-time constants for operands less
than a word wide.  Constraints for these operands should use <tt class="samp docutils literal"><span class="pre">n</span></tt>
rather than <tt class="samp docutils literal"><span class="pre">i</span></tt>.</dd>
<dt><tt class="samp docutils literal"><em><span class="pre">I</span></em><span class="pre">,</span> <em><span class="pre">J</span></em><span class="pre">,</span> <em><span class="pre">K</span></em><span class="pre">,</span> <span class="pre">...</span> <em><span class="pre">P</span></em></tt></dt>
<dd>Other letters in the range <tt class="samp docutils literal"><span class="pre">I</span></tt> through <tt class="samp docutils literal"><span class="pre">P</span></tt> may be defined in
a machine-dependent fashion to permit immediate integer operands with
explicit integer values in specified ranges.  For example, on the
68000, <tt class="samp docutils literal"><span class="pre">I</span></tt> is defined to stand for the range of values 1 to 8.
This is the range permitted as a shift count in the shift
instructions.</dd>
<dt>E</dt>
<dd>An immediate floating operand (expression code <tt class="docutils literal"><span class="pre">const_double</span></tt>) is
allowed, but only if the target floating point format is the same as
that of the host machine (on which the compiler is running).</dd>
<dt>F</dt>
<dd>An immediate floating operand (expression code <tt class="docutils literal"><span class="pre">const_double</span></tt> or
<tt class="docutils literal"><span class="pre">const_vector</span></tt>) is allowed.<span class="target" id="index-35"></span></dd>
<dt><tt class="samp docutils literal"><em><span class="pre">G</span></em><span class="pre">,</span> <em><span class="pre">H</span></em></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">G</span></tt> and <tt class="samp docutils literal"><span class="pre">H</span></tt> may be defined in a machine-dependent fashion to
permit immediate floating operands in particular ranges of values.</dd>
<dt>s</dt>
<dd><p class="first">An immediate integer operand whose value is not an explicit integer is
allowed.</p>
<p>This might appear strange; if an insn allows a constant operand with a
value not known at compile time, it certainly must allow any known
value.  So why use <tt class="samp docutils literal"><span class="pre">s</span></tt> instead of <tt class="samp docutils literal"><span class="pre">i</span></tt>?  Sometimes it allows
better code to be generated.</p>
<p class="last">For example, on the 68000 in a fullword instruction it is possible to
use an immediate operand; but if the immediate value is between -128
and 127, better code results from loading the value into a register and
using the register.  This is because the load into the register can be
done with a <tt class="samp docutils literal"><span class="pre">moveq</span></tt> instruction.  We arrange for this to happen
by defining the letter <tt class="samp docutils literal"><span class="pre">K</span></tt> to mean &#8216;any integer outside the
range -128 to 127&#8217;, and then specifying <tt class="samp docutils literal"><span class="pre">Ks</span></tt> in the operand
constraints.</p>
</dd>
<dt>g</dt>
<dd>Any register, memory or immediate integer operand is allowed, except for
registers that are not general registers.</dd>
<dt>X</dt>
<dd>Any operand whatsoever is allowed.<span class="target" id="index-40"></span></dd>
<dt><tt class="samp docutils literal"><em><span class="pre">0</span></em><span class="pre">,</span> <em><span class="pre">1</span></em><span class="pre">,</span> <em><span class="pre">2</span></em><span class="pre">,</span> <span class="pre">...</span> <em><span class="pre">9</span></em></tt></dt>
<dd><p class="first">An operand that matches the specified operand number is allowed.  If a
digit is used together with letters within the same alternative, the
digit should come last.</p>
<p>This number is allowed to be more than a single digit.  If multiple
digits are encountered consecutively, they are interpreted as a single
decimal integer.  There is scant chance for ambiguity, since to-date
it has never been desirable that <tt class="samp docutils literal"><span class="pre">10</span></tt> be interpreted as matching
either operand 1 <em>or</em> operand 0.  Should this be desired, one
can use multiple alternatives instead.</p>
<span class="target" id="index-42"></span><p id="index-43">This is called a <em class="dfn">matching constraint</em> and what it really means is
that the assembler has only a single operand that fills two roles
which <tt class="docutils literal"><span class="pre">asm</span></tt> distinguishes.  For example, an add instruction uses
two input operands and an output operand, but on most CISC
machines an add instruction really has only two operands, one of them an
input-output operand:</p>
<div class="highlight-c++"><pre>addl #35,r12</pre>
</div>
<p class="last">Matching constraints are used in these circumstances.
More precisely, the two operands that match must include one input-only
operand and one output-only operand.  Moreover, the digit must be a
smaller number than the number of the operand that uses it in the
constraint.</p>
<span class="target" id="index-44"></span><span class="target" id="index-45"></span><span class="target" id="index-46"></span></dd>
<dt>p</dt>
<dd><p class="first">An operand that is a valid memory address is allowed.  This is
for &#8216;load address&#8217; and &#8216;push address&#8217; instructions.</p>
<p class="last" id="index-48"><tt class="samp docutils literal"><span class="pre">p</span></tt> in the constraint must be accompanied by <tt class="docutils literal"><span class="pre">address_operand</span></tt>
as the predicate in the <tt class="docutils literal"><span class="pre">match_operand</span></tt>.  This predicate interprets
the mode specified in the <tt class="docutils literal"><span class="pre">match_operand</span></tt> as the mode of the memory
reference for which the address would be valid.</p>
<span class="target" id="index-49"></span></dd>
<dt>other-letters</dt>
<dd>Other letters can be defined in machine-dependent fashion to stand for
particular classes of registers or other arbitrary operand types.
<tt class="samp docutils literal"><span class="pre">d</span></tt>, <tt class="samp docutils literal"><span class="pre">a</span></tt> and <tt class="samp docutils literal"><span class="pre">f</span></tt> are defined on the 68000/68020 to stand
for data, address and floating point registers.</dd>
</dl>
</div>
<div class="section" id="multiple-alternative-constraints">
<span id="multi-alternative"></span><h3>Multiple Alternative Constraints<a class="headerlink" href="#multiple-alternative-constraints" title="Permalink to this headline">¶</a></h3>
<p id="index-51">Sometimes a single instruction has multiple alternative sets of possible
operands.  For example, on the 68000, a logical-or instruction can combine
register or an immediate value into memory, or it can combine any kind of
operand into a register; but it cannot combine one memory location into
another.</p>
<p>These constraints are represented as multiple alternatives.  An alternative
can be described by a series of letters for each operand.  The overall
constraint for an operand is made from the letters for this operand
from the first alternative, a comma, the letters for this operand from
the second alternative, a comma, and so on until the last alternative.</p>
<p>If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many instructions
must be added to copy the operands so that that alternative applies.
The alternative requiring the least copying is chosen.  If two alternatives
need the same amount of copying, the one that comes first is chosen.
These choices can be altered with the <tt class="samp docutils literal"><span class="pre">?</span></tt> and <tt class="samp docutils literal"><span class="pre">!</span></tt> characters:</p>
<span class="target" id="index-52"></span><dl class="docutils" id="index-53">
<dt><tt class="docutils literal"><span class="pre">?</span></tt></dt>
<dd>Disparage slightly the alternative that the <tt class="samp docutils literal"><span class="pre">?</span></tt> appears in,
as a choice when no alternative applies exactly.  The compiler regards
this alternative as one unit more costly for each <tt class="samp docutils literal"><span class="pre">?</span></tt> that appears
in it.<span class="target" id="index-54"></span></dd>
<dt><tt class="docutils literal"><span class="pre">!</span></tt></dt>
<dd>Disparage severely the alternative that the <tt class="samp docutils literal"><span class="pre">!</span></tt> appears in.
This alternative can still be used if it fits without reloading,
but if reloading is needed, some other alternative will be used.<span class="target" id="index-56"></span></dd>
<dt><tt class="docutils literal"><span class="pre">^</span></tt></dt>
<dd>This constraint is analogous to <tt class="samp docutils literal"><span class="pre">?</span></tt> but it disparages slightly
the alternative only if the operand with the <tt class="samp docutils literal"><span class="pre">^</span></tt> needs a reload.<span class="target" id="index-58"></span></dd>
<dt><tt class="docutils literal"><span class="pre">$</span></tt></dt>
<dd>This constraint is analogous to <tt class="samp docutils literal"><span class="pre">!</span></tt> but it disparages severely
the alternative only if the operand with the <tt class="samp docutils literal"><span class="pre">$</span></tt> needs a reload.</dd>
</dl>
</div>
<div class="section" id="constraint-modifier-characters">
<span id="modifiers"></span><h3>Constraint Modifier Characters<a class="headerlink" href="#constraint-modifier-characters" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-60"></span><span class="target" id="index-61"></span><p>Here are constraint modifier characters.</p>
<dl class="docutils" id="index-62">
<dt><tt class="samp docutils literal"><span class="pre">=</span></tt></dt>
<dd>Means that this operand is written to by this instruction:
the previous value is discarded and replaced by new data.</dd>
<dt><tt class="samp docutils literal"><span class="pre">+</span></tt></dt>
<dd><p class="first">Means that this operand is both read and written by the instruction.</p>
<p>When the compiler fixes up the operands to satisfy the constraints,
it needs to know which operands are read by the instruction and
which are written by it.  <tt class="samp docutils literal"><span class="pre">=</span></tt> identifies an operand which is only
written; <tt class="samp docutils literal"><span class="pre">+</span></tt> identifies an operand that is both read and written; all
other operands are assumed to only be read.</p>
<p class="last">If you specify <tt class="samp docutils literal"><span class="pre">=</span></tt> or <tt class="samp docutils literal"><span class="pre">+</span></tt> in a constraint, you put it in the
first character of the constraint string.</p>
<span class="target" id="index-64"></span></dd>
<dt><tt class="samp docutils literal"><span class="pre">&amp;</span></tt></dt>
<dd><p class="first">Means (in a particular alternative) that this operand is an
<em class="dfn">earlyclobber</em> operand, which is written before the instruction is
finished using the input operands.  Therefore, this operand may not lie
in a register that is read by the instruction or as part of any memory
address.</p>
<p><tt class="samp docutils literal"><span class="pre">&amp;</span></tt> applies only to the alternative in which it is written.  In
constraints with multiple alternatives, sometimes one alternative
requires <tt class="samp docutils literal"><span class="pre">&amp;</span></tt> while others do not.  See, for example, the
<tt class="samp docutils literal"><span class="pre">movdf</span></tt> insn of the 68000.</p>
<p>A operand which is read by the instruction can be tied to an earlyclobber
operand if its only use as an input occurs before the early result is
written.  Adding alternatives of this form often allows GCC to produce
better code when only some of the read operands can be affected by the
earlyclobber. See, for example, the <tt class="samp docutils literal"><span class="pre">mulsi3</span></tt> insn of the ARM.</p>
<p>Furthermore, if the <em class="dfn">earlyclobber</em> operand is also a read/write
operand, then that operand is written only after it&#8217;s used.</p>
<p class="last"><tt class="samp docutils literal"><span class="pre">&amp;</span></tt> does not obviate the need to write <tt class="samp docutils literal"><span class="pre">=</span></tt> or <tt class="samp docutils literal"><span class="pre">+</span></tt>.  As
<em class="dfn">earlyclobber</em> operands are always written, a read-only
<em class="dfn">earlyclobber</em> operand is ill-formed and will be rejected by the
compiler.</p>
</dd>
<dt><tt class="samp docutils literal"><span class="pre">%</span></tt></dt>
<dd><p class="first">Declares the instruction to be commutative for this operand and the
following operand.  This means that the compiler may interchange the
two operands if that is the cheapest way to make all operands fit the
constraints.  <tt class="samp docutils literal"><span class="pre">%</span></tt> applies to all alternatives and must appear as
the first character in the constraint.  Only read-only operands can use
<tt class="samp docutils literal"><span class="pre">%</span></tt>.</p>
<p class="last">GCC can only handle one commutative pair in an asm; if you use more,
the compiler may fail.  Note that you need not use the modifier if
the two alternatives are strictly identical; this would only waste
time in the reload pass.  The modifier is not operational after
register allocation, so the result of <tt class="docutils literal"><span class="pre">define_peephole2</span></tt>
and <a href="#id7"><span class="problematic" id="id8">``</span></a>define_split``s performed after reload cannot rely on
<tt class="samp docutils literal"><span class="pre">%</span></tt> to make the intended insn match.</p>
</dd>
<dt><tt class="samp docutils literal"><span class="pre">#</span></tt></dt>
<dd>Says that all following characters, up to the next comma, are to be
ignored as a constraint.  They are significant only for choosing
register preferences.</dd>
<dt><tt class="samp docutils literal"><span class="pre">*</span></tt></dt>
<dd>Says that the following character should be ignored when choosing
register preferences.  <tt class="samp docutils literal"><span class="pre">*</span></tt> has no effect on the meaning of the
constraint as a constraint, and no effect on reloading.  For LRA
<tt class="samp docutils literal"><span class="pre">*</span></tt> additionally disparages slightly the alternative if the
following character matches the operand.</dd>
</dl>
</div>
<div class="section" id="constraints-for-particular-machines">
<span id="machine-constraints"></span><h3>Constraints for Particular Machines<a class="headerlink" href="#constraints-for-particular-machines" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-69"></span><p id="index-70">Whenever possible, you should use the general-purpose constraint letters
in <tt class="docutils literal"><span class="pre">asm</span></tt> arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters
that usually have very similar meanings across architectures.  The most
commonly used constraints are <tt class="samp docutils literal"><span class="pre">m</span></tt> and <tt class="samp docutils literal"><span class="pre">r</span></tt> (for memory and
general-purpose registers respectively; see <a class="reference internal" href="#simple-constraints"><em>Simple Constraints</em></a>), and
<tt class="samp docutils literal"><span class="pre">I</span></tt>, usually the letter indicating the most common
immediate-constant format.</p>
<p>Each architecture defines additional constraints.  These constraints
are used by the compiler itself for instruction generation, as well as
for <tt class="docutils literal"><span class="pre">asm</span></tt> statements; therefore, some of the constraints are not
particularly useful for <tt class="docutils literal"><span class="pre">asm</span></tt>.  Here is a summary of some of the
machine-dependent constraints available on some particular machines;
it includes both constraints that are useful for <tt class="docutils literal"><span class="pre">asm</span></tt> and
constraints that aren&#8217;t.  The compiler source file mentioned in the
table heading for each architecture is the definitive reference for
the meanings of that architecture&#8217;s constraints.</p>
<p><tt class="samp docutils literal"><span class="pre">AArch64</span> <span class="pre">family-</span><em><span class="pre">config/aarch64/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">k</span></tt></dt>
<dd>The stack pointer register (<tt class="docutils literal"><span class="pre">SP</span></tt>)</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>Floating point or SIMD vector register</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Integer constant that is valid as an immediate operand in an <tt class="docutils literal"><span class="pre">ADD</span></tt>
instruction</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Integer constant that is valid as an immediate operand in a <tt class="docutils literal"><span class="pre">SUB</span></tt>
instruction (once negated)</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Integer constant that can be used with a 32-bit logical instruction</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer constant that can be used with a 64-bit logical instruction</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Integer constant that is valid as an immediate operand in a 32-bit <tt class="docutils literal"><span class="pre">MOV</span></tt>
pseudo instruction. The <tt class="docutils literal"><span class="pre">MOV</span></tt> may be assembled to one of several different
machine instructions depending on the value</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Integer constant that is valid as an immediate operand in a 64-bit <tt class="docutils literal"><span class="pre">MOV</span></tt>
pseudo instruction</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>An absolute symbolic address or a label reference</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>Floating point constant zero</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>Integer constant zero</dd>
<dt><tt class="docutils literal"><span class="pre">Ush</span></tt></dt>
<dd>The high part (bits 12 and upwards) of the pc-relative address of a symbol
within 4GB of the instruction</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>A memory address which uses a single base register with no offset</dd>
<dt><tt class="docutils literal"><span class="pre">Ump</span></tt></dt>
<dd>A memory address suitable for a load/store pair instruction in SI, DI, SF and
DF modes</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">ARC</span> <span class="pre">-</span><em><span class="pre">config/arc/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">q</span></tt></dt>
<dd>Registers usable in ARCompact 16-bit instructions: <tt class="docutils literal"><span class="pre">r0</span></tt>-<tt class="docutils literal"><span class="pre">r3</span></tt>,
<tt class="docutils literal"><span class="pre">r12</span></tt>-<tt class="docutils literal"><span class="pre">r15</span></tt>.  This constraint can only match when the <em class="xref std std-option">-mq</em>
option is in effect.</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>Registers usable as base-regs of memory addresses in ARCompact 16-bit memory
instructions: <tt class="docutils literal"><span class="pre">r0</span></tt>-<tt class="docutils literal"><span class="pre">r3</span></tt>, <tt class="docutils literal"><span class="pre">r12</span></tt>-<tt class="docutils literal"><span class="pre">r15</span></tt>, <tt class="docutils literal"><span class="pre">sp</span></tt>.
This constraint can only match when the <em class="xref std std-option">-mq</em>
option is in effect.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>ARC FPX (dpfp) 64-bit registers. <tt class="docutils literal"><span class="pre">D0</span></tt>, <tt class="docutils literal"><span class="pre">D1</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>A signed 12-bit integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">Cal</span></tt></dt>
<dd>constant for arithmetic/logical operations.  This might be any constant
that can be put into a long immediate by the assmbler or linker without
involving a PIC relocation.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>A 3-bit unsigned integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>A 6-bit unsigned integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">CnL</span></tt></dt>
<dd>One&#8217;s complement of a 6-bit unsigned integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">CmL</span></tt></dt>
<dd>Two&#8217;s complement of a 6-bit unsigned integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>A 5-bit unsigned integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>A 7-bit unsigned integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>A 8-bit unsigned integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">H</span></tt></dt>
<dd>Any const_double value.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">ARM</span> <span class="pre">family-</span><em><span class="pre">config/arm/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd>In Thumb state, the core registers <tt class="docutils literal"><span class="pre">r8</span></tt>-<tt class="docutils literal"><span class="pre">r15</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">k</span></tt></dt>
<dd>The stack pointer register.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>In Thumb State the core registers <tt class="docutils literal"><span class="pre">r0</span></tt>-<tt class="docutils literal"><span class="pre">r7</span></tt>.  In ARM state this
is an alias for the <tt class="docutils literal"><span class="pre">r</span></tt> constraint.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>VFP floating-point registers <tt class="docutils literal"><span class="pre">s0</span></tt>-<tt class="docutils literal"><span class="pre">s31</span></tt>.  Used for 32 bit values.</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>VFP floating-point registers <tt class="docutils literal"><span class="pre">d0</span></tt>-<tt class="docutils literal"><span class="pre">d31</span></tt> and the appropriate
subset <tt class="docutils literal"><span class="pre">d0</span></tt>-<tt class="docutils literal"><span class="pre">d15</span></tt> based on command line options.
Used for 64 bit values only.  Not valid for Thumb1.</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>The iWMMX co-processor registers.</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>The iWMMX GR registers.</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>The floating-point constant 0.0</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Integer that is valid as an immediate operand in a data processing
instruction.  That is, an integer in the range 0 to 255 rotated by a
multiple of 2</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Integer in the range -4095 to 4095</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Integer that satisfies constraint <tt class="samp docutils literal"><span class="pre">I</span></tt> when inverted (ones complement)</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer that satisfies constraint <tt class="samp docutils literal"><span class="pre">I</span></tt> when negated (twos complement)</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Integer in the range 0 to 32</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>A memory reference where the exact address is in a single register
(&#8216;<tt class="samp docutils literal"><span class="pre">m</span></tt>&#8216; is preferable for <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>An item in the constant pool</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>A symbol in the text segment of the current file</dd>
<dt><tt class="docutils literal"><span class="pre">Uv</span></tt></dt>
<dd>A memory reference suitable for VFP load/store insns (reg+constant offset)</dd>
<dt><tt class="docutils literal"><span class="pre">Uy</span></tt></dt>
<dd>A memory reference suitable for iWMMXt load/store instructions.</dd>
<dt><tt class="docutils literal"><span class="pre">Uq</span></tt></dt>
<dd>A memory reference suitable for the ARMv4 ldrsb instruction.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">AVR</span> <span class="pre">family-</span><em><span class="pre">config/avr/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>Registers from r0 to r15</dd>
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Registers from r16 to r23</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Registers from r16 to r31</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>Registers from r24 to r31.  These registers can be used in <tt class="samp docutils literal"><span class="pre">adiw</span></tt> command</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>Pointer register (r26-r31)</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Base pointer register (r28-r31)</dd>
<dt><tt class="docutils literal"><span class="pre">q</span></tt></dt>
<dd>Stack pointer register (SPH:SPL)</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Temporary register r0</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>Register pair X (r27:r26)</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>Register pair Y (r29:r28)</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>Register pair Z (r31:r30)</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Constant greater than -1, less than 64</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Constant greater than -64, less than 1</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Constant integer 2</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Constant integer 0</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Constant that fits in 8 bits</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Constant integer -1</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>Constant integer 8, 16, or 24</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>Constant integer 1</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>A floating point constant 0.0</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>A memory address based on Y or Z pointer with displacement.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Blackfin</span> <span class="pre">family-</span><em><span class="pre">config/bfin/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>P register</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>D register</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>A call clobbered P register.</dd>
<dt><tt class="samp docutils literal"><span class="pre">q</span><em><span class="pre">n</span></em></tt></dt>
<dd>A single register.  If <tt class="docutils literal"><span class="pre">n</span></tt> is in the range 0 to 7, the corresponding D
register.  If it is <tt class="docutils literal"><span class="pre">A</span></tt>, then the register P0.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>Even-numbered D register</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>Odd-numbered D register</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>Accumulator register.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>Even-numbered accumulator register.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt></dt>
<dd>Odd-numbered accumulator register.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>I register</dd>
<dt><tt class="docutils literal"><span class="pre">v</span></tt></dt>
<dd>B register</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>M register</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Registers used for circular buffering, i.e. I, B, or L registers.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>The CC register.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>LT0 or LT1.</dd>
<dt><tt class="docutils literal"><span class="pre">k</span></tt></dt>
<dd>LC0 or LC1.</dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt></dt>
<dd>LB0 or LB1.</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>Any D, P, B, M, I or L register.</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>Additional registers typically used only in prologues and epilogues: RETS,
RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>Any register except accumulators or CC.</dd>
<dt><tt class="docutils literal"><span class="pre">Ksh</span></tt></dt>
<dd>Signed 16 bit integer (in the range -32768 to 32767)</dd>
<dt><tt class="docutils literal"><span class="pre">Kuh</span></tt></dt>
<dd>Unsigned 16 bit integer (in the range 0 to 65535)</dd>
<dt><tt class="docutils literal"><span class="pre">Ks7</span></tt></dt>
<dd>Signed 7 bit integer (in the range -64 to 63)</dd>
<dt><tt class="docutils literal"><span class="pre">Ku7</span></tt></dt>
<dd>Unsigned 7 bit integer (in the range 0 to 127)</dd>
<dt><tt class="docutils literal"><span class="pre">Ku5</span></tt></dt>
<dd>Unsigned 5 bit integer (in the range 0 to 31)</dd>
<dt><tt class="docutils literal"><span class="pre">Ks4</span></tt></dt>
<dd>Signed 4 bit integer (in the range -8 to 7)</dd>
<dt><tt class="docutils literal"><span class="pre">Ks3</span></tt></dt>
<dd>Signed 3 bit integer (in the range -3 to 4)</dd>
<dt><tt class="docutils literal"><span class="pre">Ku3</span></tt></dt>
<dd>Unsigned 3 bit integer (in the range 0 to 7)</dd>
<dt><tt class="samp docutils literal"><span class="pre">P</span><em><span class="pre">n</span></em></tt></dt>
<dd>Constant <tt class="docutils literal"><span class="pre">n</span></tt>, where <tt class="docutils literal"><span class="pre">n</span></tt> is a single-digit constant in the range 0 to 4.</dd>
<dt><tt class="docutils literal"><span class="pre">PA</span></tt></dt>
<dd>An integer equal to one of the MACFLAG_XXX constants that is suitable for
use with either accumulator.</dd>
<dt><tt class="docutils literal"><span class="pre">PB</span></tt></dt>
<dd>An integer equal to one of the MACFLAG_XXX constants that is suitable for
use only with accumulator A1.</dd>
<dt><tt class="docutils literal"><span class="pre">M1</span></tt></dt>
<dd>Constant 255.</dd>
<dt><tt class="docutils literal"><span class="pre">M2</span></tt></dt>
<dd>Constant 65535.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>An integer constant with exactly a single bit set.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>An integer constant with all bits set except exactly one.</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">H</span></tt></p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Any SYMBOL_REF.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">CR16</span> <span class="pre">Architecture-</span><em><span class="pre">config/cr16/cr16.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Registers from r0 to r14 (registers without stack pointer)</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Register from r0 to r11 (all 16-bit registers)</dd>
<dt><tt class="docutils literal"><span class="pre">p</span></tt></dt>
<dd>Register from r12 to r15 (all 32-bit registers)</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Signed constant that fits in 4 bits</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Signed constant that fits in 5 bits</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Signed constant that fits in 6 bits</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Unsigned constant that fits in 4 bits</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Signed constant that fits in 32 bits</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Check for 64 bits wide constants for add/sub instructions</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating point constant that is legal for store immediate</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Epiphany-</span><em><span class="pre">config/epiphany/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">U16</span></tt></dt>
<dd>An unsigned 16-bit constant.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>An unsigned 5-bit constant.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>A signed 11-bit constant.</dd>
<dt><tt class="docutils literal"><span class="pre">Cm1</span></tt></dt>
<dd>A signed 11-bit constant added to -1.
Can only match when the <em class="xref std std-option">-m1reg-``reg``</em> option is active.</dd>
<dt><tt class="docutils literal"><span class="pre">Cl1</span></tt></dt>
<dd>Left-shift of -1, i.e., a bit mask with a block of leading ones, the rest
being a block of trailing zeroes.
Can only match when the <em class="xref std std-option">-m1reg-``reg``</em> option is active.</dd>
<dt><tt class="docutils literal"><span class="pre">Cr1</span></tt></dt>
<dd>Right-shift of -1, i.e., a bit mask with a trailing block of ones, the
rest being zeroes.  Or to put it another way, one less than a power of two.
Can only match when the <em class="xref std std-option">-m1reg-``reg``</em> option is active.</dd>
<dt><tt class="docutils literal"><span class="pre">Cal</span></tt></dt>
<dd>Constant for arithmetic/logical operations.
This is like <tt class="docutils literal"><span class="pre">i</span></tt>, except that for position independent code,
no symbols / expressions needing relocations are allowed.</dd>
<dt><tt class="docutils literal"><span class="pre">Csy</span></tt></dt>
<dd>Symbolic constant for call/jump instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Rcs</span></tt></dt>
<dd>The register class usable in short insns.  This is a register class
constraint, and can thus drive register allocation.
This constraint won&#8217;t match unless <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-mprefer-short-insn-regs"><em class="xref std std-option">-mprefer-short-insn-regs</em></a> is
in effect.</dd>
<dt><tt class="docutils literal"><span class="pre">Rsc</span></tt></dt>
<dd>The the register class of registers that can be used to hold a
sibcall call address.  I.e., a caller-saved register.</dd>
<dt><tt class="docutils literal"><span class="pre">Rct</span></tt></dt>
<dd>Core control register class.</dd>
<dt><tt class="docutils literal"><span class="pre">Rgs</span></tt></dt>
<dd>The register group usable in short insns.
This constraint does not use a register class, so that it only
passively matches suitable registers, and doesn&#8217;t drive register allocation.</dd>
<dt><tt class="docutils literal"><span class="pre">Rra</span></tt></dt>
<dd>Matches the return address if it can be replaced with the link register.</dd>
<dt><tt class="docutils literal"><span class="pre">Rcc</span></tt></dt>
<dd>Matches the integer condition code register.</dd>
<dt><tt class="docutils literal"><span class="pre">Sra</span></tt></dt>
<dd>Matches the return address if it is in a stack slot.</dd>
<dt><tt class="docutils literal"><span class="pre">Cfm</span></tt></dt>
<dd>Matches control register values to switch fp mode, which are encapsulated in
<tt class="docutils literal"><span class="pre">UNSPEC_FP_MODE</span></tt>.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">FRV-</span><em><span class="pre">config/frv/frv.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ACC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">acc0</span></tt> to <tt class="docutils literal"><span class="pre">acc7</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">EVEN_ACC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">acc0</span></tt> to <tt class="docutils literal"><span class="pre">acc7</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">CC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fcc0</span></tt> to <tt class="docutils literal"><span class="pre">fcc3</span></tt> and
<tt class="docutils literal"><span class="pre">icc0</span></tt> to <tt class="docutils literal"><span class="pre">icc3</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">GPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">gr0</span></tt> to <tt class="docutils literal"><span class="pre">gr63</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">EVEN_REGS</span></tt> (<tt class="docutils literal"><span class="pre">gr0</span></tt> to <tt class="docutils literal"><span class="pre">gr63</span></tt>).
Odd registers are excluded not in the class but through the use of a machine
mode larger than 4 bytes.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fr0</span></tt> to <tt class="docutils literal"><span class="pre">fr63</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FEVEN_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fr0</span></tt> to <tt class="docutils literal"><span class="pre">fr63</span></tt>).
Odd registers are excluded not in the class but through the use of a machine
mode larger than 4 bytes.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">LR_REG</span></tt> (the <tt class="docutils literal"><span class="pre">lr</span></tt> register).</dd>
<dt><tt class="docutils literal"><span class="pre">q</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">QUAD_REGS</span></tt> (<tt class="docutils literal"><span class="pre">gr2</span></tt> to <tt class="docutils literal"><span class="pre">gr63</span></tt>).
Register numbers not divisible by 4 are excluded not in the class but through
the use of a machine mode larger than 8 bytes.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ICC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">icc0</span></tt> to <tt class="docutils literal"><span class="pre">icc3</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FCC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fcc0</span></tt> to <tt class="docutils literal"><span class="pre">fcc3</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">v</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ICR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">cc4</span></tt> to <tt class="docutils literal"><span class="pre">cc7</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">FCR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">cc0</span></tt> to <tt class="docutils literal"><span class="pre">cc3</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">QUAD_FPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">fr0</span></tt> to <tt class="docutils literal"><span class="pre">fr63</span></tt>).
Register numbers not divisible by 4 are excluded not in the class but through
the use of a machine mode larger than 8 bytes.</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">SPR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">lcr</span></tt> and <tt class="docutils literal"><span class="pre">lr</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">QUAD_ACC_REGS</span></tt> (<tt class="docutils literal"><span class="pre">acc0</span></tt> to <tt class="docutils literal"><span class="pre">acc7</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">ACCG_REGS</span></tt> (<tt class="docutils literal"><span class="pre">accg0</span></tt> to <tt class="docutils literal"><span class="pre">accg7</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>Register in the class <tt class="docutils literal"><span class="pre">CR_REGS</span></tt> (<tt class="docutils literal"><span class="pre">cc0</span></tt> to <tt class="docutils literal"><span class="pre">cc7</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating point constant zero</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>6-bit signed integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>10-bit signed integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>16-bit signed integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>16-bit unsigned integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>12-bit signed integer constant that is negative-i.e. in the
range of -2048 to -1</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>Constant zero</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>12-bit signed integer constant that is greater than zero-i.e. in the
range of 1 to 2047.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Hewlett-Packard</span> <span class="pre">PA-RISC-</span><em><span class="pre">config/pa/pa.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>General register 1</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Floating point register</dd>
<dt><tt class="docutils literal"><span class="pre">q</span></tt></dt>
<dd>Shift amount register</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>Floating point register (deprecated)</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>Upper floating point register (32-bit), floating point register (64-bit)</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>Any register</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Signed 11-bit integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Signed 14-bit integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Integer constant that can be deposited with a <tt class="docutils literal"><span class="pre">zdepi</span></tt> instruction</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Signed 5-bit integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Integer constant 0</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Integer constant that can be loaded with a <tt class="docutils literal"><span class="pre">ldil</span></tt> instruction</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>Integer constant whose value plus one is a power of 2</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>Integer constant that can be used for <tt class="docutils literal"><span class="pre">and</span></tt> operations in <tt class="docutils literal"><span class="pre">depi</span></tt>
and <tt class="docutils literal"><span class="pre">extru</span></tt> instructions</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Integer constant 31</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>Integer constant 63</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating-point constant 0.0</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>A <tt class="docutils literal"><span class="pre">lo_sum</span></tt> data-linkage-table memory operand</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>A memory operand that can be used as the destination operand of an
integer store instruction</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>A scaled or unscaled indexed memory operand</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>A memory operand for floating-point loads and stores</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>A register indirect memory operand</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Intel</span> <span class="pre">IA-64-</span><em><span class="pre">config/ia64/ia64.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>General register <tt class="docutils literal"><span class="pre">r0</span></tt> to <tt class="docutils literal"><span class="pre">r3</span></tt> for <tt class="docutils literal"><span class="pre">addl</span></tt> instruction</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Branch register</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Predicate register (<tt class="samp docutils literal"><span class="pre">c</span></tt> as in &#8216;conditional&#8217;)</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Application register residing in M-unit</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>Application register residing in I-unit</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Floating-point register</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt></dt>
<dd>Memory operand.  If used together with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt>,
the operand can have postincrement and postdecrement which
require printing with <tt class="samp docutils literal"><span class="pre">%Pn</span></tt> on IA-64.</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating-point constant 0.0 or 1.0</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>14-bit signed integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>22-bit signed integer constant</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>8-bit signed integer constant for logical instructions</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>8-bit adjusted signed integer constant for compare pseudo-ops</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>6-bit unsigned integer constant for shift counts</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>9-bit signed integer constant for load and store postincrements</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>The constant zero</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>0 or -1 for <tt class="docutils literal"><span class="pre">dep</span></tt> instruction</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Non-volatile memory for floating-point loads and stores</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>Integer constant in the range 1 to 4 for <tt class="docutils literal"><span class="pre">shladd</span></tt> instruction</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Memory operand except postincrement and postdecrement.  This is
now roughly the same as <tt class="samp docutils literal"><span class="pre">m</span></tt> when not used together with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt>
or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt>.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">M32C-</span><em><span class="pre">config/m32c/m32c.c</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Rsp</span></tt> <tt class="docutils literal"><span class="pre">Rfb</span></tt> <tt class="docutils literal"><span class="pre">Rsb</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">$sp</span></tt>, <tt class="samp docutils literal"><span class="pre">$fb</span></tt>, <tt class="samp docutils literal"><span class="pre">$sb</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Rcr</span></tt></dt>
<dd>Any control register, when they&#8217;re 16 bits wide (nothing if control
registers are 24 bits wide)</dd>
<dt><tt class="docutils literal"><span class="pre">Rcl</span></tt></dt>
<dd>Any control register, when they&#8217;re 24 bits wide.</dd>
<dt><tt class="docutils literal"><span class="pre">R0w</span></tt> <tt class="docutils literal"><span class="pre">R1w</span></tt> <tt class="docutils literal"><span class="pre">R2w</span></tt> <tt class="docutils literal"><span class="pre">R3w</span></tt></dt>
<dd>$r0, $r1, $r2, $r3.</dd>
<dt><tt class="docutils literal"><span class="pre">R02</span></tt></dt>
<dd>$r0 or $r2, or $r2r0 for 32 bit values.</dd>
<dt><tt class="docutils literal"><span class="pre">R13</span></tt></dt>
<dd>$r1 or $r3, or $r3r1 for 32 bit values.</dd>
<dt><tt class="docutils literal"><span class="pre">Rdi</span></tt></dt>
<dd>A register that can hold a 64 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Rhl</span></tt></dt>
<dd>$r0 or $r1 (registers with addressable high/low bytes)</dd>
<dt><tt class="docutils literal"><span class="pre">R23</span></tt></dt>
<dd>$r2 or $r3</dd>
<dt><tt class="docutils literal"><span class="pre">Raa</span></tt></dt>
<dd>Address registers</dd>
<dt><tt class="docutils literal"><span class="pre">Raw</span></tt></dt>
<dd>Address registers when they&#8217;re 16 bits wide.</dd>
<dt><tt class="docutils literal"><span class="pre">Ral</span></tt></dt>
<dd>Address registers when they&#8217;re 24 bits wide.</dd>
<dt><tt class="docutils literal"><span class="pre">Rqi</span></tt></dt>
<dd>Registers that can hold QI values.</dd>
<dt><tt class="docutils literal"><span class="pre">Rad</span></tt></dt>
<dd>Registers that can be used with displacements ($a0, $a1, $sb).</dd>
<dt><tt class="docutils literal"><span class="pre">Rsi</span></tt></dt>
<dd>Registers that can hold 32 bit values.</dd>
<dt><tt class="docutils literal"><span class="pre">Rhi</span></tt></dt>
<dd>Registers that can hold 16 bit values.</dd>
<dt><tt class="docutils literal"><span class="pre">Rhc</span></tt></dt>
<dd>Registers chat can hold 16 bit values, including all control
registers.</dd>
<dt><tt class="docutils literal"><span class="pre">Rra</span></tt></dt>
<dd>$r0 through R1, plus $a0 and $a1.</dd>
<dt><tt class="docutils literal"><span class="pre">Rfl</span></tt></dt>
<dd>The flags register.</dd>
<dt><tt class="docutils literal"><span class="pre">Rmm</span></tt></dt>
<dd>The memory-based pseudo-registers $mem0 through $mem15.</dd>
<dt><tt class="docutils literal"><span class="pre">Rpi</span></tt></dt>
<dd>Registers that can hold pointers (16 bit registers for r8c, m16c; 24
bit registers for m32cm, m32c).</dd>
<dt><tt class="docutils literal"><span class="pre">Rpa</span></tt></dt>
<dd>Matches multiple registers in a PARALLEL to form a larger register.
Used to match function return values.</dd>
<dt><tt class="docutils literal"><span class="pre">Is3</span></tt></dt>
<dd>-8 ... 7</dd>
<dt><tt class="docutils literal"><span class="pre">IS1</span></tt></dt>
<dd>-128 ... 127</dd>
<dt><tt class="docutils literal"><span class="pre">IS2</span></tt></dt>
<dd>-32768 ... 32767</dd>
<dt><tt class="docutils literal"><span class="pre">IU2</span></tt></dt>
<dd>0 ... 65535</dd>
<dt><tt class="docutils literal"><span class="pre">In4</span></tt></dt>
<dd>-8 ... -1 or 1 ... 8</dd>
<dt><tt class="docutils literal"><span class="pre">In5</span></tt></dt>
<dd>-16 ... -1 or 1 ... 16</dd>
<dt><tt class="docutils literal"><span class="pre">In6</span></tt></dt>
<dd>-32 ... -1 or 1 ... 32</dd>
<dt><tt class="docutils literal"><span class="pre">IM2</span></tt></dt>
<dd>-65536 ... -1</dd>
<dt><tt class="docutils literal"><span class="pre">Ilb</span></tt></dt>
<dd>An 8 bit value with exactly one bit set.</dd>
<dt><tt class="docutils literal"><span class="pre">Ilw</span></tt></dt>
<dd>A 16 bit value with exactly one bit set.</dd>
<dt><tt class="docutils literal"><span class="pre">Sd</span></tt></dt>
<dd>The common src/dest memory addressing modes.</dd>
<dt><tt class="docutils literal"><span class="pre">Sa</span></tt></dt>
<dd>Memory addressed using $a0 or $a1.</dd>
<dt><tt class="docutils literal"><span class="pre">Si</span></tt></dt>
<dd>Memory addressed with immediate addresses.</dd>
<dt><tt class="docutils literal"><span class="pre">Ss</span></tt></dt>
<dd>Memory addressed using the stack pointer ($sp).</dd>
<dt><tt class="docutils literal"><span class="pre">Sf</span></tt></dt>
<dd>Memory addressed using the frame base register ($fb).</dd>
<dt><tt class="docutils literal"><span class="pre">Ss</span></tt></dt>
<dd>Memory addressed using the small base register ($sb).</dd>
<dt><tt class="docutils literal"><span class="pre">S1</span></tt></dt>
<dd>$r1h</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">MeP-</span><em><span class="pre">config/mep/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>The $sp register.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>The $tp register.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Any control register.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Either the $hi or the $lo register.</dd>
<dt><tt class="docutils literal"><span class="pre">em</span></tt></dt>
<dd>Coprocessor registers that can be directly loaded ($c0-$c15).</dd>
<dt><tt class="docutils literal"><span class="pre">ex</span></tt></dt>
<dd>Coprocessor registers that can be moved to each other.</dd>
<dt><tt class="docutils literal"><span class="pre">er</span></tt></dt>
<dd>Coprocessor registers that can be moved to core registers.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd>The $hi register.</dd>
<dt><tt class="docutils literal"><span class="pre">j</span></tt></dt>
<dd>The $rpc register.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>The $lo register.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Registers which can be used in $tp-relative addressing.</dd>
<dt><tt class="docutils literal"><span class="pre">v</span></tt></dt>
<dd>The $gp register.</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>The coprocessor registers.</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>The coprocessor control registers.</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>The $0 register.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>User-defined register set A.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt></dt>
<dd>User-defined register set B.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>User-defined register set C.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>User-defined register set D.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Offsets for $gp-rel addressing.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Constants that can be used directly with boolean insns.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Constants that can be moved directly to registers.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Small constants that can be added to registers.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Long shift counts.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Small constants that can be compared to registers.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>Constants that can be loaded into the top half of registers.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Signed 8-bit immediates.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>Symbols encoded for $tp-rel or $gp-rel addressing.</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>Non-constant addresses for loading/saving coprocessor registers.</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>The top half of a symbol&#8217;s value.</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>A register indirect address without offset.</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>Symbolic references to the control bus.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">MicroBlaze-</span><em><span class="pre">config/microblaze/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>A general register (<tt class="docutils literal"><span class="pre">r0</span></tt> to <tt class="docutils literal"><span class="pre">r31</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>A status register (<tt class="docutils literal"><span class="pre">rmsr</span></tt>, <tt class="docutils literal"><span class="pre">$fcc1</span></tt> to <tt class="docutils literal"><span class="pre">$fcc7</span></tt>).</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">MIPS-</span><em><span class="pre">config/mips/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>An address register.  This is equivalent to <tt class="docutils literal"><span class="pre">r</span></tt> unless
generating MIPS16 code.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>A floating-point register (if available).</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd>Formerly the <tt class="docutils literal"><span class="pre">hi</span></tt> register.  This constraint is no longer supported.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">lo</span></tt> register.  Use this register to store values that are
no bigger than a word.</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>The concatenated <tt class="docutils literal"><span class="pre">hi</span></tt> and <tt class="docutils literal"><span class="pre">lo</span></tt> registers.  Use this register
to store doubleword values.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>A register suitable for use in an indirect jump.  This will always be
<tt class="docutils literal"><span class="pre">$25</span></tt> for <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-mabicalls"><em class="xref std std-option">-mabicalls</em></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">v</span></tt></dt>
<dd>Register <tt class="docutils literal"><span class="pre">$3</span></tt>.  Do not use this constraint in new code;
it is retained only for compatibility with glibc.</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>Equivalent to <tt class="docutils literal"><span class="pre">r</span></tt>; retained for backwards compatibility.</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>A floating-point condition code register.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>A signed 16-bit constant (for arithmetic instructions).</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Integer zero.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>An unsigned 16-bit constant (for logic instructions).</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>A signed 32-bit constant in which the lower 16 bits are zero.
Such constants can be loaded using <tt class="docutils literal"><span class="pre">lui</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>A constant that cannot be loaded using <tt class="docutils literal"><span class="pre">lui</span></tt>, <tt class="docutils literal"><span class="pre">addiu</span></tt>
or <tt class="docutils literal"><span class="pre">ori</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>A constant in the range -65535 to -1 (inclusive).</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>A signed 15-bit constant.</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>A constant in the range 1 to 65535 (inclusive).</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating-point zero.</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>An address that can be used in a non-macro load or store.</dd>
<dt><tt class="docutils literal"><span class="pre">ZC</span></tt></dt>
<dd>A memory operand whose address is formed by a base register and offset
that is suitable for use in instructions with the same addressing mode
as <tt class="docutils literal"><span class="pre">ll</span></tt> and <tt class="docutils literal"><span class="pre">sc</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">ZD</span></tt></dt>
<dd>An address suitable for a <tt class="docutils literal"><span class="pre">prefetch</span></tt> instruction, or for any other
instruction with the same addressing mode as <tt class="docutils literal"><span class="pre">prefetch</span></tt>.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Motorola</span> <span class="pre">680x0-</span><em><span class="pre">config/m68k/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Address register</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Data register</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>68881 floating-point register, if available</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Integer in the range 1 to 8</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>16-bit signed number</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Signed number whose magnitude is greater than 0x80</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer in the range -8 to -1</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Signed number whose magnitude is greater than 0x100</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>16 (for rotate using swap)</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>Numbers that mov3q can handle</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating point constant that is not a 68881 constant</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Operands that satisfy &#8216;m&#8217; when -mpcrel is in effect</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>Operands that satisfy &#8216;s&#8217; when -mpcrel is not in effect</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Address register indirect addressing mode</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>Register offset addressing</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>const_call_operand</dd>
<dt><tt class="docutils literal"><span class="pre">Cs</span></tt></dt>
<dd>symbol_ref or const</dd>
<dt><tt class="docutils literal"><span class="pre">Ci</span></tt></dt>
<dd>const_int</dd>
<dt><tt class="docutils literal"><span class="pre">C0</span></tt></dt>
<dd>const_int 0</dd>
<dt><tt class="docutils literal"><span class="pre">Cj</span></tt></dt>
<dd>Range of signed numbers that don&#8217;t fit in 16 bits</dd>
<dt><tt class="docutils literal"><span class="pre">Cmvq</span></tt></dt>
<dd>Integers valid for mvq</dd>
<dt><tt class="docutils literal"><span class="pre">Capsw</span></tt></dt>
<dd>Integers valid for a moveq followed by a swap</dd>
<dt><tt class="docutils literal"><span class="pre">Cmvz</span></tt></dt>
<dd>Integers valid for mvz</dd>
<dt><tt class="docutils literal"><span class="pre">Cmvs</span></tt></dt>
<dd>Integers valid for mvs</dd>
<dt><tt class="docutils literal"><span class="pre">Ap</span></tt></dt>
<dd>push_operand</dd>
<dt><tt class="docutils literal"><span class="pre">Ac</span></tt></dt>
<dd>Non-register operands allowed in clr</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Moxie-</span><em><span class="pre">config/moxie/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>An absolute address</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt></dt>
<dd>An offset address</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>A register indirect memory operand</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>A constant in the range of 0 to 255.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>A constant in the range of 0 to -255.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">MSP430-</span><em><span class="pre">config/msp430/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">R12</span></tt></dt>
<dd>Register R12.</dd>
<dt><tt class="docutils literal"><span class="pre">R13</span></tt></dt>
<dd>Register R13.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Integer constant 1.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer constant -1^20..1^19.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Integer constant 1-4.</dd>
<dt><tt class="docutils literal"><span class="pre">Ya</span></tt></dt>
<dd>Memory references which do not require an extended MOVX instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Yl</span></tt></dt>
<dd>Memory reference, labels only.</dd>
<dt><tt class="docutils literal"><span class="pre">Ys</span></tt></dt>
<dd>Memory reference, stack only.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">NDS32-</span><em><span class="pre">config/nds32/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>LOW register class $r0 to $r7 constraint for V3/V3M ISA.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>LOW register class $r0 to $r7.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>MIDDLE register class $r0 to $r11, $r16 to $r19.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd>HIGH register class $r12 to $r14, $r20 to $r31.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Temporary assist register $ta (i.e. $r15).</dd>
<dt><tt class="docutils literal"><span class="pre">k</span></tt></dt>
<dd>Stack register $sp.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu03</span></tt></dt>
<dd>Unsigned immediate 3-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">In03</span></tt></dt>
<dd>Negative immediate 3-bit value in the range of -7-0.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu04</span></tt></dt>
<dd>Unsigned immediate 4-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Is05</span></tt></dt>
<dd>Signed immediate 5-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu05</span></tt></dt>
<dd>Unsigned immediate 5-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">In05</span></tt></dt>
<dd>Negative immediate 5-bit value in the range of -31-0.</dd>
<dt><tt class="docutils literal"><span class="pre">Ip05</span></tt></dt>
<dd>Unsigned immediate 5-bit value for movpi45 instruction with range 16-47.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu06</span></tt></dt>
<dd>Unsigned immediate 6-bit value constraint for addri36.sp instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu08</span></tt></dt>
<dd>Unsigned immediate 8-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu09</span></tt></dt>
<dd>Unsigned immediate 9-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Is10</span></tt></dt>
<dd>Signed immediate 10-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Is11</span></tt></dt>
<dd>Signed immediate 11-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Is15</span></tt></dt>
<dd>Signed immediate 15-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu15</span></tt></dt>
<dd>Unsigned immediate 15-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Ic15</span></tt></dt>
<dd>A constant which is not in the range of imm15u but ok for bclr instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Ie15</span></tt></dt>
<dd>A constant which is not in the range of imm15u but ok for bset instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">It15</span></tt></dt>
<dd>A constant which is not in the range of imm15u but ok for btgl instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Ii15</span></tt></dt>
<dd>A constant whose compliment value is in the range of imm15u
and ok for bitci instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Is16</span></tt></dt>
<dd>Signed immediate 16-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Is17</span></tt></dt>
<dd>Signed immediate 17-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Is19</span></tt></dt>
<dd>Signed immediate 19-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Is20</span></tt></dt>
<dd>Signed immediate 20-bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Ihig</span></tt></dt>
<dd>The immediate value that can be simply set high 20-bit.</dd>
<dt><tt class="docutils literal"><span class="pre">Izeb</span></tt></dt>
<dd>The immediate value 0xff.</dd>
<dt><tt class="docutils literal"><span class="pre">Izeh</span></tt></dt>
<dd>The immediate value 0xffff.</dd>
<dt><tt class="docutils literal"><span class="pre">Ixls</span></tt></dt>
<dd>The immediate value 0x01.</dd>
<dt><tt class="docutils literal"><span class="pre">Ix11</span></tt></dt>
<dd>The immediate value 0x7ff.</dd>
<dt><tt class="docutils literal"><span class="pre">Ibms</span></tt></dt>
<dd>The immediate value with power of 2.</dd>
<dt><tt class="docutils literal"><span class="pre">Ifex</span></tt></dt>
<dd>The immediate value with power of 2 minus 1.</dd>
<dt><tt class="docutils literal"><span class="pre">U33</span></tt></dt>
<dd>Memory constraint for 333 format.</dd>
<dt><tt class="docutils literal"><span class="pre">U45</span></tt></dt>
<dd>Memory constraint for 45 format.</dd>
<dt><tt class="docutils literal"><span class="pre">U37</span></tt></dt>
<dd>Memory constraint for 37 format.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Nios</span> <span class="pre">II</span> <span class="pre">family-</span><em><span class="pre">config/nios2/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Integer that is valid as an immediate operand in an
instruction taking a signed 16-bit number. Range
-32768 to 32767.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Integer that is valid as an immediate operand in an
instruction taking an unsigned 16-bit number. Range
0 to 65535.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Integer that is valid as an immediate operand in an
instruction taking only the upper 16-bits of a
32-bit number. Range 32-bit numbers with the lower
16-bits being 0.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer that is valid as an immediate operand for a
shift instruction. Range 0 to 31.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Integer that is valid as an immediate operand for
only the value 0. Can be used in conjunction with
the format modifier <tt class="docutils literal"><span class="pre">z</span></tt> to use <tt class="docutils literal"><span class="pre">r0</span></tt>
instead of <tt class="docutils literal"><span class="pre">0</span></tt> in the assembly output.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Integer that is valid as an immediate operand for
a custom instruction opcode. Range 0 to 255.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Matches immediates which are addresses in the small
data section and therefore can be added to <tt class="docutils literal"><span class="pre">gp</span></tt>
as a 16-bit immediate to re-create their 32-bit value.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">PDP-11-</span><em><span class="pre">config/pdp11/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Floating point registers AC0 through AC3.  These can be loaded from/to
memory with a single instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Odd numbered general registers (R1, R3, R5).  These are used for
16-bit multiply operations.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Any of the floating point registers (AC0 through AC5).</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating point constant 0.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>An integer constant that fits in 16 bits.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>An integer constant whose low order 16 bits are zero.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>An integer constant that does not meet the constraints for codes
<tt class="samp docutils literal"><span class="pre">I</span></tt> or <tt class="samp docutils literal"><span class="pre">J</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>The integer constant 1.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>The integer constant -1.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>The integer constant 0.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>Integer constants -4 through -1 and 1 through 4; shifts by these
amounts are handled as multiple single-bit shifts rather than a single
variable-length shift.</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>A memory reference which requires an additional word (address or
offset) after the opcode.</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>A memory reference that is encoded within the opcode.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">PowerPC</span> <span class="pre">and</span> <span class="pre">IBM</span> <span class="pre">RS6000-</span><em><span class="pre">config/rs6000/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Address base register</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Floating point register (containing 64-bit value)</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Floating point register (containing 32-bit value)</dd>
<dt><tt class="docutils literal"><span class="pre">v</span></tt></dt>
<dd>Altivec vector register</dd>
<dt><tt class="docutils literal"><span class="pre">wa</span></tt></dt>
<dd>Any VSX register if the -mvsx option was used or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wd</span></tt></dt>
<dd>VSX vector register to hold vector double data or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wf</span></tt></dt>
<dd>VSX vector register to hold vector float data or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wg</span></tt></dt>
<dd>If <em class="xref std std-option">-mmfpgpr</em> was used, a floating point register or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wh</span></tt></dt>
<dd>Floating point register if direct moves are available, or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wi</span></tt></dt>
<dd>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wj</span></tt></dt>
<dd>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wk</span></tt></dt>
<dd>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wl</span></tt></dt>
<dd>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wm</span></tt></dt>
<dd>VSX register if direct move instructions are enabled, or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wn</span></tt></dt>
<dd>No register (NO_REGS).</dd>
<dt><tt class="docutils literal"><span class="pre">wr</span></tt></dt>
<dd>General purpose register if 64-bit instructions are enabled or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">ws</span></tt></dt>
<dd>VSX vector register to hold scalar double values or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wt</span></tt></dt>
<dd>VSX vector register to hold 128 bit integer or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wu</span></tt></dt>
<dd>Altivec register to use for float/32-bit int loads/stores  or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wv</span></tt></dt>
<dd>Altivec register to use for double loads/stores  or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">ww</span></tt></dt>
<dd>FP or VSX register to perform float operations under <a class="reference internal" href="hardware-models-and-configurations.html#cmdoption-mvsx"><em class="xref std std-option">-mvsx</em></a> or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wx</span></tt></dt>
<dd>Floating point register if the STFIWX instruction is enabled or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wy</span></tt></dt>
<dd>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wz</span></tt></dt>
<dd>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</dd>
<dt><tt class="docutils literal"><span class="pre">wD</span></tt></dt>
<dd>Int constant that is the element number of the 64-bit scalar in a vector.</dd>
<dt><tt class="docutils literal"><span class="pre">wQ</span></tt></dt>
<dd>A memory address that will work with the <tt class="docutils literal"><span class="pre">lq</span></tt> and <tt class="docutils literal"><span class="pre">stq</span></tt>
instructions.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">MQ</span></tt>, <tt class="samp docutils literal"><span class="pre">CTR</span></tt>, or <tt class="samp docutils literal"><span class="pre">LINK</span></tt> register</dd>
<dt><tt class="docutils literal"><span class="pre">q</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">MQ</span></tt> register</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">CTR</span></tt> register</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">LINK</span></tt> register</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">CR</span></tt> register (condition register) number 0</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">CR</span></tt> register (condition register)</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd><tt class="samp docutils literal"><span class="pre">XER[CA]</span></tt> carry bit (part of the XER register)</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Signed 16-bit constant</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Unsigned 16-bit constant shifted left 16 bits (use <tt class="samp docutils literal"><span class="pre">L</span></tt> instead for
<tt class="docutils literal"><span class="pre">SImode</span></tt> constants)</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Unsigned 16-bit constant</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Signed 16-bit constant shifted left 16 bits</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Constant larger than 31</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Exact power of 2</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>Zero</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>Constant whose negation is a signed 16-bit constant</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating point constant that can be loaded into a register with one
instruction per word</dd>
<dt><tt class="docutils literal"><span class="pre">H</span></tt></dt>
<dd>Integer/Floating point constant that can be loaded into a register using
three instructions</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt></dt>
<dd><p class="first">Memory operand.
Normally, <tt class="docutils literal"><span class="pre">m</span></tt> does not allow addresses that update the base register.
If <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt> constraint is also used, they are allowed and
therefore on PowerPC targets in that case it is only safe
to use <tt class="samp docutils literal"><span class="pre">m&lt;&gt;</span></tt> in an <tt class="docutils literal"><span class="pre">asm</span></tt> statement if that <tt class="docutils literal"><span class="pre">asm</span></tt> statement
accesses the operand exactly once.  The <tt class="docutils literal"><span class="pre">asm</span></tt> statement must also
use <tt class="samp docutils literal"><span class="pre">%U``&lt;opno&gt;``</span></tt> as a placeholder for the &#8216;update&#8217; flag in the
corresponding load or store instruction.  For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;st%U0 %1,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
<p>is correct but:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;st %1,%0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
<p class="last">is not.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">es</span></tt></dt>
<dd>A &#8216;stable&#8217; memory operand; that is, one which does not include any
automodification of the base register.  This used to be useful when
<tt class="samp docutils literal"><span class="pre">m</span></tt> allowed automodification of the base register, but as those are now only
allowed when <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt> is used, <tt class="samp docutils literal"><span class="pre">es</span></tt> is basically the same
as <tt class="samp docutils literal"><span class="pre">m</span></tt> without <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> and <tt class="samp docutils literal"><span class="pre">&gt;</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Memory operand that is an offset from a register (it is usually better
to use <tt class="samp docutils literal"><span class="pre">m</span></tt> or <tt class="samp docutils literal"><span class="pre">es</span></tt> in <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>Memory operand that is an indexed or indirect from a register (it is
usually better to use <tt class="samp docutils literal"><span class="pre">m</span></tt> or <tt class="samp docutils literal"><span class="pre">es</span></tt> in <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>AIX TOC entry</dd>
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Address operand that is an indexed or indirect from a register (<tt class="samp docutils literal"><span class="pre">p</span></tt> is
preferable for <tt class="docutils literal"><span class="pre">asm</span></tt> statements)</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Constant suitable as a 64-bit mask operand</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>Constant suitable as a 32-bit mask operand</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>System V Release 4 small data area reference</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>AND masks that can be performed by two rldic{l, r} instructions</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>Vector constant that does not require memory</dd>
<dt><tt class="docutils literal"><span class="pre">j</span></tt></dt>
<dd>Vector constant that is all zeros.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">RL78-</span><em><span class="pre">config/rl78/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Int3</span></tt></dt>
<dd>An integer constant in the range 1 ... 7.</dd>
<dt><tt class="docutils literal"><span class="pre">Int8</span></tt></dt>
<dd>An integer constant in the range 0 ... 255.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>An integer constant in the range -255 ... 0</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>The integer constant 1.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>The integer constant -1.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>The integer constant 0.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>The integer constant 2.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>The integer constant -2.</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>An integer constant in the range 1 ... 15.</dd>
<dt><tt class="docutils literal"><span class="pre">Qbi</span></tt></dt>
<dd>The built-in compare types-eq, ne, gtu, ltu, geu, and leu.</dd>
<dt><tt class="docutils literal"><span class="pre">Qsc</span></tt></dt>
<dd>The synthetic compare types-gt, lt, ge, and le.</dd>
<dt><tt class="docutils literal"><span class="pre">Wab</span></tt></dt>
<dd>A memory reference with an absolute address.</dd>
<dt><tt class="docutils literal"><span class="pre">Wbc</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">BC</span></tt> as a base register, with an optional offset.</dd>
<dt><tt class="docutils literal"><span class="pre">Wca</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">AX</span></tt>, <tt class="docutils literal"><span class="pre">BC</span></tt>, <tt class="docutils literal"><span class="pre">DE</span></tt>, or <tt class="docutils literal"><span class="pre">HL</span></tt> for the address, for calls.</dd>
<dt><tt class="docutils literal"><span class="pre">Wcv</span></tt></dt>
<dd>A memory reference using any 16-bit register pair for the address, for calls.</dd>
<dt><tt class="docutils literal"><span class="pre">Wd2</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">DE</span></tt> as a base register, with an optional offset.</dd>
<dt><tt class="docutils literal"><span class="pre">Wde</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">DE</span></tt> as a base register, without any offset.</dd>
<dt><tt class="docutils literal"><span class="pre">Wfr</span></tt></dt>
<dd>Any memory reference to an address in the far address space.</dd>
<dt><tt class="docutils literal"><span class="pre">Wh1</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">HL</span></tt> as a base register, with an optional one-byte offset.</dd>
<dt><tt class="docutils literal"><span class="pre">Whb</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">HL</span></tt> as a base register, with <tt class="docutils literal"><span class="pre">B</span></tt> or <tt class="docutils literal"><span class="pre">C</span></tt> as the index register.</dd>
<dt><tt class="docutils literal"><span class="pre">Whl</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">HL</span></tt> as a base register, without any offset.</dd>
<dt><tt class="docutils literal"><span class="pre">Ws1</span></tt></dt>
<dd>A memory reference using <tt class="docutils literal"><span class="pre">SP</span></tt> as a base register, with an optional one-byte offset.</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>Any memory reference to an address in the near address space.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">AX</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">BC</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">DE</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">A</span></tt> through <tt class="docutils literal"><span class="pre">L</span></tt> registers.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">SP</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">HL</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">Z08W</span></tt></dt>
<dd>The 16-bit <tt class="docutils literal"><span class="pre">R8</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">Z10W</span></tt></dt>
<dd>The 16-bit <tt class="docutils literal"><span class="pre">R10</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">Zint</span></tt></dt>
<dd>The registers reserved for interrupts (<tt class="docutils literal"><span class="pre">R24</span></tt> to <tt class="docutils literal"><span class="pre">R31</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">A</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">B</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">C</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">D</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">E</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">H</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">L</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">v</span></tt></dt>
<dd>The virtual registers.</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">PSW</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">X</span></tt> register.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">RX-</span><em><span class="pre">config/rx/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>An address which does not involve register indirect addressing or
pre/post increment/decrement addressing.</dd>
<dt><tt class="docutils literal"><span class="pre">Symbol</span></tt></dt>
<dd>A symbol reference.</dd>
<dt><tt class="docutils literal"><span class="pre">Int08</span></tt></dt>
<dd>A constant in the range -256 to 255, inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">Sint08</span></tt></dt>
<dd>A constant in the range -128 to 127, inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">Sint16</span></tt></dt>
<dd>A constant in the range -32768 to 32767, inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">Sint24</span></tt></dt>
<dd>A constant in the range -8388608 to 8388607, inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">Uint04</span></tt></dt>
<dd>A constant in the range 0 to 15, inclusive.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">S/390</span> <span class="pre">and</span> <span class="pre">zSeries-</span><em><span class="pre">config/s390/s390.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Address register (general purpose register except r0)</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Condition code register</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Data register (arbitrary general purpose register)</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Floating-point register</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Unsigned 8-bit constant (0-255)</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Unsigned 12-bit constant (0-4095)</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Signed 16-bit constant (-32768-32767)</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd><p class="first">Value appropriate as displacement.</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">(0..4095)</span></tt></dt>
<dd>for short displacement</dd>
<dt><tt class="docutils literal"><span class="pre">(-524288..524287)</span></tt></dt>
<dd>for long displacement</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Constant integer with a value of 0x7fffffff.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd><p class="first">Multiple letter constraint followed by 4 parameter letters.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">0..9:</span></tt></dt>
<dd>number of the part counting from most to least significant</dd>
<dt><tt class="docutils literal"><span class="pre">H,Q:</span></tt></dt>
<dd>mode of the part</dd>
<dt><tt class="docutils literal"><span class="pre">D,S,H:</span></tt></dt>
<dd>mode of the containing operand</dd>
<dt><tt class="docutils literal"><span class="pre">0,F:</span></tt></dt>
<dd><p class="first">value of the other parts (F-all bits set)</p>
<p class="last">The constraint matches if the specified part of a constant</p>
</dd>
</dl>
<p class="last">has a value different from its other parts.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Memory reference without index register and with short displacement.</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>Memory reference with index register and short displacement.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Memory reference without index register but with long displacement.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>Memory reference with index register and long displacement.</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>Pointer with short displacement.</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>Pointer with long displacement.</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>Shift count operand.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">SPARC-</span><em><span class="pre">config/sparc/sparc.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Floating-point register on the SPARC-V8 architecture and
lower floating-point register on the SPARC-V9 architecture.</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>Floating-point register.  It is equivalent to <tt class="samp docutils literal"><span class="pre">f</span></tt> on the
SPARC-V8 architecture and contains both lower and upper
floating-point registers on the SPARC-V9 architecture.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Floating-point condition code register.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Lower floating-point register.  It is only valid on the SPARC-V9
architecture when the Visual Instruction Set is available.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Floating-point register.  It is only valid on the SPARC-V9 architecture
when the Visual Instruction Set is available.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt></dt>
<dd>64-bit global or out register for the SPARC-V8+ architecture.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>The constant all-ones, for floating-point.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>Signed 5-bit constant</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>A vector constant</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Signed 13-bit constant</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Zero</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>32-bit constant with the low 12 bits clear (a constant that can be
loaded with the <tt class="docutils literal"><span class="pre">sethi</span></tt> instruction)</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>A constant in the range supported by <tt class="docutils literal"><span class="pre">movcc</span></tt> instructions (11-bit
signed immediate)</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>A constant in the range supported by <tt class="docutils literal"><span class="pre">movrcc</span></tt> instructions (10-bit
signed immediate)</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Same as <tt class="samp docutils literal"><span class="pre">K</span></tt>, except that it verifies that bits that are not in the
lower 32-bit range are all zero.  Must be used instead of <tt class="samp docutils literal"><span class="pre">K</span></tt> for
modes wider than <tt class="docutils literal"><span class="pre">SImode</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>The constant 4096</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating-point zero</dd>
<dt><tt class="docutils literal"><span class="pre">H</span></tt></dt>
<dd>Signed 13-bit constant, sign-extended to 32 or 64 bits</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>The constant -1</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Floating-point constant whose integral representation can
be moved into an integer register using a single sethi
instruction</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>Floating-point constant whose integral representation can
be moved into an integer register using a single mov
instruction</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Floating-point constant whose integral representation can
be moved into an integer register using a high/lo_sum
instruction sequence</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>Memory address aligned to an 8-byte boundary</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>Even register</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>Memory address for <tt class="samp docutils literal"><span class="pre">e</span></tt> constraint registers</dd>
<dt><tt class="docutils literal"><span class="pre">w</span></tt></dt>
<dd>Memory address with only a base register</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>Vector zero</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">SPU-</span><em><span class="pre">config/spu/spu.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>An immediate for and/xor/or instructions.  const_int is treated as a 64 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>An immediate for the <tt class="docutils literal"><span class="pre">iohl</span></tt> instruction.  const_int is treated as a 64 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>An immediate which can be loaded with <tt class="docutils literal"><span class="pre">fsmbi</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt></dt>
<dd>An immediate for most arithmetic instructions.  const_int is treated as a 32 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>An immediate for and/xor/or instructions.  const_int is treated as a 32 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>An immediate for the <tt class="docutils literal"><span class="pre">iohl</span></tt> instruction.  const_int is treated as a 32 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>A constant in the range [-64, 63] for shift/rotate instructions.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>An unsigned 7-bit constant for conversion/nop/channel instructions.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>A signed 10-bit constant for most arithmetic instructions.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>A signed 16 bit immediate for <tt class="docutils literal"><span class="pre">stop</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>An unsigned 16-bit constant for <tt class="docutils literal"><span class="pre">iohl</span></tt> and <tt class="docutils literal"><span class="pre">fsmbi</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>An unsigned 7-bit constant whose 3 least significant bits are 0.</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>An unsigned 3-bit constant for 16-byte rotates and shifts</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>Call operand, reg, for indirect calls</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Call operand, symbol, for relative calls.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>Call operand, const_int, for absolute calls.</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is sign extended to 128 bit.</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>An immediate for shift and rotate instructions.  const_int is treated as a 32 bit value.</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>An immediate for and/xor/or instructions.  const_int is sign extended as a 128 bit.</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>An immediate for the <tt class="docutils literal"><span class="pre">iohl</span></tt> instruction.  const_int is sign extended to 128 bit.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">TI</span> <span class="pre">C6X</span> <span class="pre">family-</span><em><span class="pre">config/c6x/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Register file A (A0-A31).</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Register file B (B0-B31).</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>Predicate registers in register file A (A0-A2 on C64X and
higher, A1 and A2 otherwise).</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt></dt>
<dd>Predicate registers in register file B (B0-B2).</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>A call-used register in register file B (B0-B9, B16-B31).</dd>
<dt><tt class="docutils literal"><span class="pre">Da</span></tt></dt>
<dd>Register file A, excluding predicate registers (A3-A31,
plus A0 if not C64X or higher).</dd>
<dt><tt class="docutils literal"><span class="pre">Db</span></tt></dt>
<dd>Register file B, excluding predicate registers (B3-B31).</dd>
<dt><tt class="docutils literal"><span class="pre">Iu4</span></tt></dt>
<dd>Integer constant in the range 0 ... 15.</dd>
<dt><tt class="docutils literal"><span class="pre">Iu5</span></tt></dt>
<dd>Integer constant in the range 0 ... 31.</dd>
<dt><tt class="docutils literal"><span class="pre">In5</span></tt></dt>
<dd>Integer constant in the range -31 ... 0.</dd>
<dt><tt class="docutils literal"><span class="pre">Is5</span></tt></dt>
<dd>Integer constant in the range -16 ... 15.</dd>
<dt><tt class="docutils literal"><span class="pre">I5x</span></tt></dt>
<dd>Integer constant that can be the operand of an ADDA or a SUBA insn.</dd>
<dt><tt class="docutils literal"><span class="pre">IuB</span></tt></dt>
<dd>Integer constant in the range 0 ... 65535.</dd>
<dt><tt class="docutils literal"><span class="pre">IsB</span></tt></dt>
<dd>Integer constant in the range -32768 ... 32767.</dd>
<dt><tt class="docutils literal"><span class="pre">IsC</span></tt></dt>
<dd>Integer constant in the range -2^{20} ... 2^{20} - 1.</dd>
<dt><tt class="docutils literal"><span class="pre">Jc</span></tt></dt>
<dd>Integer constant that is a valid mask for the clr instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Js</span></tt></dt>
<dd>Integer constant that is a valid mask for the set instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Memory location with A base register.</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>Memory location with B base register.</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>Register B14 (aka DP).</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">TILE-Gx-</span><em><span class="pre">config/tilegx/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">R00</span></tt> <tt class="docutils literal"><span class="pre">R01</span></tt> <tt class="docutils literal"><span class="pre">R02</span></tt> <tt class="docutils literal"><span class="pre">R03</span></tt> <tt class="docutils literal"><span class="pre">R04</span></tt> <tt class="docutils literal"><span class="pre">R05</span></tt> <tt class="docutils literal"><span class="pre">R06</span></tt> <tt class="docutils literal"><span class="pre">R07</span></tt> <tt class="docutils literal"><span class="pre">R08</span></tt> <tt class="docutils literal"><span class="pre">R09</span></tt> <tt class="docutils literal"><span class="pre">R10</span></tt></dt>
<dd>Each of these represents a register constraint for an individual
register, from r0 to r10.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Signed 8-bit integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Signed 16-bit integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Unsigned 16-bit integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer constant that fits in one signed byte when incremented by one
(-129 ... 126).</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt></dt>
<dd><p class="first">Memory operand.  If used together with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt>, the
operand can have postincrement which requires printing with <tt class="samp docutils literal"><span class="pre">%In</span></tt>
and <tt class="samp docutils literal"><span class="pre">%in</span></tt> on TILE-Gx.  For example:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;st_add %I0,%1,%i0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>A bit mask suitable for the BFINS instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Integer constant that is a byte tiled out eight times.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>The integer zero constant.</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>Integer constant that is a sign-extended byte tiled out as four shorts.</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Integer constant that fits in one signed byte when incremented
(-129 ... 126), but excluding -1.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>Integer constant that has all 1 bits consecutive and starting at bit 0.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>A 16-bit fragment of a got, tls, or pc-relative reference.</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>Memory operand except postincrement.  This is roughly the same as
<tt class="samp docutils literal"><span class="pre">m</span></tt> when not used together with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>An 8-element vector constant with identical elements.</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>A 4-element vector constant with identical elements.</dd>
<dt><tt class="docutils literal"><span class="pre">Z0</span></tt></dt>
<dd>The integer constant 0xffffffff.</dd>
<dt><tt class="docutils literal"><span class="pre">Z1</span></tt></dt>
<dd>The integer constant 0xffffffff00000000.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">TILEPro-</span><em><span class="pre">config/tilepro/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">R00</span></tt> <tt class="docutils literal"><span class="pre">R01</span></tt> <tt class="docutils literal"><span class="pre">R02</span></tt> <tt class="docutils literal"><span class="pre">R03</span></tt> <tt class="docutils literal"><span class="pre">R04</span></tt> <tt class="docutils literal"><span class="pre">R05</span></tt> <tt class="docutils literal"><span class="pre">R06</span></tt> <tt class="docutils literal"><span class="pre">R07</span></tt> <tt class="docutils literal"><span class="pre">R08</span></tt> <tt class="docutils literal"><span class="pre">R09</span></tt> <tt class="docutils literal"><span class="pre">R10</span></tt></dt>
<dd>Each of these represents a register constraint for an individual
register, from r0 to r10.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Signed 8-bit integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Signed 16-bit integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Nonzero integer constant with low 16 bits zero.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer constant that fits in one signed byte when incremented by one
(-129 ... 126).</dd>
<dt><tt class="docutils literal"><span class="pre">m</span></tt></dt>
<dd><p class="first">Memory operand.  If used together with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt>, the
operand can have postincrement which requires printing with <tt class="samp docutils literal"><span class="pre">%In</span></tt>
and <tt class="samp docutils literal"><span class="pre">%in</span></tt> on TILEPro.  For example:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="k">asm</span> <span class="p">(</span><span class="s">&quot;swadd %I0,%1,%i0&quot;</span> <span class="o">:</span> <span class="s">&quot;=m&lt;&gt;&quot;</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">val</span><span class="p">));</span>
</pre></div>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>A bit mask suitable for the MM instruction.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Integer constant that is a byte tiled out four times.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>The integer zero constant.</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>Integer constant that is a sign-extended byte tiled out as two shorts.</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Integer constant that fits in one signed byte when incremented
(-129 ... 126), but excluding -1.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative
reference.</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>Memory operand except postincrement.  This is roughly the same as
<tt class="samp docutils literal"><span class="pre">m</span></tt> when not used together with <tt class="samp docutils literal"><span class="pre">&lt;</span></tt> or <tt class="samp docutils literal"><span class="pre">&gt;</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">W</span></tt></dt>
<dd>A 4-element vector constant with identical elements.</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt></dt>
<dd>A 2-element vector constant with identical elements.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Visium-</span><em><span class="pre">config/visium/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>EAM register <tt class="docutils literal"><span class="pre">mdb</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>EAM register <tt class="docutils literal"><span class="pre">mdc</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Floating point register</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt></dt>
<dd>General register, but not <tt class="docutils literal"><span class="pre">r29</span></tt>, <tt class="docutils literal"><span class="pre">r30</span></tt> and <tt class="docutils literal"><span class="pre">r31</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Register <tt class="docutils literal"><span class="pre">r1</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt></dt>
<dd>Register <tt class="docutils literal"><span class="pre">r2</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">v</span></tt></dt>
<dd>Register <tt class="docutils literal"><span class="pre">r3</span></tt></dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Floating-point constant 0.0</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Integer constant in the range 0 .. 65535 (16-bit immediate)</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Integer constant in the range 1 .. 31 (5-bit immediate)</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Integer constant in the range -65535 .. -1 (16-bit negative immediate)</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>Integer constant -1</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>Integer constant 0</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>Integer constant 32</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">x86</span> <span class="pre">family-</span><em><span class="pre">config/i386/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>Legacy register-the eight integer registers available on all
i386 processors (<tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">d</span></tt>,
<tt class="docutils literal"><span class="pre">si</span></tt>, <tt class="docutils literal"><span class="pre">di</span></tt>, <tt class="docutils literal"><span class="pre">bp</span></tt>, <tt class="docutils literal"><span class="pre">sp</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">q</span></tt></dt>
<dd>Any register accessible as <tt class="docutils literal"><span class="pre">``r``l</span></tt>.  In 32-bit mode, <tt class="docutils literal"><span class="pre">a</span></tt>,
<tt class="docutils literal"><span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">c</span></tt>, and <tt class="docutils literal"><span class="pre">d</span></tt>; in 64-bit mode, any integer register.</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>Any register accessible as <tt class="docutils literal"><span class="pre">``r``h</span></tt>: <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">c</span></tt>, and <tt class="docutils literal"><span class="pre">d</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">a</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">b</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">c</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">d</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">si</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt></dt>
<dd>The <tt class="docutils literal"><span class="pre">di</span></tt> register.</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd><p class="first">The <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">d</span></tt> registers.  This class is used for instructions
that return double word results in the <tt class="docutils literal"><span class="pre">ax:dx</span></tt> register pair.  Single
word values will be allocated either in <tt class="docutils literal"><span class="pre">ax</span></tt> or <tt class="docutils literal"><span class="pre">dx</span></tt>.
For example on i386 the following implements <tt class="docutils literal"><span class="pre">rdtsc</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">rdtsc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">tick</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rdtsc&quot;</span><span class="o">:</span><span class="s">&quot;=A&quot;</span><span class="p">(</span><span class="n">tick</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">tick</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is not correct on x86-64 as it would allocate tick in either <tt class="docutils literal"><span class="pre">ax</span></tt>
or <tt class="docutils literal"><span class="pre">dx</span></tt>.  You have to use the following variant instead:</p>
<div class="last highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">rdtsc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tickl</span><span class="p">,</span> <span class="n">tickh</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;rdtsc&quot;</span><span class="o">:</span><span class="s">&quot;=a&quot;</span><span class="p">(</span><span class="n">tickl</span><span class="p">),</span><span class="s">&quot;=d&quot;</span><span class="p">(</span><span class="n">tickh</span><span class="p">));</span>
  <span class="k">return</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">tickh</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span><span class="o">|</span><span class="n">tickl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt></dt>
<dd>Any 80387 floating-point (stack) register.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Top of 80387 floating-point stack (<tt class="docutils literal"><span class="pre">%st(0)</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt></dt>
<dd>Second from top of 80387 floating-point stack (<tt class="docutils literal"><span class="pre">%st(1)</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>Any MMX register.</dd>
<dt><tt class="docutils literal"><span class="pre">x</span></tt></dt>
<dd>Any SSE register.</dd>
<dt><tt class="docutils literal"><span class="pre">Yz</span></tt></dt>
<dd>First SSE register (<tt class="docutils literal"><span class="pre">%xmm0</span></tt>).</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Integer constant in the range 0 ... 31, for 32-bit shifts.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Integer constant in the range 0 ... 63, for 64-bit shifts.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Signed 8-bit integer constant.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd><tt class="docutils literal"><span class="pre">0xFF</span></tt> or <tt class="docutils literal"><span class="pre">0xFFFF</span></tt>, for andsi as a zero-extending move.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>0, 1, 2, or 3 (shifts for the <tt class="docutils literal"><span class="pre">lea</span></tt> instruction).</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>Unsigned 8-bit integer constant (for <tt class="docutils literal"><span class="pre">in</span></tt> and <tt class="docutils literal"><span class="pre">out</span></tt>
instructions).</dd>
<dt><tt class="docutils literal"><span class="pre">G</span></tt></dt>
<dd>Standard 80387 floating point constant.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt></dt>
<dd>Standard SSE floating point constant.</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>32-bit signed integer constant, or a symbolic reference known
to fit that range (for immediate operands in sign-extending x86-64
instructions).</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>32-bit unsigned integer constant, or a symbolic reference known
to fit that range (for immediate operands in zero-extending x86-64
instructions).</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Xstormy16-</span><em><span class="pre">config/stormy16/stormy16.h</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>Register r0.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>Register r1.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt></dt>
<dd>Register r2.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt></dt>
<dd>Register r8.</dd>
<dt><tt class="docutils literal"><span class="pre">e</span></tt></dt>
<dd>Registers r0 through r7.</dd>
<dt><tt class="docutils literal"><span class="pre">t</span></tt></dt>
<dd>Registers r0 and r1.</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt></dt>
<dd>The carry register.</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt></dt>
<dd>Registers r8 and r9.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>A constant between 0 and 3 inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>A constant that has exactly one bit set.</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>A constant that has exactly one bit clear.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>A constant between 0 and 255 inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">M</span></tt></dt>
<dd>A constant between -255 and 0 inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt></dt>
<dd>A constant between -3 and 0 inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt></dt>
<dd>A constant between 1 and 4 inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">P</span></tt></dt>
<dd>A constant between -4 and -1 inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">Q</span></tt></dt>
<dd>A memory reference that is a stack push.</dd>
<dt><tt class="docutils literal"><span class="pre">R</span></tt></dt>
<dd>A memory reference that is a stack pop.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt></dt>
<dd>A memory reference that refers to a constant address of known value.</dd>
<dt><tt class="docutils literal"><span class="pre">T</span></tt></dt>
<dd>The register indicated by Rx (not implemented yet).</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt></dt>
<dd>A constant that is not between 2 and 15 inclusive.</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt></dt>
<dd>The constant 0.</dd>
</dl>
</div></blockquote>
<p><tt class="samp docutils literal"><span class="pre">Xtensa-</span><em><span class="pre">config/xtensa/constraints.md</span></em></tt></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">a</span></tt></dt>
<dd>General-purpose 32-bit register</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt></dt>
<dd>One-bit boolean register</dd>
<dt><tt class="docutils literal"><span class="pre">A</span></tt></dt>
<dd>MAC16 40-bit accumulator register</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt></dt>
<dd>Signed 12-bit integer constant, for use in MOVI instructions</dd>
<dt><tt class="docutils literal"><span class="pre">J</span></tt></dt>
<dd>Signed 8-bit integer constant, for use in ADDI instructions</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt></dt>
<dd>Integer constant valid for BccI instructions</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt></dt>
<dd>Unsigned constant valid for BccUI instructions</dd>
</dl>
</div></blockquote>
</div>
</div>
<div class="section" id="controlling-names-used-in-assembler-code">
<span id="asm-labels"></span><h2>Controlling Names Used in Assembler Code<a class="headerlink" href="#controlling-names-used-in-assembler-code" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-71"></span><span class="target" id="index-72"></span><p id="index-73">You can specify the name to be used in the assembler code for a C
function or variable by writing the <tt class="docutils literal"><span class="pre">asm</span></tt> (or <tt class="docutils literal"><span class="pre">__asm__</span></tt>)
keyword after the declarator as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">foo</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;myfoo&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>This specifies that the name to be used for the variable <tt class="docutils literal"><span class="pre">foo</span></tt> in
the assembler code should be <tt class="samp docutils literal"><span class="pre">myfoo</span></tt> rather than the usual
<tt class="samp docutils literal"><span class="pre">_foo</span></tt>.</p>
<p>On systems where an underscore is normally prepended to the name of a C
function or variable, this feature allows you to define names for the
linker that do not start with an underscore.</p>
<p>It does not make sense to use this feature with a non-static local
variable since such variables do not have assembler names.  If you are
trying to put the variable in a particular register, see Explicit
Reg Vars.  GCC presently accepts such code with a warning, but will
probably be changed to issue an error, rather than a warning, in the
future.</p>
<p>You cannot use <tt class="docutils literal"><span class="pre">asm</span></tt> in this way in a function <em>definition</em>; but
you can get the same effect by writing a declaration for the function
before its definition and putting <tt class="docutils literal"><span class="pre">asm</span></tt> there, like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="nf">func</span> <span class="p">()</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;FUNC&quot;</span><span class="p">);</span>

<span class="n">func</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
     <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="cm">/* ... */</span>
</pre></div>
</div>
<p>It is up to you to make sure that the assembler names you choose do not
conflict with any other assembler symbols.  Also, you must not use a
register name; that would produce completely invalid assembler code.  GCC
does not as yet have the ability to store static variables in registers.
Perhaps that will be added.</p>
</div>
<div class="section" id="variables-in-specified-registers">
<span id="explicit-reg-vars"></span><h2>Variables in Specified Registers<a class="headerlink" href="#variables-in-specified-registers" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-74"></span><span class="target" id="index-75"></span><span class="target" id="index-76"></span><p id="index-77">GNU C allows you to put a few global variables into specified hardware
registers.  You can also specify the register in which an ordinary
register variable should be allocated.</p>
<ul>
<li><p class="first">Global register variables reserve registers throughout the program.
This may be useful in programs such as programming language
interpreters that have a couple of global variables that are accessed
very often.</p>
</li>
<li><p class="first">Local register variables in specific registers do not reserve the
registers, except at the point where they are used as input or output
operands in an <tt class="docutils literal"><span class="pre">asm</span></tt> statement and the <tt class="docutils literal"><span class="pre">asm</span></tt> statement itself is
not deleted.  The compiler&#8217;s data flow analysis is capable of determining
where the specified registers contain live values, and where they are
available for other uses.  Stores into local register variables may be deleted
when they appear to be dead according to dataflow analysis.  References
to local register variables may be deleted or moved or simplified.</p>
<p>These local variables are sometimes convenient for use with the extended
<tt class="docutils literal"><span class="pre">asm</span></tt> feature (see <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>), if you want to write one
output of the assembler instruction directly into a particular register.
(This works provided the register you specify fits the constraints
specified for that operand in the <tt class="docutils literal"><span class="pre">asm</span></tt>.)</p>
</li>
</ul>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="defining-global-register-variables">
<span id="global-reg-vars"></span><h3>Defining Global Register Variables<a class="headerlink" href="#defining-global-register-variables" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-78"></span><p id="index-79">You can define a global register variable in GNU C like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">foo</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;a5&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">a5</span></tt> is the name of the register that should be used.  Choose a
register that is normally saved and restored by function calls on your
machine, so that library routines will not clobber it.</p>
<p>Naturally the register name is CPU-dependent, so you need to
conditionalize your program according to CPU type.  The register
<tt class="docutils literal"><span class="pre">a5</span></tt> is a good choice on a 68000 for a variable of pointer
type.  On machines with register windows, be sure to choose a &#8216;global&#8217;
register that is not affected magically by the function call mechanism.</p>
<p>In addition, different operating systems on the same CPU may differ in how they
name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register <tt class="docutils literal"><span class="pre">%a5</span></tt>.</p>
<p>Eventually there may be a way of asking the compiler to choose a register
automatically, but first we need to figure out how it should choose and
how to enable you to guide the choice.  No solution is evident.</p>
<p>Defining a global register variable in a certain register reserves that
register entirely for this use, at least within the current compilation.
The register is not allocated for any other purpose in the functions
in the current compilation, and is not saved and restored by
these functions.  Stores into this register are never deleted even if they
appear to be dead, but references may be deleted or moved or
simplified.</p>
<p>It is not safe to access the global register variables from signal
handlers, or from more than one thread of control, because the system
library routines may temporarily use the register for other things (unless
you recompile them specially for the task at hand).</p>
<p id="index-80">It is not safe for one function that uses a global register variable to
call another such function <tt class="docutils literal"><span class="pre">foo</span></tt> by way of a third function
<tt class="docutils literal"><span class="pre">lose</span></tt> that is compiled without knowledge of this variable (i.e. in a
different source file in which the variable isn&#8217;t declared).  This is
because <tt class="docutils literal"><span class="pre">lose</span></tt> might save the register and put some other value there.
For example, you can&#8217;t expect a global register variable to be available in
the comparison-function that you pass to <tt class="docutils literal"><span class="pre">qsort</span></tt>, since <tt class="docutils literal"><span class="pre">qsort</span></tt>
might have put something else in that register.  (If you are prepared to
recompile <tt class="docutils literal"><span class="pre">qsort</span></tt> with the same global register variable, you can
solve this problem.)</p>
<p>If you want to recompile <tt class="docutils literal"><span class="pre">qsort</span></tt> or other source files that do not
actually use your global register variable, so that they do not use that
register for any other purpose, then it suffices to specify the compiler
option <em class="xref std std-option">-ffixed-``reg``</em>.  You need not actually add a global
register declaration to their source code.</p>
<p>A function that can alter the value of a global register variable cannot
safely be called from a function compiled without this variable, because it
could clobber the value the caller expects to find there on return.
Therefore, the function that is the entry point into the part of the
program that uses the global register variable must explicitly save and
restore the value that belongs to its caller.</p>
<span class="target" id="index-81"></span><span class="target" id="index-82"></span><span class="target" id="index-83"></span><span class="target" id="index-84"></span><p id="index-85">On most machines, <tt class="docutils literal"><span class="pre">longjmp</span></tt> restores to each global register
variable the value it had at the time of the <tt class="docutils literal"><span class="pre">setjmp</span></tt>.  On some
machines, however, <tt class="docutils literal"><span class="pre">longjmp</span></tt> does not change the value of global
register variables.  To be portable, the function that called <tt class="docutils literal"><span class="pre">setjmp</span></tt>
should make other arrangements to save the values of the global register
variables, and to restore them in a <tt class="docutils literal"><span class="pre">longjmp</span></tt>.  This way, the same
thing happens regardless of what <tt class="docutils literal"><span class="pre">longjmp</span></tt> does.</p>
<p>All global register variable declarations must precede all function
definitions.  If such a declaration could appear after function
definitions, the declaration would be too late to prevent the register from
being used for other purposes in the preceding functions.</p>
<p>Global register variables may not have initial values, because an
executable file has no means to supply initial contents for a register.</p>
<p>On the SPARC, there are reports that g3 ... g7 are suitable
registers, but certain library functions, such as <tt class="docutils literal"><span class="pre">getwd</span></tt>, as well
as the subroutines for division and remainder, modify g3 and g4.  g1 and
g2 are local temporaries.</p>
<p>On the 68000, a2 ... a5 should be suitable, as should d2 ... d7.
Of course, it does not do to use more than a few of those.</p>
</div>
<div class="section" id="specifying-registers-for-local-variables">
<span id="local-reg-vars"></span><h3>Specifying Registers for Local Variables<a class="headerlink" href="#specifying-registers-for-local-variables" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-86"></span><span class="target" id="index-87"></span><p id="index-88">You can define a local register variable with a specified register
like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">foo</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;a5&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">a5</span></tt> is the name of the register that should be used.  Note
that this is the same syntax used for defining global register
variables, but for a local variable it appears within a function.</p>
<p>Naturally the register name is CPU-dependent, but this is not a
problem, since specific registers are most often useful with explicit
assembler instructions (see <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>).  Both of these things
generally require that you conditionalize your program according to
CPU type.</p>
<p>In addition, operating systems on one type of CPU may differ in how they
name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register <tt class="docutils literal"><span class="pre">%a5</span></tt>.</p>
<p>Defining such a register variable does not reserve the register; it
remains available for other uses in places where flow control determines
the variable&#8217;s value is not live.</p>
<p>This option does not guarantee that GCC generates code that has
this variable in the register you specify at all times.  You may not
code an explicit reference to this register in the assembler
instruction template part of an <tt class="docutils literal"><span class="pre">asm</span></tt> statement and assume it
always refers to this variable.
However, using the variable as an input or output operand to the <tt class="docutils literal"><span class="pre">asm</span></tt>
guarantees that the specified register is used for that operand.
See <a class="reference internal" href="#extended-asm"><em>Extended Asm - Assembler Instructions with C Expression Operands</em></a>, for more information.</p>
<p>Stores into local register variables may be deleted when they appear to be dead
according to dataflow analysis.  References to local register variables may
be deleted or moved or simplified.</p>
<p>As with global register variables, it is recommended that you choose a
register that is normally saved and restored by function calls on
your machine, so that library routines will not clobber it.</p>
<p>Sometimes when writing inline <tt class="docutils literal"><span class="pre">asm</span></tt> code, you need to make an operand be a
specific register, but there&#8217;s no matching constraint letter for that
register. To force the operand into that register, create a local variable
and specify the register in the variable&#8217;s declaration. Then use the local
variable for the asm operand and specify any constraint letter that matches
the register:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">);</span>
<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;sysint&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p2</span><span class="p">));</span>
</pre></div>
</div>
<p><em>Warning:</em> In the above example, be aware that a register (for example r0) can be
call-clobbered by subsequent code, including function calls and library calls
for arithmetic operators on other variables (for example the initialization
of p2). In this case, use temporary variables for expressions between the
register assignments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="k">asm</span> <span class="p">(</span><span class="s">&quot;r1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">t1</span><span class="p">;</span>
<span class="k">register</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span> <span class="nf">asm</span> <span class="p">(</span><span class="s">&quot;r0&quot;</span><span class="p">);</span>
<span class="k">asm</span> <span class="p">(</span><span class="s">&quot;sysint&quot;</span> <span class="o">:</span> <span class="s">&quot;=r&quot;</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;0&quot;</span> <span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="s">&quot;r&quot;</span> <span class="p">(</span><span class="n">p2</span><span class="p">));</span>
</pre></div>
</div>
<p id="size-of-an-asm">Size of an <tt class="docutils literal"><span class="pre">asm``Some</span> <span class="pre">targets</span> <span class="pre">require</span> <span class="pre">that</span> <span class="pre">GCC</span> <span class="pre">track</span> <span class="pre">the</span> <span class="pre">size</span> <span class="pre">of</span> <span class="pre">each</span> <span class="pre">instruction</span> <span class="pre">used</span>
<span class="pre">in</span> <span class="pre">order</span> <span class="pre">to</span> <span class="pre">generate</span> <span class="pre">correct</span> <span class="pre">code.</span>&nbsp; <span class="pre">Because</span> <span class="pre">the</span> <span class="pre">final</span> <span class="pre">length</span> <span class="pre">of</span> <span class="pre">the</span>
<span class="pre">code</span> <span class="pre">produced</span> <span class="pre">by</span> <span class="pre">an</span> <span class="pre">``asm</span></tt> statement is only known by the
assembler, GCC must make an estimate as to how big it will be.  It
does this by counting the number of instructions in the pattern of the
<tt class="docutils literal"><span class="pre">asm</span></tt> and multiplying that by the length of the longest
instruction supported by that processor.  (When working out the number
of instructions, it assumes that any occurrence of a newline or of
whatever statement separator character is supported by the assembler -
typically <tt class="samp docutils literal"><span class="pre">;</span></tt> - indicates the end of an instruction.)</p>
<p>Normally, GCC&#8217;s estimate is adequate to ensure that correct
code is generated, but it is possible to confuse the compiler if you use
pseudo instructions or assembler macros that expand into multiple real
instructions, or if you use assembler directives that expand to more
space in the object file than is needed for a single instruction.
If this happens then the assembler may produce a diagnostic saying that
a label is unreachable.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="alternate-keywords.html" title="Alternate Keywords"
             >next</a> |</li>
        <li class="right" >
          <a href="when-is-a-volatile-object-accessed?.html" title="When is a Volatile Object Accessed?"
             >previous</a> |</li>
        <li><a href="index.html">gcc 6 documentation</a> &raquo;</li>
          <li><a href="gcc.html" >Introduction</a> &raquo;</li>
          <li><a href="extensions-to-the-c-language-family.html" >Extensions to the C Language Family</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, gcc peeps.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>