<h3>Basics</h3>

<ul>
  <li><b>Bit</b>: The smallest unit in computers. It is either a 1 or a 0.</li>
  <li><b>Nibble</b>: Half a byte, or 4 bites. </li>
  <li><b>Byte</b>: 8 bits together form one byte, a number from 0 to 255.  Bits in the byte are numbered starting from the right at 0.</li>
  <li><b>Short</b>: Two bytes put together is 16 bits, forming a number from 0 to 65535. The low byte is the rightmost eight bits.</li>
  <li><b>Hex Number</b>: A HEX number consisting of 4 numbers is 16-bit.</li>
</ul>  

<h3>Binary to Hexadecimal Conversion</h3>

<p>Break down the binary value in chunks of 4, multiply each 1 by its equivalent value, either 8, 4, 2 or 1. Add the resulting numbers together to get the result. For example, the value 1100, or (8*1 + 4*1), is equal to C(decimal 12).</p>

<table border='1'>
  <tr><th colspan='8'><code>1101 0101(D5)</code></th></tr>
  <tr><td style='background:#eee'>1</td><td style='background:#eee'>1</td><td>0</td><td style='background:#eee'>1</td><td>0</td><td style='background:#eee'>1</td><td>0</td><td style='background:#eee'>1</td><td>Binary</td></tr>
  <tr><td style='background:#eee'>128</td><td style='background:#eee'>64</td><td>32</td><td style='background:#eee'>16</td><td>8</td><td style='background:#eee'>4</td><td>2</td><td style='background:#eee'>1</td><td>Values</td></tr>
  <tr><td style='background:#eee'>128</td><td style='background:#eee'>64</td><td></td><td style='background:#eee'>16</td><td></td><td style='background:#eee'>4</td><td></td><td style='background:#eee'>1</td><td>Result: 213</td></tr>
</table>

<h3>Hexadecimal to Binary Table</h3>

<table border='1'>
  <tr><td>0</td><td>0000</td><td>4</td><td>0100</td><td>8</td><td>1000</td><td>C</td><td>1100</td></tr>
  <tr><td>1</td><td>0001</td><td>5</td><td>0101</td><td>9</td><td>1001</td><td>D</td><td>1101</td></tr>
  <tr><td>2</td><td>0010</td><td>6</td><td>0110</td><td>A</td><td>1010</td><td>E</td><td>1110</td></tr>
  <tr><td>3</td><td>0011</td><td>7</td><td>0111</td><td>B</td><td>1011</td><td>F</td><td>1111</td></tr>
</table>

<h3>Arithmetic</h3>

<p><b>Addition</b></p>

<table border='1'>
  <tr><td>input</td><td>ADD</td><td>output</td><td>carry</td></tr>
  <tr><td>0</td><td>1</td><td>1</td><td>0</td></tr>
  <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>1</td><td>1</td><td>0</td><td>1</td></tr>
  <tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
</table>

<p><b>Subtraction</b></p>

<table border='1'>
  <tr><td>input</td><td>SUB</td><td>output</td><td>borrow</td></tr>
  <tr><td>0</td><td>1</td><td>1</td><td>1</td></tr>
  <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>1</td><td>1</td><td>0</td><td>0</td></tr>
  <tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
</table>

<p><b>Multiplication</b></p>

<table border='1'>
  <tr><td>input</td><td>MUL</td><td>output</td></tr>
  <tr><td>0</td><td>1</td><td>0</td></tr>
  <tr><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>1</td><td>1</td><td>1</td></tr>
  <tr><td>1</td><td>0</td><td>0</td></tr>
</table>

<h3>Bit Masks</h3>

<p><b>AND</b>, or "both", sets individual bits to 0. AND is useful for masking bits, for example, to mask the high order bits of a value AND with $0F: $36 AND $0F = $06.</p>

<table border='1'>
  <tr><td>input</td><td>AND</td><td>output</td></tr>
  <tr><td>0</td><td>1</td><td>0</td></tr>
  <tr><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>1</td><td>1</td><td>1</td></tr>
  <tr><td>1</td><td>0</td><td>0</td></tr>
</table>

<p><b>ORA</b>(OR), or "either one or both", sets individual bits to 1. OR is useful for setting a particular bit, for example, $80 OR $08 = $88</p>

<table border='1'>
  <tr><td>input</td><td>ORA</td><td>output</td></tr>
  <tr><td>0</td><td>1</td><td>1</td></tr>
  <tr><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>1</td><td>1</td><td>1</td></tr>
  <tr><td>1</td><td>0</td><td>1</td></tr>
</table>

<p><b>EOR</b>(XOR), or "one or the other but not both", inverts individual bits.</p>

<table border='1'>
  <tr><td>input</td><td>EOR</td><td>output</td></tr>
  <tr><td>0</td><td>1</td><td>1</td></tr>
  <tr><td>0</td><td>0</td><td>0</td></tr>
  <tr><td>1</td><td>1</td><td>0</td></tr>
  <tr><td>1</td><td>0</td><td>1</td></tr>
</table>

<h3>Rotate</h3>

<p><b>ROL</b> rotate one bit left to multiply by 2, and <b>ROR</b> rotates one bit right to divided by 2.</p>

<table border='1'>
  <tr><td>input</td><td>op</td><td>output</td></tr>
  <tr><td>0110(6)</td><td>ROL</td><td>1100(C)</td></tr>
  <tr><td>0110(6)</td><td>ROR</td><td>0011(3)</td></tr>
</table>

<h3>Signed Integers</h3>

<p>If Bit 7 is not set (as in the first example) the representation of signed and unsigned numbers is the same. However, when Bit 7 is set, the number is always negative. For this reason Bit 7 is sometimes called the sign bit.</p>

<table width="289" border="1">
  <tr><td >Binary</td><td>Unsigned</td><td>Signed</td></tr>
  <tr><td>0010 0011</td><td>35</td><td>35</td></tr>
  <tr><td>1010 0011</td><td>163</td><td>-93</td></tr>
  <tr><td>1111 1111</td><td>255</td><td>-1</td></tr>
  <tr><td>1000 0000</td><td>128</td><td>-128</td></tr>
</table>

<h3>Add with bitwise in C</h3>

<pre>
int Add(int x, int y) 
{ 
  /* Iterate till there is no carry   */
  while (y != 0) 
  { 
    /* carry now contains common  */
    /* set bits of x and y */
    int carry = x & y;   

    /* Sum of bits of x and y where at  */
    /* least one of the bits is not set */
    x = x ^ y;  

    /* Carry is shifted by one so that adding */
    /* it to x gives the required sum */
    y = carry << 1; 
  } 
  return x; 
} 
</pre>