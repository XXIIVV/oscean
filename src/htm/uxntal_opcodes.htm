<h2>Uxntal Opcodes</h2>

<p>Uxn has 32 standard opcodes and 4 <a href='#immediate'>immediate opcodes</a>.
The | character, in the table below, indicates an effect on the return stack.</p>

<table border='1' id='opcodes'>
	<tr>
		<th colspan='4'>Standard Opcodes</th>
	</tr>
	<tr>
		<th>stack I</th>
		<th>logic</th>
		<th>ram I</th>
		<th>arithmetic</th>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#brk'>BRK</a> -- </td>
		<td><a href='uxntal_reference.html#equ'>EQU</a> a b -- a==b</td>
		<td><a href='uxntal_reference.html#ldz'>LDZ</a> abs8 -- [abs8]</td>
		<td><a href='uxntal_reference.html#add'>ADD</a> a b -- a+b</td>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#inc'>INC</a> a -- a+1</td>
		<td><a href='uxntal_reference.html#neq'>NEQ</a> a b -- a!=b</td>
		<td><a href='uxntal_reference.html#stz'>STZ</a> val abs8 -- </td>
		<td><a href='uxntal_reference.html#sub'>SUB</a> a b -- a-b</td>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#pop'>POP</a> a -- </td>
		<td><a href='uxntal_reference.html#gth'>GTH</a> a b -- a>b</td>
		<td><a href='uxntal_reference.html#ldr'>LDR</a> rel8 -- [rel8]</td>
		<td><a href='uxntal_reference.html#mul'>MUL</a> a b -- a*b</td>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#nip'>NIP</a> a b -- b</td>
		<td><a href='uxntal_reference.html#lth'>LTH</a> a b -- a&lt;b</td>
		<td><a href='uxntal_reference.html#str'>STR</a> val rel8 -- </td>
		<td><a href='uxntal_reference.html#div'>DIV</a> a b -- a/b</td>
	</tr>
	<tr>
		<th>stack II</th>
		<th>stash</th>
		<th>ram II</th>
		<th>bitwise</th>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#swp'>SWP</a> a b -- b a</td>
		<td><a href='uxntal_reference.html#jmp'>JMP</a> addr -- </td>
		<td><a href='uxntal_reference.html#lda'>LDA</a> abs16 -- [abs16]</td>
		<td><a href='uxntal_reference.html#and'>AND</a> a b -- a&b</td>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#rot'>ROT</a> a b c -- b c a</td>
		<td><a href='uxntal_reference.html#jcn'>JCN</a> cond8 addr -- </td>
		<td><a href='uxntal_reference.html#sta'>STA</a> val abs16 -- </td>
		<td><a href='uxntal_reference.html#ora'>ORA</a> a b -- a|b</td>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#dup'>DUP</a> a -- a a</td>
		<td><a href='uxntal_reference.html#jsr'>JSR</a> addr -- | pc16 </td>
		<td><a href='uxntal_reference.html#dei'>DEI</a> dev -- [dev]</td>
		<td><a href='uxntal_reference.html#eor'>EOR</a> a b -- a^b</td>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#ovr'>OVR</a> a b -- a b a</td>
		<td><a href='uxntal_reference.html#sth'>STH</a> a -- | a </td>
		<td><a href='uxntal_reference.html#deo'>DEO</a> val dev -- </td>
		<td><a href='uxntal_reference.html#sft'>SFT</a> a sft8 -- res</td>
	</tr>
	<tr>
		<th colspan='4'>Immediate Opcodes</th>
	</tr>
	<tr>
		<td><a href='uxntal_reference.html#lit'>LIT</a> -- [pc]</td>
		<td><a href='uxntal_reference.html#jci'>JCI</a> cond8 -- </td>
		<td><a href='uxntal_reference.html#jmi'>JMI</a> -- </td>
		<td><a href='uxntal_reference.html#jsi'>JSI</a> -- | pc16</td>
	</tr>
</table>

<style>
	table#opcodes td a { font-family:mono, monospace }
</style>

<h3 id='modes'>Modes</h3>

<p>Each opcode has 3 possible modes, which can combined:</p>

<ul>
	<li>The <b>short mode</b> <kbd>2</kbd> operates on shorts, instead of bytes.</li>
	<li>The <b>keep mode</b> <kbd>k</kbd> operates without consuming items.</li>
	<li>The <b>return mode</b> <kbd>r</kbd> operates on the return stack.</li>
</ul>

<table border='1' style='float:right'>
	<tr><th colspan='8'>INC2r</th></tr>
	<tr><th>k</th><th>r</th><th>2</th><th colspan='5'>opcode</th></tr>
	<tr><td>0</td><td class='highlight'>1</td><td class='highlight'>1</td>
	<td>0</td><td>0</td><td>0</td><td>0</td><td class='highlight'>1</td></tr>
</table>

<p>By default, operators consume bytes from the working stack, notice how in the
following example only the last two bytes <code>#45</code> and <code>#67</code>
are added, even if there are two shorts on the stack.</p>
<pre>#1234 #4567 ADD<span style='float:right'>12 34 ac</span></pre>

<p id='2_mode'>The <b>short mode</b> consumes two bytes from the stack. In the
case of jump opcodes, the short-mode operation jumps to an absolute address in
memory. For the memory accessing opcodes, the short mode operation indicates
the size of the data to read and write.</p>
<pre>#1234 #4567 ADD2 <span style='float:right'>57 9b</span></pre>

<p id='k_mode'>The <b>keep mode</b> does not consume items from the stack, and
pushes the result on top. Every opcode begins by popping values from the stack
before operating on them. This mode keeps a copy of the stack pointer to
recover after the popping stage.</p>

<pre>#1234 #4567 ADD2k <span style='float:right'>12 34 45 67 57 9b</pre>

<p id='r_mode'>The <b>return mode</b> swaps the stacks on which an opcode
operates. Under this mode, a return address will be pushed to the working
stack, and stashing will take from the return stack. For that reason, there is
no <i>return</i> opcode. For example, the <code>JSR</code> opcode pushes the
return address onto the return stack, and <code>JMP2r</code> jumps to that
address.</p>

<pre>LITr 12 #34 STH ADDr STHr <span style='float:right'>46</span></pre>

<img src="../media/generic/uxn.crew.png" width="400"/>

<style>
	.highlight { background:#eee }
	@media (prefers-color-scheme:dark) {
		.highlight { background:#222 }
	}
</style>

<h3 id='immediate'>Immediate opcodes</h3>

<p>Immediate opcodes are operators that do not take items from the stack, but
read values stored <i>immediately</i> after the opcode in the program's memory.
Uxntal has 4 immediate opcodes: </p>

<ul>
	<li>The <b>literal</b> <kbd><a href='uxntal_reference.html#lit'>LIT</a></kbd>.</li>
	<li id='jmi'>The <b>jump</b> <kbd><a href='uxntal_reference.html#jmi'>!routine</a></kbd>, immediate of <kbd>JMP</kbd>.</li>
	<li id='jci'>The <b>conditional</b> <kbd><a href='uxntal_reference.html#jci'>?routine</a></kbd>, immediate of <kbd>JCN</kbd>.</li>
	<li>The <b>subroutine</b> <kbd><a href='uxntal_reference.html#jsi'>routine</a></kbd>, immediate of <kbd>JSR</kbd>.</li>
</ul>

<p>The immediate jump opcodes are slightly faster than their standard opcode
counterparts, but do not have modes and cannot be used to do pointer
arithmetic. The address value of the immediate opcodes are stored in memory as
relative shorts, enabling routines making use of these opcodes to be moved
around in the program's memory.</p>

<pre>
<b>@on-reset</b> <i>( -> )</i>
	#0007 fact
	BRK

<b>@fact</b> <i>( n* -- res* )</i>
	ORAk ?{ POP2 #0001 JMP2r }
	DUP2 #0001 SUB2 fact MUL2
	JMP2r</pre>

<p>To learn more about each opcode, see the <a
href='uxntal_reference.html'>Opcode Reference</a>.</p>
