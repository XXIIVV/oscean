<h3>Register Machine Emulator</h3>

<p>The pen, representing the program counter, is positioned at the first line of the program. The instruction on that line is processed by modifying the value of a register, or checking if a register is Zero and then moving to the next instruction. The evaluation stops upon reaching a halt or empty instruction.</p>

<ul>
	<li><code>CLR(r)</code>: <b>Set</b> register r to Zero.</li>
	<li><code>INC(r)</code>: <b>Add 1</b> to the register r.</li>
	<li><code>DEC(r)</code>: <b>Subtract 1</b> from register r.</li>
	<li><code>CPY(a, b)</code>: <b>Copy</b> the register a in register b.</li>
	<li><code>JZ(r, i)</code>: <b>If</b> register r is Zero, <b>jump</b> to instruction i.</li>
	<li><code>JE(a, b, i)</code>: <b>If</b> the registers a and b are equal, <b>jump</b> to instruction i.</li>
</ul>

<!--

<p>The following three counter machine models have the same computational power
since the instructions of one model can be derived from those of another:</p>

<ul>
	<li><b>INC</b>(r), <b>DEC</b>(r), <b>JZ</b>(r, z) &mdash; <i>Minsky (1961, 1967), Lambek (1961)</i></li>
	<li><b>CLR</b>(r), <b>INC</b>(r), <b>JE</b>(rj, rk, z) &mdash; <i>Ershov (1958), Peter (1958)</i></li>
	<li><b>INC</b>(r), <b>CPY</b>(rj, rk), <b>JE</b>(rj, rk, z) &mdash; <i>Elgot-Robinson (1964), Minsky (1967)</i></li>
</ul>

-->
