<h2>Uxntal Labels</h2>

<p>A label is a non-numeric, non-opcode, and non-runic symbol that correspond to
a number between 0 and 65536. A label name is made of two parts, a scope and a
sublabel. Sublabels can be added to a scope with the <kbd>&name</kbd> rune, or
by writing the full name, like <kbd>@scope/name</kbd>. Note that a labels like
<i>bed</i>, <i>add</i> and <i>cafe</i> are considered numeric.</p>

<p><b>Routines</b> are labels that will be jumped to, a <kbd>@routine</kbd> has
its own scope, making it possible for multiple routines to have their own
instance of the label <kbd>&loop</kbd>.</p>

<pre>
@routine ( a b -- c )
	&loop
		INC GTHk ?&loop
	ADD JMP2r
</pre>

<p><b>Constants</b> are labels that hold a specific value through the entire
execution of the program. They allow to create label that can be used in place
of a number, making the code more readable.</p>

<pre>
|1400 @limit

@within-limit ( value* -- f )
	;limit LTH2
	JMP2r
</pre>

<p><b>Enums</b> are labels with unique values that can be used as constants in a
program, they begin by rolling back the program address with
<kbd>|00</kbd>:</p>

<pre>
|00 @Suit &clubs $1 &diamonds $1 &hearts $1 &spades

@is-diamond ( suit -- f )
	.Suit/clubs EQU
	JMP2r
</pre>

<p id='structs'><b>Structs</b> define padded labels, for example the
<code>;person/age</code> label holds a value of 2, using that offset allows to
access specific members of a data structure by applying the sublabels to a
pointer:</p>

<pre>
|00 @Person &name $2 &age $1 &height $2
@members
	=dict/melanye 2a 008c
	=dict/alexane 2c 009a

@get-height ( member* -- height* )
	;Person/height ADD2 LDA2
	JMP2r
</pre>

<p>Labels can also be used with the padding runes to define a
global length. For example, if one needs to specify a length of 0x30 for
multiple members of a struct, a value can be specified as follow:</p>

<pre>
|30 @length
|00 @struct &field $length
</pre>

<h3 id='scope'>Scope</h3>

<p>Uxntal objects are defined statically using a <kbd>@label</kbd> token, it
allows for the enclosed methods to access local <kbd>&labels</kbd>. The example
below creates an object with the method <kbd>get-x</kbd>, accessible from
outside the scope as <kbd>Object/get-x</kbd>. By capitalizing the object name,
we communicate to the assembler that the label will not be called and should
not raise a warning.</p>

<pre>
@Object &x $1 &y $1

&get-x <i>( -- x )</i>
	,&x LDR JMP2r
</pre>

<p>New methods and members can be appended to an existing scope by creating a
label with the scope name followed by a slash and the name of the extension.
The <kbd>&labels</kbd> declared within the extension have the same access to
local labels as the rest of the object.</p>

<pre>
@Object/get-y <i>( -- y )</i>
	,&y LDR JMP2r
</pre>

<p id='method'>When calling local methods the scope's name can be omitted,
starting at the slash, like <kbd>/method</kbd>:</p>

<pre>
&get-both <i>( -- x y )</i>
	/get-x /get-y JMP2r
</pre>

<h3 id='addressing'>Addressing</h3>

<p>A labels is a way of assigning a name to a number. There are six ways to get
the number corresponding to that label. Literal addressing prefixes the label
with a <code>LIT</code> for Relative and Zero-Page addressing, and
<code>LIT2</code> for absolute addressing.</p>

<ul>
	<li id='litrel'><b>Literal Relative</b>, like <kbd>,label</kbd>, pushes a
relative distance byte to the label.</li>
	<li id='litzep'><b>Literal Zero-Page</b>, like <kbd>.label</kbd>, pushes an
absolute address byte to the label.</li>
	<li id='litabs'><b>Literal Absolute</b>, like <kbd>;label</kbd>, pushes an
absolute address short to the label.</li>
	<li id='rawrel'><b>Raw Relative</b>, like <kbd>_label</kbd>, writes a
relative distance byte to the label.</li>
	<li id='rawzep'><b>Raw Zero-Page</b>, like <kbd>-label</kbd>, writes an
absolute address byte to the label.</li>
	<li id='rawabs'><b>Raw Absolute</b>, like <kbd>=label</kbd>, writes an
absolute address short to the label.</li>
</ul>

<p>Raw addressing is used for building data-structures and more advanced
programs. A relatively common usage of raw runes is to create literals directly
into the return stack:</p>

<pre>
[ LITr ab ] STHr INC <span style='float:right'>ac</span>
</pre>

<h3 id='anonymous'>Anonymous Labels</h3>

<p>Anonymous labels are designated with a curly bracket that points to its
associated closing bracket, and can be nested. Under the hood, the opening
bracket assembles to the address of the closing bracket which allows the
destination address to be used like any other label such as a JCI
<kbd>?{</kbd>, a JMI, <kbd>!{</kbd> or a plain literal <kbd>;{</kbd>. Here are
some example data-structures:</p>

<pre>
@counted-string
	_{ "foo 20 "bar }

@linked-list
	={ ={ "A } ={ "B ={ "C } } }
</pre>

<h4 id='unless'>Unless Blocks</h4>

<p>It is important to notice that in the case of a conditional jump, the
lambda's content is <b>jumped over when the flag byte is true</b>.</p>

<pre>
[ LIT2 &last $1 -Mouse/state ] DEI DUP ,&last STR
DUP2 #0001 NEQ2 ?{ ( on down ) }
DUP2 #0101 NEQ2 ?{ ( on drag ) }
DUP2 #0100 NEQ2 ?{ ( on release ) }
POP2
</pre>

<p>The opening curly bracket assembles to a unique label reference, and the
closing bracket to a corresponding matching label definition. They do not
affect the scope.</p>

