<!DOCTYPE html><html lang='en'></head><meta charset='utf-8'><meta name='description' content='Arithmetics is study of numbers, especially the properties of the traditional operations on them.'/><meta name='thumbnail' content='https://wiki.xxiivv.com/media/services/thumbnail.jpg' /><meta name='viewport' content='width=device-width,initial-scale=1'><link rel='alternate' type='application/rss+xml' title='RSS Feed' href='../links/rss.xml' /><link rel='stylesheet' type='text/css' href='../links/main.css'><link rel='shortcut icon' type='image/png' href='../media/services/icon.png'><title>XXIIVV — arithmetic</title></head><body><header><a href='home.html'><img src='../media/icon/logo.svg' alt='XXIIVV' height='29'></a></header><nav><ul><li><a href='audio.html'>audio</a></li><li><a href='visual.html'>visual</a></li><li><a href='research.html'>research/</a></li><li><a href='about.html'>about</a></li></ul><ul><li><a href='arithmetic.html'>arithmetic/</a></li><li><a href='language.html'>language</a></li><li><a href='computation.html'>computation</a></li><li><a href='hardware.html'>hardware</a></li><li><a href='mirrors.html'>mirrors</a></li><li><a href='notebook.html'>notebook</a></li></ul><ul><li><a href='binary.html'>binary</a></li><li><a href='reverse_polish.html'>reverse polish</a></li><li><a href='fractran.html'>fractran</a></li></ul></nav><main><h2>Arithmetics is study of numbers, especially the properties of the traditional operations on them.</h2><figure><h3>Primes</h3>

<p>Multiplying two numbers is the same as adding the counts of each prime factors, and division is the same as subtracting the counts. To experiment with primes, have a look at <a href='fractran.html'>Fractran</a>. For example, using numbers made up of the 3 first primes(2, 3, 5), 2250 is equal to <code>2^1 x 3^2 x 5^3</code>.</p>

<table border='1'>
	<tr><th colspan='3' style='text-align:center'>6 * 375 = 2250</th></tr>
	<tr><td>6(1,1,0)</td><td>375(0,1,3)</td><td>2250(1,2,3)</td></tr>
</table>

<p>To find the prime factorization of a number, start by dividing the number by the first prime number 2 and continue dividing by 2 until you get a decimal or remainder. Then divide by 3, 5, 7, etc. until the only numbers left are prime numbers. </p>

<h3>Peasant Multiplication</h3>

<p>In the first column, divide the first number by 2, dropping the remainder if any, until 1 is reached. In the second column, write the numbers obtained by successive multiplication by 2. The answer is found by adding the numbers in the doubling column with odd numbers in their first column.</p>

<table border="1" style='float:left; margin-right:30px'>
	<tr><th colspan='3'>64 x 61</th></tr>
	<tr><td>64</td><td>61</td><td></td></tr>
	<tr><td>32</td><td>122</td><td></td></tr>
	<tr><td>16</td><td>244</td><td></td></tr>
	<tr><td>8</td><td>488</td><td></td></tr>
	<tr><td>4</td><td>976</td><td></td></tr>
	<tr><td>2</td><td>1952</td><td></td></tr>
	<tr style='background:#eee'><td>1</td><td>3904</td><td>+3904</td></tr>
	<tr><th colspan='3'>Result: 3904</th></tr>
</table>

<table border="1">
	<tr><th colspan='3'>61 x 64</th></tr>
	<tr style='background:#eee'><td>61</td><td>64</td><td>+64</td></tr>
	<tr><td>30</td><td>128</td><td></td></tr>
	<tr style='background:#eee'><td>15</td><td>256</td><td>+256</td></tr>
	<tr style='background:#eee'><td>7</td><td>512</td><td>+512</td></tr>
	<tr style='background:#eee'><td>3</td><td>1024</td><td>+1024</td></tr>
	<tr style='background:#eee'><td>1</td><td>2048</td><td>+2048</td></tr>
	<tr><th colspan='3'>Result: 3904</th></tr>
</table>

<hr />

<h3>Addition of 5</h3>
<p>When adding 5 to a digit greater than 5, it is easier to first subtract 5 and then add 10.</p>
<pre>
7 + 5 = 12.
Also 7 - 5 = 2; 2 + 10 = 12.
</pre>

<h3>Subtraction of 5</h3>
<p>When subtracting 5 from a number ending with a a digit smaller than 5, it is easier to first add 5 and then subtract 10.<p>
<pre>
23 - 5 = 18.
Also 23 + 5 = 28; 28 - 10 = 18.
</pre>

<h3>Division by 5</h3>
<p>Similarly, it's often more convenient instead to multiply first by 2 and then divide by 10.</p>
<pre>1375/5 = 2750/10 = 275.</pre>

<h3>Multiplication by 5</h3>
<p>It's often more convenient instead of multiplying by 5 to multiply first by 10 and then divide by 2.</p>
<pre>137×5 = 1370/2 = 685.</pre>

<h3>Division by 5</h3>
<p>Similarly, it's often more convenient instead to multiply first by 2 and then divide by 10.</p>
<pre>1375/5 = 2750/10 = 275.</pre>

<h3>Division/multiplication by 4</h3>
<p>Replace either with a repeated operation by 2.</p>
<pre>
124/4 = 62/2 = 31. Also,
124×4 = 248×2 = 496.
</pre>

<h3>Division/multiplication by 25</h3>
<p>Use operations with 4 instead.</p>
<pre>
37×25 = 3700/4 = 1850/2 = 925.
</pre>

<h3>Division/multiplication by 8</h3>
<p>Replace either with a repeated operation by 2.</p>
<pre>
124×8 = 248×4 = 496×2 = 992.
</pre>

<h3>Division/multiplication by 125</h3>
<p>Use operations with 8 instead.</p>
<pre>
37×125 = 37000/8 = 18500/4 = 9250/2 = 4625.
</pre>

<!--
Any Square.
Assume you want to find 87². Find a simple number nearby - a number whose square could be found relatively easy. In the case of 87 we take 90. To obtain 90, we need to add 3 to 87; so now let's subtract 3 from 87. We are getting 84. Finally,

87² = 90×84 + 3² = 7200 + 360 + 9 = 7569.

More examples and explanation
Squares Can Be Computed Squentially
In case A is a successor of a number with a known square, you find A⊃ by adding to the latter itself and then A. For example, A = 111 is a successor of a = 110 whose square is 12100. Added to this 110 and then 111 to get A²:

111²	= 110² + 110 + 111
 	= 12100 + 221
 	= 12321.

More examples and explanation
Squares of numbers that end with 5.
A number that ends in 5 has the form A = 10a + 5, where a has one digit less than A. To find the square A² of A, append 25 to the product a×(a + 1) of a with its successor. For example, compute 115². 115 = 11×10 + 5, so that a = 11. First compute 11×(11 + 1) = 11×12 = 132 (since 3 = 1 + 2). Next, append 25 to the right of 132 to get 13225!

More examples and explanation
Product of 10a + b and 10a + c where b + c = 10.
Similar to the squaring of numbers that end with 5:

For example, compute 113×117, where a = 11, b = 3, and c = 7. First compute 11×(11 + 1) = 11×12 = 132 (since 3 = 1 + 2). Next, append 21 (= 3×7) to the right of 132 to get 13221!

More examples and explanation
Product of two one-digit numbers greater than 5.
This is a rule that helps remember a big part of the multiplication table. Assume you forgot the product 7×9. Do this. First find the excess of each of the multiples over 5: it's 2 for 7 (7 - 5 = 2) and 4 for 9 (9 - 5 = 4). Add them up to get 6 = 2 + 4. Now find the complements of these two numbers to 5: it's 3 for 2 (5 - 2 = 3) and 1 for 4 (5 - 4 = 1). Remember their product 3 = 3×1. Lastly, combine thus obtained two numbers (6 and 3) as 63 = 6×10 + 3.

More examples and explanation
Product of two 2-digit numbers.

The simplest case is when two numbers are not too far apart and their difference is even, for example, let one be 24 and the other 28. Find their average: (24 + 28)/2 = 26 and half the difference (28 - 24)/2 = 2. Subtract the squares:

28×24 = 26² - 2² = 676 - 4 = 672.

The ancient Babylonian used a similar approach. They calculated the sum and the difference of the two numbers, subtracted their squares and divided the result by four. For example,
 	33×32	= (65² - 1²)/4
 	 	= (4225 - 1)/4
 	 	= 4224/4
 	 	= 1056.

More examples and explanation
Product of numbers close to 100.
Say, you have to multiply 94 and 98. Take their differences to 100: 100 - 94 = 6 and 100 - 98 = 2. Note that 94 - 2 = 98 - 6 so that for the next step it is not important which one you use, but you'll need the result: 92. These will be the first two digits of the product. The last two are just 2×6 = 12. Therefore, 94×98 = 9212.

More examples and explanation
Multiplying by 11.
To multiply a 2-digit number by 11, take the sum of its digits. If it's a single digit number, just write it between the two digits. If the sum is 10 or more, do not forget to carry 1 over.

For example, 34×11 = 374 since 3 + 4 = 7. 47×11 = 517 since 4 + 7 = 11.
Faster subtraction.
Subtraction is often faster in two steps instead of one.

For example,

427 - 38 = (427 - 27) - (38 - 27) = 400 - 11 = 389.

A generic advice might be given as "First remove what's easy, next whatever remains". Another example:

1049 - 187 = 1000 - (187 - 49) = 900 - 38 = 862.
Faster addition.
Addition is often faster in two steps instead of one.

For example,

487 + 38 = (487 + 13) + (38 - 13) = 500 + 25 = 525.

A generic advice might be given as "First add what's easy, next whatever remains". Another example:

1049 + 187 = 1100 + (187 - 51) = 1200 + 36 = 1236.
Faster addition, #2.
It's often faster to add a digit at a time starting with higher digits. For example,

583 + 645	= 583 + 600 + 40 + 5
 	= 1183 + 40 + 5
 	= 1223 + 5
 	= 1228.
Multipliply, then subtract.
When multiplying by 9, multiply by 10 instead, and then subtract the other number. For example,

23×9 = 230 - 23 = 207.

More examples and explanation

The same applies to other numbers near those for which multiplication is simplified:
 	23×51	= 23×50 + 23
		= 2300/2 + 23
		= 1150 + 23
		= 1173.
 	 	 
 	87×48	= 87×50 - 87×2
		= 8700/2 - 160 - 14
		= 4350 - 160 - 14
		= 4190 - 14
		= 4176.

--><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/html/arithmetic.htm' target='_blank'>edit</a> to <a href='../src/inc/html/arithmetic.htm'>arithmetic.htm</a>(187 lines)</figcaption>
</figure><h2><a href='binary.html'>binary</a></h2><h4>Binary numbers are a base 2 numeral system.</h4><p>A binary number is a number expressed in the base-2 numeral system, which uses only two symbols: 0 and 1. Each digit is referred to as a bit. Because of its straightforward implementation in digital electronic circuitry using logic gates, the binary system is used by almost all modern computers and computer-based devices.</p><figure><img src='../media/refs/binary.jpg' width='200'/>&nbsp;<figcaption>—Two of Leibniz's binary calculation examples</figcaption></figure><p>To explore binary logic, see <a href='noton.html'>Noton</a> or <a href='papier.html'>Der Papiercomputer</a>.</p><h2><a href='reverse_polish.html'>reverse polish</a></h2><h4>In Reverse Polish Notation, the operators follow their operands.</h4><p>In RPN calculators, no equals key is required to force computation to occur. To learn more about a programming language using RPN at its core, see <a href='forth.html'>Forth</a>. To find a simple RPN implementation and playground, see <a href='firth.html'>Firth</a>.</p><h2><a href='fractran.html'>fractran</a></h2><h4>Fractran is insanely difficult to program in, but based on one of the most bizarrely elegant concepts of computation.</h4><p>A Fractran program is an ordered list of positive fractions together with an initial positive integer input. The program is run by updating the accumulator.</p><figure><img src='../media/refs/fractran.jpg' width='340'/>&nbsp;<figcaption>—The Book of Numbers, <a href='https://en.wikipedia.org/wiki/John_Horton_Conway' target='_blank'>John Conway</a></figcaption></figure><p>Any number that can't be divided by any other number, apart from itself and one, is prime. Since primes can't be divided, we can think of them as the DNA of other numbers. In Fractran, each prime is a register and their exponent is their value. </p><figure><h3>The Accumulator</h3>

<p>The <b>state of the accumulator</b> is held as a single number, whose prime factorization holds these registers(2, 3, 5, 7, 11, 13, 17, ..). If the state of the accumulator is 1008(2⁴ × 3² × 7), r2 has the value 4, r3 has the value 2, r7 has the value 1, and all other registers are unassigned. </p>

<table border='1'>
	<tr><th>accumulator</th><th colspan='4'>registers</th></tr>
	<tr><th></th><th>r2</th><th>r3</th><th>r5</th><th>r7</th></tr>
	<tr><th>6</th><td>1</td><td>1</td><td></td><td></td></tr>
	<tr><th>18</th><td>1</td><td>2</td><td></td><td></td></tr>
	<tr><th>1008</th><td>4</td><td>2</td><td></td><td>1</td></tr>
	<tr><th>5402250</th><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</table>

<h3>The Operators</h3>

<img src='../media/refs/fractran.adder1.jpg' width='140px'/>

<p>A fractran operation is a positive fraction, each fraction represents an instruction that tests one or more registers, represented by the prime factors of its denominator. The Fractran computer goes through each fraction in order, in terms of our current accumulator value.</p>

<pre>18(2<sup>1</sup> × 3<sup>2</sup>) <b>2/3</b> = 8(2<sup>3</sup>) <i>addition r2+r3->r2</i></pre>

<p>To run the <i>adder operation</i>(<code>2/3</code>), we will take the state of the accumulator. If multiplying it by this fraction will give us an integer, we will do so and start again at the beginning of the program. Otherwise, we will stop and consider the program complete. We will do this repeatedly until we can no longer produce an integer with this method. </p>

<table border='1'>
	<tr><th rowspan='2'>steps</th><th rowspan='2'>state</th><th colspan='2'>registers</th></tr>
	<tr><th>r2</th><th>r3</th></tr>
	<tr style='background:#eee'><td>1</td><th>18</th><td>1</td><td>2</td><td>18 × 2/3 = 12/1</td><td>INT, RESTART</td></tr>
	<tr><td>2</td><th>12</th><td>2</td><td>1</td><td>12 × 2/3 = 8/1</td><td>INT, RESTART</td></tr>
	<tr><td>3</td><th>8</th><td>3</td><td></td><td>8 × 2/3 = 16/3</td><td>NOT INT, END</td></tr>
</table>

<p>To add the values 1 and 2, we will store the values in registers 2 and 3, our starting state is therefore 18(2<sup>1</sup> × 3<sup>2</sup>).</p>

<p>For each step of the program, we will multiply our state with the program(18 × 2/3 = 12, 12 × 2/3 = 8, ..) until our our working value cannot be reduced to a whole number(16/3), we have exhausted the program. Alternatively, the program <code>3/2</code> will do the same operation but store the result in the register 3. </p>

<pre>576(2<sup>6</sup> × 3<sup>2</sup>) <b>1/6</b> = 16(2<sup>4</sup>) <i>subtraction r2-r3->r2</i></pre>

<p>Operations become more readable when broken down into their primes. We can think of every prime number as having a register which can take on non-negative integer values. Each fraction is an instruction that operates on some of the registers.</p>

<table border='1'>
	<tr>
		<th>2/3</th>
		<th>15/256</th>
		<th>21/20</th>
	</tr>
	<tr>
		<td>(<span class='numreg'>2</span><sup class='numval'>1</sup>)/(<span class='denreg'>3</span><sup class='denval'>1</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>5</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>6</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>7</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>2</sup> × <span class='denreg'>5</span><sup class='denval'>1</sup>)</td>
	</tr>
	<tr>
		<td>
<pre>
if(<span class='denreg'>r3</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r3</span> -= <span class='denval'>1</span>;
	<span class='numreg'>r2</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>6</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>6</span>;
	<span class='numreg'>r3</span> += <span class='numval'>1</span>;
	<span class='numreg'>r5</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>2</span> && <span class='denreg'>r5</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>2</span>; 
	<span class='denreg'>r5</span> -= <span class='denval'>1</span>; 
	<span class='numreg'>r3</span> += <span class='numval'>1</span>; 
	<span class='numreg'>r7</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
	</tr>
</table>

<p>You can interpret a fraction as saying if the current value of each register is greater than or equal to the the value specified by the denominator, you subtract from the registers all of the values in the denominator, add all the values specified in the numerator, and then jump back to the first instruction. Otherwise, if any register is less than the value specified in the denominator, continue to the next fraction.</p>

<h3>The Programs</h3>

<img src='../media/refs/fractran.adder2.jpg' width='160px'/>

<p>Let's consider an adder program similar from the one above(<code>2/3</code>) but which writes to a third register. The following program first moves the content in r2 to r3, and then the content of r3 to r5.</p>

<pre>18(2<sup>1</sup> × 3<sup>2</sup>) <b>3/2 5/3</b> = 125(5<sup>3</sup>) <i>addition r2+r3->r5(9 steps)</i></pre>

<p>Alternatively, a faster way to do this would be to directly move powers of 2 over to 5, then powers of 3.</p>

<pre>18(2<sup>1</sup> × 3<sup>2</sup>) <b>5/2 5/3</b> = 125(5<sup>3</sup>) <i>addition r2+r3->r5(7 steps)</i></pre>

<p>Each of the 7 steps of this last program looks like: </p>

<pre>
18 5/2 5/3           [18]  r2=01 r3=02
------------------   -----------------
18 × 5/2 = 45/1      [45]  r3=02 r5=01
45 × 5/2 = 225/2 
45 × 5/3 = 75/1      [75]  r3=01 r5=02
75 × 5/2 = 375/2 
75 × 5/3 = 125/1     [125] r5=03
125 × 5/2 = 625/2 
125 × 5/3 = 625/3    [125] r5=03
</pre>

<p>Both of these programs are destructive, meaning that they drain the registers of their original values. We can make (<code>2/3</code>) less destructive with (<code>10/3</code>) by storing a copy of r3 in r5. And we can create a non-destructive adder but this requires coming in with the program with the flag r7 set: </p>

<pre>126(2<sup>1</sup> × 3<sup>2</sup> × 7<sup>1</sup>) <b>7/11 715/14 935/21 1/7 2/13 3/17</b> = 2250(2<sup>1</sup> × 3<sup>2</sup> × 5<sup>3</sup>)</pre>

<h3>NAND Gate</h3>

<p>Here's a simple <a href='https://en.wikipedia.org/wiki/NAND_gate'>NAND Gate</a> program from <a href='https://yetanotherlifeform.wordpress.com/2012/02/26/fractran/'>Yet Another Lifeform</a> that produces the correct truth table from: </p>

<pre>1/42 5/14 5/21 5/7</pre>

<table border='1'>
	<tr><th>7</th><th><code>1<sup>1</sup> × 7<sup>1</sup></code></th><td>1</td></tr>
	<tr><th>14</th><th><code>2<sup>1</sup> × 7<sup>1</sup></code></th><td>1</td></tr>
	<tr><th>21</th><th><code>3<sup>2</sup> × 7<sup>1</sup></code></th><td>1</td></tr>
	<tr><th>42</th><th><code>2<sup>1</sup> × 3<sup>2</sup> × 7<sup>1</sup></code></th><td>0</td></tr>
</table>

<style>
	.numreg { background:pink }
	.numval { background:#ffdee4 }
	.denreg { background:#72dec2 }
	.denval { background:#ffd18c }
</style><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/html/fractran_guide.htm' target='_blank'>edit</a> to <a href='../src/inc/html/fractran_guide.htm'>fractran_guide.htm</a>(131 lines)</figcaption>
</figure><h3>Interpreter</h3><p>A simple Fractran interpreter, written in <a href='ansi_c'>ANSI C</a>, showing the value in the registers as it steps through the program.</p><figure><pre>#include &lt;stdio.h&gt;

/* 
Copyright (c) 2020 Devine Lu Linvega

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE.
*/

typedef struct Fraction {
	unsigned int num, den;
} Fraction;

typedef struct Machine {
	int len;
	Fraction acc, program[256];
} Machine;

int
gcd(int a, int b)
{
	if(b == 0)
		return a;
	return gcd(b, a % b);
}

Fraction
Frac(unsigned int num, unsigned int den)
{
	Fraction f;
	unsigned int d = gcd(num, den);
	f.num = num / d;
	f.den = den / d;
	return f;
}

void
printstate(Machine *m)
{
	unsigned int fac = 2, num = m-&gt;acc.num;
	printf("[%d] ", num);
	while(num &gt; 1) {
		if(num % fac == 0) {
			unsigned int pow = 1;
			printf("r%02u=", fac);
			num /= fac;
			while(!(num % fac)) {
				num /= fac;
				pow++;
			}
			printf("%02u", pow);
			if(num != 1)
				putchar(' ');
		} else
			fac++;
	}
	putchar('\n');
}

void
run(Machine *m)
{
	int i = 0, steps = 0;
	while(i &lt; m-&gt;len &amp;&amp; m-&gt;acc.num) {
		Fraction res, *f = &amp;m-&gt;program[i++];
		res = Frac(m-&gt;acc.num * f-&gt;num, m-&gt;acc.den * f-&gt;den);
		printf("%u × %u/%u = %u/%u \n",
			m-&gt;acc.num,
			f-&gt;num,
			f-&gt;den,
			res.num,
			res.den);
		if(res.den == 1) {
			m-&gt;acc = res;
			printstate(m);
			i = 0;
		}
		steps++;
	}
	if(steps) {
		printstate(m);
		printf("Completed in %d steps.\n", steps);
	}
}

void
push(Machine *m, char *w)
{
	Fraction f;
	if(!m-&gt;acc.den) {
		if(sscanf(w, "%u", &amp;m-&gt;acc.num) &gt; 0)
			m-&gt;acc.den = 1;
		return;
	}
	if(sscanf(w, "%u/%u", &amp;f.num, &amp;f.den) &gt; 0)
		m-&gt;program[m-&gt;len++] = f;
}

Machine m;

int
main(void)
{
	int len = 0;
	char c, word[64];
	while((c = fgetc(stdin)) != EOF) {
		if(c == ' ' || c == '\n') {
			word[len] = '\0';
			len = 0;
			push(&amp;m, word);
		} else
			word[len++] = c;
		if(c == '\n')
			break;
	}
	printstate(&amp;m);
	run(&amp;m);
	return 0;
}
</pre><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/text/fractran.c.txt' target='_blank'>edit</a> to <a href='../src/inc/text/fractran.c.txt'>fractran.c.txt</a>(123 lines)</figcaption>
</figure><q>A common man marvels at uncommon things; a wise man marvels at the commonplace.</q><h5>—Confucius</h5><ul><li><a href='https://imgur.com/gallery/I7wFi' target='_blank'>Logic Gates</a></li></ul><p><i>incoming(2)</i>: <a href='firth.html'>firth</a> <a href='language.html'>language</a> </p></main><footer><a href='https://creativecommons.org/licenses/by-nc-sa/4.0'><img src='../media/icon/cc.svg' width='30'/></a><a href='http://webring.xxiivv.com/'><img src='../media/icon/rotonde.svg' width='30'/></a><a href='https://merveilles.town/@neauoire'><img src='../media/icon/merveilles.svg' width='30'/></a><a href='https://github.com/neauoire'><img src='../media/icon/github.png' alt='github' width='30'/></a><span><a href='devine_lu_linvega.html'>Devine Lu Linvega</a> © 2020 — <a href='about.html'>BY-NC-SA 4.0</a></span></footer></body></html>