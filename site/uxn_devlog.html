<!DOCTYPE html><html><head>
<link href="../links/main.css" type="text/css" rel="stylesheet">
<link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property='og:type' content='website'/>
<meta property='og:site_name' content='XXIIVV'/>
<meta property='og:description' content="By Devine Lu Linvega"/>
<meta property='og:logo' content="https://wiki.xxiivv.com/media/services/rss.jpg"/>
<meta property="og:title" content="uxn devlog"/><meta property="og:url" content="https://wiki.xxiivv.com/site/uxn_devlog.html"/><meta property="og:image" content="https://wiki.xxiivv.com/media/services/rss.jpg"/><title>XXIIVV &mdash; uxn devlog</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>
<nav><ul><li><a href="events.html">events</a></li><li><a href="blog.html">blog</a></li><li><a href="devlog.html" class="parent">devlog</a></li><li><a href="now.html">now</a></li></ul><ul><li><a href="uxn_devlog.html" class="self">uxn devlog</a></li><li><a href="uxntal_devlog.html">uxntal devlog</a></li><li><a href="varvara_devlog.html">varvara devlog</a></li><li><a href="now_lie_in_it.html">now lie in it</a></li></ul><ul></ul></nav>
<main><h2>A virtual machine</h2>

<p>Emulation is the reproduction of the behavior of a physical computer's
circuitry with software. Given that an emulator can translate the actions of
one computer onto an other, the same program can sometimes be used on both.
<br/>This is called <b>emulation</b>.</p>

<p>Someone could devise the actions of a fictional computer that is not
necessarily based on existing hardware, write software for this fantastical
computer, implement an emulator for it, and use the same program on
supported systems.
<br/>This is called a <b>virtual machine</b>.</p>

<img src='../media/refs/magiciens.png' alt='Le Matin des magiciens, by Louis Pauwels and Jacques Bergier. 1963' width='200'/>

<p><a href='stack.html'>Bitrot</a> is the inability to access digital data
because hardware and software no longer exist to read its format. Over the
years, I wrote software for a multitude of peripherals and frameworks, the vast
majority is now defunct due to either falling behind on the <a
href='obsolescence.html'>ever-changing toolchains</a> or simply the hardware
being discontinued. Perhaps it's just a matter of time until people build
emulators to make these projects usable again, otherwise these projects were
never truly mine, and my learning of these languages <i>only ever belonged to
the platforms</i>.</p>

<article>
	<p>So, why not <b>X86 assembly</b>? While some of our computers share an
architecture, cross-platform audio and graphical development is unlikely to
work between them.</p>
</article>

<h3>I. An Adequate Number Of Bits</h3>

<p>During my research into portability, I kept thinking about how frictionless
it is to play <a href='famicom.html'>classic console games</a> today.
Pulling on that thread led me to projects designed explicitly for virtual
machines, such as <a href='https://fabiensanglard.net/another_world_polygons/'
target='_blank'>Another World</a> which is equally easy to play today due to
its targeting of a portable virtual machine, instead of any ever-changing
physical hardware.</p>

<img src='../media/refs/mos6502.jpg' width="100" style='float:right'/>

<p>For a time, I thought I ought to be building software for the <a
href='famicom.html'>NES</a> to ensure their survival against the wave of
disposable <a href='http://collapseos.org/why.html' target='_blank'>modern
platforms</a> &mdash; So, <a href='6502.html'>I did</a>. Unfortunately,
most of the software that I care to write and use require slightly more than an
8-button controller.</p>

<article>
	<p>So, why not the <b>Commodore 64</b>? Having implemented a NES emulator I
found that, in comparison, implementing a c64 emulator is a monumental
project.</p>
</article>

<img src='../media/refs/hands.png' alt='Saul Steinberg, Untouched by Human Hands' width='350'/>

<h3>II. Tarpits & Houses Of Cards</h3>

<p>If the focus of this experiment is to ensure the support of a piece of code by
writing emulation software for each new platform, the specifications should be
painless to implement. Let's use the time one would need to write a passable
emulator as a limit in complexity for this system. Could a computer science
student implement an emulation of the <a href='6502.html'>6502 instructions</a>
in an afternoon? Could that design be simplified, changed in some way to make
it more approachable for would-be implementers?</p>

<img src='../media/refs/bthennota.png' width='100'/>

<ul>
	<li><a href='subleq.html'>Subleq</a> is a <i>One-Instruction</i> architecture
which takes at most <b>a day</b> for one person to implement. But what it does away in
emulation complexity, it offloads onto the toolchain needed to make
intelligible programs.</li>
	<li><a href='smalltalk.html'>Smalltalk</a> is a complete computing environment
and virtual machine, that was said to take about <b>a year</b> for one person to
implement.</li>
</ul>

<p>So, let us also set a limit to the complexity of the toolchain, since it would
be an equally Herculean task to build an <i>emulator and assembler</i> for a
machine with thousands of instructions; or a single instruction machine
building abstract logic from thousands of primitive parts.</p>

<p>The complexity of our virtual machine runtime and toolchain implementation
cannot exceed that which can be done within a weekend.</p>

<article>
	<p>So, why not the <b>Chifir</b>? Because of its very incomplete specification, unspecified behaviors, and lack of testing software, it is doubtful that general purpose computing is possible on such a system.</p>
</article>

<h3>III. Things Betwixt</h3>

<p>In 1977, a programmer wrote a small virtual machine with <a
href='chip8.html'>36 instructions</a>, 16 registers and 4096 bytes of memory.
It had no mouse device, its controller is 16 keys organized in a square, the
screen is barely capable of displaying readable text, but I was able to write
an implementation in <b>a weekend</b>.</p>

<p>In 1964, a computer scientist proposed an abstract machine with <a
href='secd.html'>10 instructions</a> and 4 stacks. The superficially documented
implementation specifies a list processing system capable or hosting functional
languages. The system was later expanded with arithmetic and IO operations, but
rests on an intricate and inefficient garbage collected system. I was able to write
an <a href='../etc.secd.c.txt'>implementation</a> in about <b>two weeks</b>.</p>

<img src="../media/refs/computers.png" width="300">

<p>In the early 1980s , when computer access was still not yet widespread, a <a
href='paper_register.html'>paper computer</a> was designed, consisting of a
piece of paper with 21 lines of <i>code</i> and eight registers. The
instruction set of five commands(inc, dec, jmp, isz, stp) is small but <a
href='https://en.wikipedia.org/wiki/Turing_completeness' target='_blank'>Turing
complete</a>, meaning that it can approximately simulate the computational
aspects of any other real-world general-purpose computer, and is therefore
enough to represent all mathematical functions.</p>

<article>
	<p>So, why not <b>Pico-8</b>? The Pico-8 comparison comes from people conflating
Uxn with <a href='varvara.html'>Varvara</a>. A better comparison would be Uxn
and the LuaVM, which runs Pico-8, but isn't intended to be targeted directly
and subject to change. On the other hand, Uxn is a VM focused on long-term
stability, implantability, and portability.</p>
</article>

<img src='../media/refs/ma.png' style='float:right; margin-left:30px; width:100px'/>

<p>Somewhere along this voyage into finding a suitable host for my programs, I
began thinking about <a href='collapse.html'>electronic waste</a>, and I
couldn't justify surrounding myself with <a href='salvage_computing.html'>yet
more electronics</a>. This dream platform would therefore be designed to be
emulated, its complexity would be designed around the complexity of software
and not that of hardware, so I do no consider FPGAs.</p>

<h3>IV. Back & Forth</h3>

<p>The balancing act of virtual machine instructions, assembler, emulator and the
resulting capabilities of its language eventually brought me back to stack machines.</p>

<img src="../media/refs/swap.png" alt="Swap operation by Leo Brodie">

<p><a href='concatenative.html'>Concatenative languages</a> consist of breaking a
program into a list of words, and to interpret each word, words are often
combinations of other words, combined to create more complex words. Brackets
and parentheses are unnecessary: the program merely performs calculations in
the order that is required, letting the automatic stack store intermediate
results on the fly for later use. Likewise, there is no requirement for
precedence rules.</p>

<table border="1">
	<tr><td><i>operation</i></td><th>3</th><th>10</th><th>5</th><th>+</th><th>*</th></tr>
	<tr><td rowspan="3"><i>stack</i></td><td rowspan="3">3</td><td>10</td><td>5</td><td>15</td><td rowspan="3">45</td></tr>
	<tr><td rowspan="2">3</td><td>10</td><td rowspan="2">3</td></tr>
	<tr><td>3</td></tr>
</table>

<p>In <a href='forth.html'>Forth</a>, memory is made of blocks of cells, which
are typically <a href='binary.html'>16-bits in length</a>, meaning that each
piece of data is a number from 0 to 65535. For this specific imaginary system,
I wanted the memory to consist of cells of 8-bit, or numbers from 0 to 255. For
example, the <code>12 / (34 - 12)</code> sequence is equivalent to the 6
bytes:</p>

<pre>
uxntal |  #  12  34 OVR SUB DIV
binary | a0  12  34  07  19  1b
</pre>

<p>Using stack-machine operations as primitives, along with enough arithmetic and
bitwise functions as to not require to abstract computation to a higher level
language, in order words to keep the assembly programming pleasant with
convenience opcodes such as multiplication and division, I reached an
expressive and extendable virtual machine that can be implemented in a weekend
exposing a programmable assembly dialect running at a reasonable speed.</p>

<pre>
<b>Stack I</b>             <b>Logic</b>              <b>Memory I</b>            <b>Arithmetic</b>
<a href="uxntal_reference.html#brk">BRK</a> --              <a href="uxntal_reference.html#equ">EQU</a> a b -- a=b     <a href="uxntal_reference.html#ldz">LDZ</a> abs8 -- [abs8]  <a href="uxntal_reference.html#add">ADD</a> a b -- a+b  
<a href="uxntal_reference.html#inc">INC</a> a -- a+1        <a href="uxntal_reference.html#neq">NEQ</a> a b -- a≠b     <a href="uxntal_reference.html#stz">STZ</a> val abs8 --     <a href="uxntal_reference.html#sub">SUB</a> a b -- a-b  
<a href="uxntal_reference.html#pop">POP</a> a --            <a href="uxntal_reference.html#gth">GTH</a> a b -- a&gt;b     <a href="uxntal_reference.html#ldr">LDR</a> rel8 -- [rel8]  <a href="uxntal_reference.html#mul">MUL</a> a b -- a×b  
<a href="uxntal_reference.html#nip">NIP</a> a b -- b        <a href="uxntal_reference.html#lth">LTH</a> a b -- a&lt;b     <a href="uxntal_reference.html#str">STR</a> val rel8 --     <a href="uxntal_reference.html#div">DIV</a> a b -- a÷b

<b>Stack II</b>            <b>Stash</b>              <b>Memory II</b>           <b>Bitwise</b>
<a href='uxntal_reference.html#swp'>SWP</a> a b -- b a      <a href='uxntal_reference.html#jmp'>JMP</a> addr --        <a href='uxntal_reference.html#lda'>LDA</a> abs* -- [abs*]  <a href='uxntal_reference.html#and'>AND</a> a b -- a&b
<a href='uxntal_reference.html#rot'>ROT</a> a b c -- b c a  <a href='uxntal_reference.html#jcn'>JCN</a> cond8 addr --  <a href='uxntal_reference.html#sta'>STA</a> val abs* --     <a href='uxntal_reference.html#ora'>ORA</a> a b -- a|b
<a href='uxntal_reference.html#dup'>DUP</a> a -- a a        <a href='uxntal_reference.html#jsr'>JSR</a> addr -- | pc*  <a href='uxntal_reference.html#dei'>DEI</a> dev -- [dev]    <a href='uxntal_reference.html#eor'>EOR</a> a b -- a^b
<a href='uxntal_reference.html#ovr'>OVR</a> a b -- a b a    <a href='uxntal_reference.html#sth'>STH</a> a -- | a       <a href='uxntal_reference.html#deo'>DEO</a> val dev --      <a href='uxntal_reference.html#sft'>SFT</a> a sft8 -- res

<a href='uxntal_reference.html#lit'>LIT</a> -- [pc*]        <a href='uxntal_reference.html#jci'>JCI</a> cond8 --       <a href='uxntal_reference.html#jmi'>JMI</a> -- </td>             <a href='uxntal_reference.html#jsi'>JSI</a> -- | pc*</td>
</pre>

<p>An implementation of the runtime, capable of running the self-hosted assembler
is about <a href="../etc/uxnmin.c.txt" target="_blank">150 lines of C</a>. Uxn
cannot error and has no <a
href='https://git.sr.ht/~rabbits/uxn-utils/tree/main/item/cli/opctest/opctest.tal'
target='_blank'>unspecified behaviors</a>. Its documentation encourages
re-implementation instead of adoption of a specific implementation. It operates
on bytes as to remain portable on small systems, abstracting I/O entirely to
the host system via dedicated opcodes. </p> 

<ul></ul><p class="incoming"><b>incoming</b> <a href="devlog.html" class="parent">devlog</a> <a href="2022.html">2022</a> </p></main>
<footer>
	<a href="uxn.html"><img src="../media/icon/uxn.png" alt="Uxn Powered"/></a> 
	<a href="ethics.html"><img src="../media/icon/3arrows.png" alt="NoNazis!"/></a>
	<span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &bull; 2008-2025</span>
	<div class="right"><a href="about.html#license">BY-NC-SA 4.0</a>
		<a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.png" alt="CreativeCommons"/></a>
		<a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/rotonde.png" alt="Webring"/></a>
		<a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.png" alt="Merveilles"/></a>
	</div>
	<hr/>
</footer>
</body></html>