<!DOCTYPE html><html><head>
<link href="../links/main.css" type="text/css" rel="stylesheet">
<link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property='og:type' content='website'/>
<meta property='og:site_name' content='XXIIVV'/>
<meta property='og:description' content="By Devine Lu Linvega"/>
<meta property='og:logo' content="https://wiki.xxiivv.com/media/services/rss.jpg"/>
<meta property="og:title" content="uxntal"/><meta property="og:url" content="https://wiki.xxiivv.com/site/uxntal.html"/><meta property="og:image" content="https://wiki.xxiivv.com/media/diary/804.jpg"/><title>XXIIVV &mdash; uxntal</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>
<nav><ul><li><a href="subleq.html">subleq</a></li><li><a href="brainfuck.html">brainfuck</a></li><li><a href="chip8.html">chip8</a></li><li><a href="uxn.html" class="parent">uxn</a></li><li><a href="secd.html">secd</a></li></ul><ul><li><a href="uxntal.html" class="self">uxntal</a></li><li><a href="varvara.html">varvara</a></li><li><a href="porporo.html">porporo</a></li></ul><ul><li><a href="uxntal_syntax.html">uxntal syntax</a></li><li><a href="uxntal_stacks.html">uxntal stacks</a></li><li><a href="uxntal_opcodes.html">uxntal opcodes</a></li><li><a href="uxntal_notation.html">uxntal notation</a></li><li><a href="uxntal_numbers.html">uxntal numbers</a></li><li><a href="uxntal_labels.html">uxntal labels</a></li><li><a href="uxntal_macros.html">uxntal macros</a></li><li><a href="uxntal_memory.html">uxntal memory</a></li><li><a href="uxntal_devices.html">uxntal devices</a></li><li><a href="uxntal_software.html">uxntal software</a></li></ul></nav>
<main><figure><img alt="Rostiger's Uxn Zine" src="../media/diary/804.jpg"><figcaption>Rostiger's Uxn Zine<span class="right">16X08</span></figcaption></figure>
<h2>A programming language for the Uxn virtual machine.</h2>

<img src="../media/generic/uxn.beet.png" style="float:right; margin-left: 15px;" width="200">

<p><a href='uxn.html'>Uxn</a> programs are written in a stack-based
flavor of assembly designed especially for this virtual machine. Tal files are
textual source files, Rom files are binary program files; applications that
transform Tal files into Rom files are called <i>Assemblers</i>.</p>

<ul>
	<li><a href='varvara_zine.html' target='_blank'>Uxn Zine</a>, by Clemens Scott.</li>
	<li><a href='../media/generic/uxntal-cheatsheet-normal.svg' target='_blank'>Uxntal Cheatsheet</a>, by Weeble.</li>
	<li><a href='https://compudanzas.net/uxn_tutorial.html' target='_blank'>Introduction Tutorial</a>, by Compudanzas</li>
</ul>

<h3 id='setup'>Setup</h3>

<p>Here is a quick way to get started writing programs with a little self-hosted
assembler and an emulator which includes the <a
href='varvara.html#console'>Console device</a>:</p>

<pre>
<i># Build emulator</i>
<b>cc</b> <a href='../etc/uxnmin.c.txt'>uxnmin.c</a> -o uxnmin

<i># Build assembler</i>
<b>xxd </b>-r -p <a href='../etc/drifloon.rom.txt'>drifloon.rom</a> uxnasm.rom

<i># Assemble source</i>
<b>echo</b> "#1234 #010e DEO" | <b>uxnmin</b> uxnasm.rom > result.rom

<i># Run program</i>
<b>uxnmin</b> result.rom
</pre>

<h2>Uxntal Syntax</h2>

<p>In <a href='concatenative.html'>concatenative programming</a>, there are no
precedence rules, the calculations are merely performed in the sequence in
which they are presented. The order with which elements come off a stack is
known as <b>last in, first out</b>. In the stack <i>a b c</i>, the <i>c</i>
item was the last to be added, and will be the first to be removed.</p>

<pre>
#01 DUP ADD #03 MUL <i style='float:right'>program</i>
</pre>
<pre style='margin-top:-29px'>
 01  01  02  03  06 <i style='float:right'>stack</i>
     01      02
</pre>

<h3>Hello World!</h3>

<p>The <kbd>;text</kbd> token pushes a pointer made of two bytes holding the <a
href='uxntal_labels.html#addressing'>absolute address</a> in memory of the
<kbd>@text</kbd> label to the stack. Next, we define a <a
href='uxntal_labels.html'>label</a> named <kbd>@while</kbd>, to mark the start
of a loop that will be printing each character stored at the text pointer.</p>

<iframe src="../etc/uxnrepl/index.html" frameborder="0" class='frame'></iframe>

<style>
.example span.label { font-weight: bold;background: #fff;color: #000;padding: 2px 4px; }
.example span.comment { color:#777 }
.frame { overflow: hidden; height: 450px; margin-bottom: 15px; border-radius:5px }
</style>

<p>The <kbd><a href='uxntal_opcodes.html#lda'>LDAk</a></kbd> opcode loads a byte
from the address on top of the stack, in this case, the <a
href='ascii.html'>ascii</a> letter <i>H</i>(48). The <a
href='uxntal_opcodes.html#modes'>k-mode</a> indicates that the operator will
not consume the address.</p><p>The <kbd><a
href='uxntal_opcodes.html#dup'>DUP</a></kbd> opcode copies the letter to the
top of the stack. The <kbd>?{</kbd> pops that byte from the stack, and if the
byte is <b>non-zero</b>, we jump to the corresponding <kbd>}</kbd>, which is an
<a href='uxntal_labels.html#anonymous'>anonymous label</a> .</p>

<pre>
|0100   a0 01 11   ( ;text )

@while
|0103   94         ( LDAk )
|0104   06         ( DUP )
|0105   20 00 02   ( ?λ00 )
|0108   22         ( POP2 )
|0109   00         ( BRK )
</pre>

<p>The <kbd>#18</kbd> token pushes a number to the stack, which maps to the <a
href='varvara.html#console'>device port #18</a>, followed by the <kbd><a
href='uxntal_opcodes.html#deo'>DEO</a></kbd> opcodes which pops both bytes and
sends the letter to the device port, printing that letter to the terminal,
leaving the address on top of the stack.</p>

<pre>
@λ00
|010a   80 18      ( #18 )
|010c   17         ( DEO )
|010d   21         ( INC2 )
|010e   40 ff f2   ( !while )
</pre>

<p>The <a href='uxntal_opcodes.html#inc'><kbd>INC2</kbd></a> opcode increments
the address, moving the pointer to the next letter. The <a
href='uxntal_opcodes.html#modes'>2-mode</a> is used because the address is made
of two bytes. Finally, we jump back to the start of the loop with
<kbd>!while</kbd>, and repeat the loop until the letter is zero, and use <a
href='uxntal_opcodes.html#pop'><kbd>POP2</kbd></a> to remove the address on the
stack and keep the stack clean at the end of the program.</p>

<pre>
@text
|0111   48 65 6c   H e l
|0114   6c 6f 20   l o  
|0116   57 6f 72   W o r
|011a   6c 64 21   l d !</pre>

<img src="../media/generic/uxn.team.png" style="margin:0 auto 30px" width="300">

<p>To summarize, <a href='uxntal_notation.html'>comments</a> are within
parentheses, <a href='uxntal_numbers.html'>numbers</a> are lowercase hexdecimal
shorts or bytes, <a href='uxntal_opcodes.html'>opcodes</a> are uppercased
reserved words, and <a href='uxntal_labels.html#anonymous'>anonymous labels</a>
are within curlies. Runes are special characters at the start of a word that
define its meaning, here is the full list:</p>

<table border="1" id='runes'>
	<tr><th colspan="4">Padding Runes</th><th colspan="4">Number Rune</th></tr>
	<tr>
		<td><code>|</code></td><td><a href='uxntal_memory.html#absolute'>absolute</a></td>
		<td><code>$</code></td><td><a href='uxntal_memory.html#relative'>relative</a></td>
		<td><code>#</code></td><td colspan="3"><a href='uxntal_numbers.html'>literal number</a></td>
	</tr>
	<tr><th colspan="4">Label Runes</th><th colspan="4">Ascii Runes</th></tr>
	<tr>
		<td><code>@</code></td><td><a href='uxntal_labels.html#parent'>parent</a></td>
		<td><code>&</code></td><td><a href='uxntal_labels.html#child'>child</a></td>
		<td><code>&quot;</code></td><td colspan="3">raw ascii</td>
	</tr>
	<tr><th colspan="4">Addressing Runes</th><th colspan="4">Wrapping Runes</th></tr>
	<tr>
		<td><code>,</code></td><td><a href='uxntal_labels.html#litrel'>literal relative</a></td>
		<td><code>_</code></td><td><a href='uxntal_labels.html#rawrel'>raw relative</a></td>
		<td><code>( )</code></td><td colspan='3'><a href='uxntal_notation.html#comments'>comment</a></td>
	<tr>
		<td><code>.</code></td><td><a href='uxntal_labels.html#litzep'>literal zero-page</a></td>
		<td><code>-</code></td><td><a href='uxntal_labels.html#rawzep'>raw zero-page</a></td>
		<td><code>{ }</code></td><td colspan='3'><a href='uxntal_labels.html#anonymous'>anonymous</a></td>
	</tr>
	<tr>
		<td><code>;</code></td><td><a href='uxntal_labels.html#litabs'>literal absolute</a></td>
		<td><code>=</code></td><td><a href='uxntal_labels.html#rawabs'>raw absolute</a></td>
		<td><code>[ ]</code></td><td colspan='3'><a href='uxntal_notation.html#brackets'>ignored</a></td>
	</tr>
	<tr><th colspan="4">Immediate Runes</th><th colspan="4">Pre-processor Runes</th></tr>
	<tr>
		<td><code>!</code></td><td><a href='uxntal_opcodes.html#jmi'>jmi</a></td>
		<td><code>?</code></td><td><a href='uxntal_opcodes.html#jci'>jci</a></td>
		<td><code>%</code></td><td><a href='uxntal_macros.html'>macro</a></td>
		<td><code>~</code></td><td>include</td></tr>
	</tr>
</table>
<h2>Uxntal Stacks</h2>

<p>All programming in Uxntal is done by manipulating the <i>working stack</i>,
and <i>return stack</i>, each stack contains 256 bytes. Here are some stack
primitives assuming the initial state of the stack is <code>a b c</code> where
<code>c</code> is the top of the stack: </p>

<table border='1'>
	<tr><th>POP</th><td>a b</td><td>Discard top item.</td></tr>
	<tr><th>NIP</th><td>a c</td><td>Discard second item.</td></tr>
	<tr><th>SWP</th><td>a c b</td><td>Move second item to top.</td></tr>
	<tr><th>ROT</th><td>b c a</td><td>Move third item to top.</td></tr>
	<tr><th>DUP</th><td>a b c c</td><td>Copy top item.</td></tr>
	<tr><th>OVR</th><td>a b c b</td><td>Copy second item to top.</td></tr>
</table>

<p>A byte is a number between 0-255(256 values), a short is a number between
0-65535(65536 values) made of two bytes, each byte in a short can be
manipulated individually:</p>

<pre>
#0a #0b POP <span style='float:right'>0a</span>
#12 #3456 NIP <span style='float:right'>12 56</span>
#1234 DUP <span style='float:right'>12 34 34</span>
</pre>

<p>The two stacks are <i>circular</i>, to pop an empty stack does not trigger an
error, but merely means to set the stack pointer to 255. There are no invalid
programs, any sequence of bytes is a potential Uxn program. Values are moved
between stacks with the <a href='uxntal_reference.html#sth'><kbd>STH</kbd></a>
opcode.</p>

<pre>
WST 00 00 00 00 00 00|12 34 <02
RST 00 00 00 00 00 00 00|56 <01
</pre>

<p>The program above contains 12 and 34 on the working stack, and 56 on the
return stack. The stack content can always be printed by sending a non-null
byte to the <a href='varvara.html#system'>System/debug</a> port.</p>


<h2>Uxntal Opcodes</h2>

<p>Uxn supports 4 <a href='#immediate'>immediate opcodes</a>, and 32 standard
opcodes. The list below show the opcodes and their effect on a given stack
<code>a b c</code>, where <code>c</code> is the top of the stack.</p>

<ul>
	<li><b>PC</b>: Program Counter.</li>
	<li><b>[M]</b>: Value at address <code>M</code> in Memory.</li>
	<li><b>&lt;D&gt;</b>: Value at address <code>D</code> in Device.</li>
	<li><b>a8</b>: a byte, <b>a16</b>: a short.</li>
	<li><b>|</b>: Return Stack.</li>
</ul>

<pre>
<b>LIT</b> a b c [PC]
<b>JCI</b> a b , (c8)PC+=[PC]
<b>JMI</b> a b c , PC+=[PC]
<b>JSI</b> a b c | PC , PC+=[PC]

<b>BRK</b> .        <b>EQU</b> a b==c            <b>LDZ</b> a b [c8]     <b>ADD</b> a b+c
<b>INC</b> a b c+1  <b>NEQ</b> a b!=c            <b>STZ</b> a [c8]=b     <b>SUB</b> a b-c
<b>POP</b> a b      <b>GTH</b> a b&gt;c             <b>LDR</b> a b [PC+c8]  <b>MUL</b> a b*c
<b>NIP</b> a c      <b>LTH</b> a b&lt;c             <b>STR</b> a [PC+c8]=b  <b>DIV</b> a b/c
<b>SWP</b> a c b    <b>JMP</b> a b , PC+=c       <b>LDA</b> a b [c16]    <b>AND</b> a b&c
<b>ROT</b> b c a    <b>JCN</b> a , (b8)PC+=c     <b>STA</b> a [c16]=b    <b>ORA</b> a b|c
<b>DUP</b> a b c c  <b>JSR</b> a b | PC , PC+=c  <b>DEI</b> a b &lt;c8&gt;     <b>EOR</b> a b^c
<b>OVR</b> a b c b  <b>STH</b> a b | c           <b>DEO</b> a &lt;c8&gt;=b     <b>SFT</b> a b&gt;&gt;c8l&lt;&lt;c8h
</pre>

<h3 id='modes'>Modes</h3>

<p>Each opcode has 3 possible modes, which can combined:</p>

<ul>
	<li>The <b>short mode</b> <kbd>2</kbd> operates on shorts, instead of bytes.</li>
	<li>The <b>keep mode</b> <kbd>k</kbd> operates without consuming items.</li>
	<li>The <b>return mode</b> <kbd>r</kbd> operates on the return stack.</li>
</ul>

<table border='1' style='float:right'>
	<tr><th colspan='8'>INC2r</th></tr>
	<tr><th>k</th><th>r</th><th>2</th><th colspan='5'>opcode</th></tr>
	<tr><td>0</td><td class='highlight'>1</td><td class='highlight'>1</td>
	<td>0</td><td>0</td><td>0</td><td>0</td><td class='highlight'>1</td></tr>
</table>

<p>By default, operators consume bytes from the working stack, notice how in the
following example only the last two bytes <code>#45</code> and <code>#67</code>
are added, even if there are two shorts on the stack.</p>
<pre>#1234 #4567 ADD<span style='float:right'>12 34 ac</span></pre>

<p id='2_mode'>The <b>short mode</b> consumes two bytes from the stack. In the
case of jump opcodes, the short-mode operation jumps to an absolute address in
memory. For the memory accessing opcodes, the short mode operation indicates
the size of the data to read and write.</p>
<pre>#1234 #4567 ADD2 <span style='float:right'>57 9b</span></pre>

<p id='k_mode'>The <b>keep mode</b> does not consume items from the stack, and
pushes the result on top. Every opcode begins by popping values from the stack
before operating on them. This mode keeps a copy of the stack pointer to
recover after the popping stage.</p>

<pre>#1234 #4567 ADD2k <span style='float:right'>12 34 45 67 57 9b</pre>

<p id='r_mode'>The <b>return mode</b> swaps the stacks on which an opcode
operates. Under this mode, a return address will be pushed to the working
stack, and stashing will take from the return stack. For that reason, there is
no <i>return</i> opcode. For example, the <code>JSR</code> opcode pushes the
return address onto the return stack, and <code>JMP2r</code> jumps to that
address.</p>

<pre>LITr 12 #34 STH ADDr STHr <span style='float:right'>46</span></pre>

<img src="../media/generic/uxn.crew.png" width="400"/>

<style>
	.highlight { background:#eee }
	@media (prefers-color-scheme:dark) {
		.highlight { background:#222 }
	}
</style>

<h3 id='immediate'>Immediate opcodes</h3>

<p>Immediate opcodes are operators that do not take items from the stack, but
read values stored <i>immediately</i> after the opcode in the program's memory.
Uxntal has 4 immediate opcodes: </p>

<ul>
	<li>The <b>literal</b> <kbd><a href='uxntal_reference.html#lit'>LIT</a></kbd>.</li>
	<li id='jmi'>The <b>jump</b> <kbd><a href='uxntal_reference.html#jmi'>!routine</a></kbd>, immediate of <kbd>JMP</kbd>.</li>
	<li id='jci'>The <b>conditional</b> <kbd><a href='uxntal_reference.html#jci'>?routine</a></kbd>, immediate of <kbd>JCN</kbd>.</li>
	<li>The <b>subroutine</b> <kbd><a href='uxntal_reference.html#jsi'>routine</a></kbd>, immediate of <kbd>JSR</kbd>.</li>
</ul>

<p>The immediate jump opcodes are slightly faster than their standard opcode
counterparts, but do not have modes and cannot be used to do pointer
arithmetic. The address value of the immediate opcodes are stored in memory as
relative shorts, enabling routines making use of these opcodes to be moved
around in the program's memory.</p>

<pre>
|100 @on-reset ( -> )
	#0007 fact
	BRK

@fact <i>( n* -- res* )</i>
	ORAk ?{ POP2 #0001 JMP2r }
	DUP2 #0001 SUB2 fact MUL2
	JMP2r</pre>

<p>To learn more about each opcode, see the <a
href='uxntal_reference.html'>Opcode Reference</a>.</p>
<h2>Uxntal Notation</h2>

<p>The Uxntal notation follows that of the <a href='forth.html'>Forth</a>
programming language, where each item on the left of the <kbd>--</kbd> spacer
is the state of the stack before, and to the right, the state of the stack
after:</p>

<pre>
@routine ( a b -- a b c )
	ADDk JMP2r
</pre>

<p>By default, single items are a byte long, and shorts are indicated with a
<kbd>*</kbd> suffix, the order in which they appear is the order of the stack
with the top item to the right:</p>

<pre>
@routine ( a b* -- b* a )
	ROT JMP2r
</pre>

<p>If a routine is a <a href='uxntal_devices.html'>vector</a>, it uses the arrow
notation.</p>

<pre>
@on-event ( -> )
	BRK
</pre>

<p>If a specific item on the stack is a pointer, or a -1 value for failure, the item is within angular brackets.</p>

<pre>
@routine ( name* -- &lt;res&gt;* )
	lut/find-name ORAk ?{ POP2 #ffff } JMP2r
</pre>

<h3 id='brackets'>Brackets</h3>

<p>The square brackets do nothing, they are there merely for readability and <a
href='uxnfor.html'>formatting</a>, they are useful for making explicit certain
things.</p>

<pre>
@routine ( -- )
	[ LIT2 20 -Console/write ] DEO JMP2r

%min ( a b -- r ) {
	GTHk [ JMP SWP ] POP }

@sprite [ 00 66 ff ff ff 7e 3c 18 ]
</pre>

<h2>Uxntal Numbers</h2>

<p>Uxntal uses only lowercase unsigned <a href='hexadecimal.html'>hexadecimal
numbers</a> of either 2 or 4 characters in length. There are two types of
numbers:</p>

<ul>
	<li>A <b>Literal Hex</b>, like <kbd>#ab</kbd>, denotes a number that will be
pushed on the stack when evaluated, it is made of a <a
href='uxntal_reference.html#lit'>LIT</a> opcode that matches its length,
followed by a Raw Hex number.</li>
	<li>A <b>Raw Hex</b>, like <kbd>aa</kbd>, is the standard textual
encoding of data in a program, generally speaking these are more often loaded
than evaluated. It can be anything, an opcode, an ascii byte, an address, part
of a sprite.</li>
</ul>

<pre>
#12 #34 LIT2 5678 ADD2 <span style="float:right">68 ac</span>
</pre>

<h2>Uxntal Labels</h2>

<p>A label is a non-numeric, non-opcode, and non-runic symbol that correspond to
a number between 0 and 65536. A label name is made of two parts, a scope and a
sublabel. Sublabels can be added to a scope with the <kbd>&name</kbd> rune, or
by writing the full name, like <kbd>@scope/name</kbd>. Note that a labels like
<i>bed</i>, <i>add</i> and <i>cafe</i> are considered numeric.</p>

<p><b>Routines</b> are labels that will be jumped to, a <kbd>@routine</kbd> has
its own scope, making it possible for multiple routines to have their own
instance of the label <kbd>&loop</kbd>.</p>

<pre>
@routine ( a b -- c )
	&loop
		INC GTHk ?&loop
	ADD JMP2r
</pre>

<p><b>Constants</b> are labels that hold a specific value through the entire
execution of the program. They allow to create label that can be used in place
of a number, making the code more readable.</p>

<pre>
|1400 @limit

@within-limit ( value* -- f )
	;limit LTH2
	JMP2r
</pre>

<p><b>Enums</b> are labels with unique values that can be used as constants in a
program, they begin by rolling back the program address with
<kbd>|00</kbd>:</p>

<pre>
|00 @Suit &clubs $1 &diamonds $1 &hearts $1 &spades

@is-diamond ( suit -- f )
	.Suit/clubs EQU
	JMP2r
</pre>

<p id='structs'><b>Structs</b> define padded labels, for example the
<code>;person/age</code> label holds a value of 2, using that offset allows to
access specific members of a data structure by applying the sublabels to a
pointer:</p>

<pre>
|00 @Person &name $2 &age $1 &height $2
@members
	=dict/melanye 2a 008c
	=dict/alexane 2c 009a

@get-height ( member* -- height* )
	;Person/height ADD2 LDA2
	JMP2r
</pre>

<p>Labels can also be used with the padding runes to define a
global length. For example, if one needs to specify a length of 0x30 for
multiple members of a struct, a value can be specified as follow:</p>

<pre>
|30 @length
|00 @struct &field $length
</pre>

<h3 id='scope'>Scope</h3>

<p>Uxntal objects are defined statically using a <kbd>@label</kbd> token, it
allows for the enclosed methods to access local <kbd>&labels</kbd>. The example
below creates an object with the method <kbd>get-x</kbd>, accessible from
outside the scope as <kbd>Object/get-x</kbd>. By capitalizing the object name,
we communicate to the assembler that the label will not be called and should
not raise a warning.</p>

<pre>
@Object &x $1 &y $1

&get-x <i>( -- x )</i>
	,&x LDR JMP2r
</pre>

<p>New methods and members can be appended to an existing scope by creating a
label with the scope name followed by a slash and the name of the extension.
The <kbd>&labels</kbd> declared within the extension have the same access to
local labels as the rest of the object.</p>

<pre>
@Object/get-y <i>( -- y )</i>
	,&y LDR JMP2r
</pre>

<p id='method'>When calling local methods the scope's name can be omitted,
starting at the slash, like <kbd>/method</kbd>:</p>

<pre>
&get-both <i>( -- x y )</i>
	/get-x /get-y JMP2r
</pre>

<h3 id='addressing'>Addressing</h3>

<p>A labels is a way of assigning a name to a number. There are six ways to get
the number corresponding to that label. Literal addressing prefixes the label
with a <code>LIT</code> for Relative and Zero-Page addressing, and
<code>LIT2</code> for absolute addressing.</p>

<ul>
	<li id='litrel'><b>Literal Relative</b>, like <kbd>,label</kbd>, pushes a
relative distance byte to the label.</li>
	<li id='litzep'><b>Literal Zero-Page</b>, like <kbd>.label</kbd>, pushes an
absolute address byte to the label.</li>
	<li id='litabs'><b>Literal Absolute</b>, like <kbd>;label</kbd>, pushes an
absolute address short to the label.</li>
	<li id='rawrel'><b>Raw Relative</b>, like <kbd>_label</kbd>, writes a
relative distance byte to the label.</li>
	<li id='rawzep'><b>Raw Zero-Page</b>, like <kbd>-label</kbd>, writes an
absolute address byte to the label.</li>
	<li id='rawabs'><b>Raw Absolute</b>, like <kbd>=label</kbd>, writes an
absolute address short to the label.</li>
</ul>

<p>Raw addressing is used for building data-structures and more advanced
programs. A relatively common usage of raw runes is to create literals directly
into the return stack:</p>

<pre>
[ LITr ab ] STHr INC <span style='float:right'>ac</span>
</pre>

<h3 id='anonymous'>Anonymous Labels</h3>

<p>Anonymous labels are designated with a curly bracket that points to its
associated closing bracket, and can be nested. Under the hood, the opening
bracket assembles to the address of the closing bracket which allows the
destination address to be used like any other label such as a JCI
<kbd>?{</kbd>, a JMI, <kbd>!{</kbd> or a plain literal <kbd>;{</kbd>. Here are
some example data-structures:</p>

<pre>
@counted-string
	_{ "foo 20 "bar }

@linked-list
	={ ={ "A } ={ "B ={ "C } } }
</pre>

<h4 id='unless'>Unless Blocks</h4>

<p>It is important to notice that in the case of a conditional jump, the
lambda's content is <b>jumped over when the flag byte is true</b>.</p>

<pre>
[ LIT2 &last $1 -Mouse/state ] DEI DUP ,&last STR
DUP2 #0001 NEQ2 ?{ ( on down ) }
DUP2 #0101 NEQ2 ?{ ( on drag ) }
DUP2 #0100 NEQ2 ?{ ( on release ) }
POP2
</pre>

<p>The opening curly bracket assembles to a unique label reference, and the
closing bracket to a corresponding matching label definition. They do not
affect the scope.</p>

<h2>Uxntal Macros</h2>

<p>A macro is a way of defining inline routines, it allows to create new words
that will be replaced by the body of the macro, as opposed to a jump where the
program counter will move to a routine and back, therefore it needs to be
defined before its usage, as follow: </p>

<pre>
%modulo ( num denum -- res ) {
	DIVk MUL SUB }

@routine ( -- c* )
	#18 #03 modulo JMP2r
</pre>

<p>In the previous example, the token <kbd>modulo</kbd> will get replaced by the
body of the macro during assembly:</p>

<pre>
@routine ( -- c* )
	#18 #03 DIVk MUL SUB JMP2r
</pre>

<h2>Uxntal Memory</h2>

<p>There are 64kb of <b>addressable memory</b>. Roms are loaded at 0x0100, which
is the address of the <a href='uxntal_devices.html'>reset vector</a>. During
boot, the stacks, device and addressable memories are zeroed. During a
soft-reboot, the content of the zero-page is preserved.</p>

<ul>
	<li>An <b id='absolute'>Absolute Padding</b>, like <kbd>|100</kbd> moves
the program generation to an address specified by a number or label.</li>
	<li>A <b id='relative'>Relative Padding</b>, like <kbd>$18</kbd> moves
the program generation by a distance specified by a number or label.</li>
</ul>

<pre>
|18 @width
|100 @on-reset ( -> )
	;buffer/end BRK <span style='float:right'>02 18</span>
|200 @buffer $width &end
</pre>

<p>The <b>device page</b> and stacks are located outside of addressable
memory.</p>

<table border='1'>
	<tr><th><i>Shared</i></th><th>Memory</th><td>RAM</td><td>Data</td><td>64kb pages</td></tr>
	<tr><th rowspan='5'><i>Private</i></th><th rowspan='4'>Stacks</th><td rowspan='2'>Working Stack</td><td>Data</td><td>256 bytes</td></tr>
	<tr><td>Pointer</td><td>1 byte</td></tr>
	<tr><td rowspan='2'>Return Stack</td><td>Data</td><td>256 bytes</td></tr>
	<tr><td>Pointer</td><td>1 byte</td></tr>
	<tr><th>IO</th><td>Devices</td><td>Data</td><td>256 bytes</td></tr>
</table>

<p>Memory is <b>big-endian</b>, when writing or reading a short from memory, the
position is that of the high-byte. The low-byte of a short written at 0xffff
wraps to 0x0000.</p>

<pre>
#12 #0200 STA <span style='float:right'>0x0200=12</span>
#3456 #0400 STA2 <span style='float:right'>0x0400=34, 0x0401=56</span>
#0400 LDA <span style='float:right'>34</span>
</pre>

<p>The <b>zero-page</b> is the memory located below 0x0100, its
purpose is to store variables that will be accessed often, or needs to be
preserved across a soft-reboot. It is sligthly faster to read and write from
the zero-page using the LDZ and STZ opcodes as they use only a single byte
instead of a short. This memory space cannot be pre-filled in the rom prior to
initialization. The low-byte of a short written at 0xff wraps to 0x00.</p>

<pre>
#1234 #80 STZ2 <span style='float:right'>0x0080=12, 0x0081=34</span>
#81 LDZ <span style='float:right'>34</span>
</pre>


<h2>Uxntal Devices</h2>

<p>Uxn is non-interruptible, <b>vectors</b> are locations in programs that are
evaluated when certain events occur. A vector is evaluated until a BRK opcode
is encountered. Uxn can communicate with a maximum of 16 devices, each device
has 16 <b>ports</b>, each port handles a specific I/O message. Ports are mapped to the
devices memory page, which is located outside of the main addressable
memory.</p>

<img src="../media/generic/uxn.devices.png" width="350" />


<p>All programs begin by executing the <b>reset vector</b> located at
<code>0x100</code>. The content of the stacks are preserved between vectors,
but it is discouraged to use the stacks to pass <a
href='uxntal_doors.html'>data between vectors</a>.</p>

<pre>
@on-reset <i>( -> )</i>
	<i>( set vector )</i>
	;on-mouse .Mouse/vector DEO2
	BRK

@on-mouse <i>( -> )</i>
	<i>( read state )</i>
	.Mouse/state DEI ?&on-touch
	BRK

&on-touch <i>( -> )</i>
	<i>( A mouse button is pressed )</i>
	BRK
</pre>

<p>For example, the address stored in the <a
href='varvara.html#mouse'>Mouse/vector</a> ports points to a part of the
program to be evaluated when the cursor is moved, or a button state has
changed. </p>

<img src="../media/generic/varvara.uxn.png"/>

<style>
pre i { color: #777 }
</style><h2>Uxntal Utilities</h2>

<p>Here's a list of small self-hosted development tools:</p>

<ul>
	<li><a href='uxnfor.html'>Uxnfor</a> is a
formatter that standardize the source code, this is the formatting style used
across the Uxntal documentation.</li>
	<li><a href='uxnlin.html'>Uxnlin</a> is a
peephole optimizer that reveals potential optimizations in opcode sequences.</li>
	<li><a href='https://git.sr.ht/~rabbits/uxnbal' target='_blank'>Uxnbal</a> is a
program validator that warns when routines do not match their definitions.</li>
	<li><a href='https://git.sr.ht/~rabbits/uxndis' target='_blank'>Uxndis</a> is a disassembler that prints the opcodes in a rom file.</li>
</ul>
<ul></ul><p class="incoming"><b>incoming</b> <a href="left.html">left</a> <a href="noodle.html">noodle</a> <a href="drifblim.html">drifblim</a> <a href="catclock.html">catclock</a> <a href="theme.html">theme</a> <a href="bifurcan.html">bifurcan</a> <a href="yufo.html">yufo</a> <a href="programming_languages.html">programming languages</a> <a href="gly_format.html">gly format</a> <a href="ufx_format.html">ufx format</a> <a href="ulz_format.html">ulz format</a> <a href="proquints.html">proquints</a> <a href="brainfuck.html">brainfuck</a> <a href="uxn.html" class="parent">uxn</a> <a href="uxntal_reference.html">uxntal reference</a> <a href="uxntal_alphabet.html">uxntal alphabet</a> <a href="uxntal_types.html">uxntal types</a> <a href="bicycle.html">bicycle</a> <a href="beetbug.html">beetbug</a> <a href="arvelie.html">arvelie</a> <a href="about.html">about</a> <a href="oscean.html">oscean</a> <a href="computer.html">computer</a> </p></main>
<footer>
	<a href="ethics.html"><img src="../media/icon/3arrows.svg" alt="NoNazis!"/></a>
	<a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a>
	<a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a>
	<a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a> 
	<span><a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2008-2025</span>
	<div class="right"><a href="about.html#license">BY-NC-SA 4.0</a>
		<a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a>
	</div>
	<hr/>
</footer>
</body></html>