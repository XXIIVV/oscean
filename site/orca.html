<!DOCTYPE html><html lang='en'><head><meta charset='utf-8'><meta name='description' content='Orca is a livecoding playground.'/><meta name='thumbnail' content='https://wiki.xxiivv.com/media/services/thumbnail.jpg' /><meta name='viewport' content='width=device-width,initial-scale=1'><link rel='alternate' type='application/rss+xml' title='RSS Feed' href='../links/rss.xml' /><link rel='stylesheet' type='text/css' href='../links/main.css'><link rel='shortcut icon' type='image/png' href='../media/services/icon.png'><title>XXIIVV &mdash; orca</title></head><body><header><a href='home.html'><img src='../media/icon/logo.svg' alt='XXIIVV' height='29'></a></header><nav><ul><li><a href='paper_computing.html'>paper computing</a></li><li><a href='programming.html'>programming</a></li><li><a href='virtual_machines.html'>virtual machines/</a></li><li><a href='fluidics.html'>fluidics</a></li></ul><ul><li><a href='orca.html'>orca/</a></li><li><a href='gyo.html'>gyo</a></li><li><a href='noton.html'>noton</a></li><li><a href='paradise.html'>paradise</a></li></ul><ul><li><a href='pilot.html'>pilot</a></li><li><a href='enfer.html'>enfer</a></li></ul></nav><main><figure><img src='../media/diary/582.jpg' alt='Orca x Dotgrid picture' width='900'/><figcaption>13A12 &mdash; Orca x Dotgrid</figcaption></figure><h2>Orca is a livecoding playground.</h2><p>Orca is a two-dimensional <a href='https://esolangs.org/wiki/Esoteric_programming_language' target='_blank'>esoteric programming language</a> in which <b>every letter of the alphabet is an operator</b>, where lowercase letters operate on bang, uppercase letters operate each frame. This livecoding language is designed to procedurally generate <a href='https://github.com/hundredrabbits/orca#midi' target='_blank'>MIDI, UDP or OSC</a> messages.</p><p>If you wish to learn more about Orca, watch a <a href='https://www.youtube.com/watch?v=ktcWOLeWP-g' target='_blank'>tutorial</a>, visit the <a href='https://talk.lurk.org/channel/orca' target='_blank'>chatroom</a> or ask your questions in the <a href='https://llllllll.co/t/orca-live-coding-tool/17689' target='_blank'>forum</a>.</p><iframe width='624' height='380' src='https://www.youtube.com/embed/DCKUunRjhJo?rel=0' style='max-width:700px' frameborder='0' allow='autoplay; encrypted-media' allowfullscreen></iframe><q>Orca is a wildly unique visual programming tool. It's also an inky black and seafoam green alphabet soup, pulsating to some species of broody electronic industrial throb.</q><h5>â€”Ivan Reese, <a href='https://futureofcoding.org/episodes/045' target='_blank'>The Future Of Coding</a></h5><figure><h1>Operators</h1>

<ul>
  <li><code>A</code> <b>add</b>(<em>a</em> b): Outputs sum of inputs.</li>
  <li><code>B</code> <b>subtract</b>(<em>a</em> b): Outputs difference of inputs.</li>
  <li><code>C</code> <b>clock</b>(<em>rate</em> mod): Outputs modulo of frame.</li>
  <li><code>D</code> <b>delay</b>(<em>rate</em> mod): Bangs on modulo of frame.</li>
  <li><code>E</code> <b>east</b>: Moves eastward, or bangs.</li>
  <li><code>F</code> <b>if</b>(<em>a</em> b): Bangs if inputs are equal.</li>
  <li><code>G</code> <b>generator</b>(<em>x</em> <em>y</em> <em>len</em>): Writes operands with offset.</li>
  <li><code>H</code> <b>halt</b>: Halts southward operand.</li>
  <li><code>I</code> <b>increment</b>(<em>step</em> mod): Increments southward operand.</li>
  <li><code>J</code> <b>jumper</b>(<em>val</em>): Outputs northward operand.</li>
  <li><code>K</code> <b>konkat</b>(<em>len</em>): Reads multiple variables.</li>
  <li><code>L</code> <b>less</b>(<em>a</em> <em>b</em>): Outputs smallest of inputs.</li>
  <li><code>M</code> <b>multiply</b>(<em>a</em> b): Outputs product of inputs.</li>
  <li><code>N</code> <b>north</b>: Moves Northward, or bangs.</li>
  <li><code>O</code> <b>read</b>(<em>x</em> <em>y</em> read): Reads operand with offset.</li>
  <li><code>P</code> <b>push</b>(<em>len</em> <em>key</em> val): Writes eastward operand.</li>
  <li><code>Q</code> <b>query</b>(<em>x</em> <em>y</em> <em>len</em>): Reads operands with offset.</li>
  <li><code>R</code> <b>random</b>(<em>min</em> max): Outputs random value.</li>
  <li><code>S</code> <b>south</b>: Moves southward, or bangs.</li>
  <li><code>T</code> <b>track</b>(<em>key</em> <em>len</em> val): Reads eastward operand.</li>
  <li><code>U</code> <b>uclid</b>(<em>step</em> max): Bangs on Euclidean rhythm.</li>
  <li><code>V</code> <b>variable</b>(<em>write</em> read): Reads and writes variable.</li>
  <li><code>W</code> <b>west</b>: Moves westward, or bangs.</li>
  <li><code>X</code> <b>write</b>(<em>x</em> <em>y</em> val): Writes operand with offset.</li>
  <li><code>Y</code> <b>jymper</b>(<em>val</em>): Outputs westward operand.</li>
  <li><code>Z</code> <b>lerp</b>(<em>rate</em> target): Transitions operand to input.</li>
  <li><code>*</code> <b>bang</b>: Bangs neighboring operands.</li>
  <li><code>#</code> <b>comment</b>: Halts a line.</li>
</ul>

<h1>Base 36 Table</h1>

<p>Orca operates on a <b>base of 36 increments</b>. Operators using numeric values will typically also operate on letters and convert them into values as per the following table. For instance <code>Do</code> will bang every 24th frame.</p>

<table border='1'>
<tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th></tr>
<tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr>
<tr><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th><th>I</th><th>J</th><th>K</th><th>L</th><th>M</th><th>N</th></tr>
<tr><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td></tr>
<tr><th>O</th><th>P</th><th>Q</th><th>R</th><th>S</th><th>T</th><th>U</th><th>V</th><th>W</th><th>X</th><th>Y</th><th>Z</th></tr>
<tr><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td></tr>
</table>

<h1>Tutorial</h1>

<h2 id="basics">Basics</h2>

<p>This section will teach the basics of playing a note and a sequence of notes.</p>

<h3>Send a midi note</h3>

<ul>
  <li><code>D8</code>, will send a bang, every 8th frame.</li>
  <li><code>:03C</code>, will send the <code>C</code> note, on the 3rd octave, to send <code>C#</code>, use the lowercase <code>c3</code>.</li>
</ul>

<pre>
D8...
.:03C</pre>

<h3>Play a random note</h3>

<ul>
  <li><code>aRG</code>, will output a random value between <code>A</code> &amp; <code>G</code>, the rightside uppercase letter indicates an uppercase output.</li>
</ul>

<pre>
D8.aRG.
.:03D..
</pre>

<h3 id="make-a-melody">Make a melody</h3>

<ul>
  <li><code>04TCAFE</code>, will create a track of 4 notes, and output its first value.</li>
</ul>

<pre>
D814TCAFE
.:03A....
</pre>

<h3 id="play-the-melody">Play the melody</h3>

<ul>
  <li><code>8C4</code>, will count from <code>0</code> to <code>3</code>, at 1/8th speed.</li>
</ul>

<pre>
.8C4.....
D804TCAFE
.:03C....
</pre>

<h2 id="logic">Logic</h2>

<p>This section will teach the basics of automating logic decisions and changing the values of operators dynamically.</p>

<h3 id="play-every-second-note">Play every second note</h3>

<ul>
  <li><code>2I6</code>, will increment to <code>6</code> at a rate of <code>2</code>.</li>
</ul>

<pre>
.2I6.......
D646TCAFEDG
.:03D......
</pre>

<h3 id="play-a-note-with-an-offset">Play a note with an offset</h3>

<ul>
  <li><code>1AC</code>, will add <code>1</code> to <code>C</code>, to output <code>D</code>. To get <code>D#</code>, use the lowercase <code>d</code>, like <code>1Ac</code>.</li>
</ul>

<pre>
D8.1AC.
.:03D..
</pre>

<h3 id="play-a-sequence-back-and-forth">Play a sequence back and forth</h3>

<ul>
  <li>The combination of the output of <code>C6</code> into <code>B3</code> will bounce a value between 0 and 3 over 6 frames.</li>
</ul>

<pre>
4C6......
.4B3.....
D414TCAFE
.:03A....
</pre>

<h3 id="play-a-note-at-a-specific-interval">Play a note at a specific interval</h3>

<ul>
  <li><code>.I4</code>, will increment to <code>4</code>, at a rate of <code>1</code>.</li>
  <li><code>.F2</code>, will bang only if leftside input is equal to <code>2</code>.</li>
</ul>

<pre>
I4.....
3F2.1AC
..:03D.
</pre>

<h2 id="projectors">Projectors</h2>

<p>This section will teach the basics of creating new operators procedurally.</p>

<h3 id="halt-a-moving-operator">Halt a moving operator</h3>

<ul>
  <li><code>E</code>, will travel further eastward, every frame.</li>
  <li><code>H</code>, will stop a <code>E</code> from moving.</li>
</ul>

<pre>
..H
E..
</pre>

<h3 id="read-an-operator-at-position">Read an operator at position</h3>

<ul>
  <li><code>22O</code>, will get the operator <code>E</code> at the offset <code>2,2</code>.</li>
</ul>

<pre>
22O...
..E..H
.....E
</pre>

<h3 id="write-an-operator-at-position">Write an operator at position</h3>

<ul>
  <li><code>22X</code>, will output the operator <code>E</code> at the offset <code>2,2</code>.</li>
</ul>

<pre>
22XE.
.....
.....
....E
</pre>

<h3 id="animate-a-projector">Animate a projector</h3>

<ul>
  <li><code>B8</code>, will bounce between <code>0</code> and <code>8</code>.</li>
</ul>

<pre>
C...........
.B4.........
.1XE........
........:03C
........:03D
........:03E
........:03F
........:03G
</pre>

<h2 id="variables">Variables</h2>

<p>This section will teach the basics of storing accessing and combining that stored data.</p>

<h3 id="write-a-variable">Write a variable</h3>

<ul>
  <li><code>aV5</code>, will store <code>5</code> in the variable <code>a</code>.</li>
</ul>

<pre>
aV5
</pre>

<h3 id="read-a-variable">Read a variable</h3>

<ul>
  <li><code>Va</code>, will output the value of the variable <code>a</code>. Notice how variables always have to be written above where they are read.</li>
</ul>

<pre>
.....Va
.......
aV5..Va
.....5.
.......
aV6..Va
.....6.
</pre>

<h3 id="read-3-variables">Read 3 variables</h3>

<ul>
  <li><code>3Kion</code>, will output the values of <code>i</code>, <code>o</code> &amp; <code>n</code>, side-by-side.</li>
</ul>

<pre>
iV0.oV3.nVC
...........
3Kion......
.:03C......
</pre>

<h3 id="carry-a-value-horizontally-and-vertically">Carry a value horizontally and vertically</h3>

<ul>
  <li><code>Y</code>, will output the west input, eastward.</li>
  <li><code>J</code>, will output the north input, southward.</li>
</ul>

<pre>
3..
J..
3Y3
</pre>

<h3 id="carry-a-bang">Carry a bang</h3>

<ul>
  <li>This method will allow you to bring bangs into tight spots.</li>
</ul>

<pre>
D43Ka...
.Y.:03C.
</pre>

<p>I hope this workshop has been enlightening, if you have questions or suggestions, please visit the <a href="https://llllllll.co/t/orca-live-coding-tool/17689">forum</a>, or the <a href="https://talk.lurk.org/channel/orca">chatroom</a>. Enjoy!</p>

<iframe width='624' height='380' src='https://www.youtube.com/embed/r28Xy-1_F8I' style='max-width:700px' frameborder='0' allow='autoplay; encrypted-media' allowfullscreen></iframe>

<h2>Golf</h2>

<p>Here are a few interesting snippets to achieve various arithmetic operations.</p>

<table border='1'>
  <tr><td><code>1X..<br />6I4.</code></td><td><b>Modulo</b><br />Will output the modulo of <code>6 % 4</code>.</td></tr>
  <tr><td><code>cA1.<br />.dAZ</code></td><td><b>Uppercase</b><br />Will output uppercase C.</td></tr>
  <tr><td><code>H...<br />CM1.</code></td><td><b>Lowercase</b><br />Will output lowercase C.</td></tr>
  <tr><td><code>.L0.<br />..F0</code></td><td><b>Not Null</b><br />Will bang if L free input is not null.</td></tr>
</table><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/html/orca_guide.htm' target='_blank'>edit</a> to <a href='../src/inc/html/orca_guide.htm'>orca_guide.htm</a>(288 lines)</figcaption>
</figure><h3>orca.c</h3><p>To learn more, see the complete manual in the <a href='https://git.sr.ht/~rabbits/orca-toy' target='_blank'>repository</a>.</p><pre>cc -std=c89 -O2 -DNDEBUG -g0 -s -Wall -L/usr/local/lib -lSDL2 -lportmidi orca.c -o orca</pre><p>The following code is a single-file implementation written <a href='ansi_c.html'>ANSI C</a> with <a href='https://www.libsdl.org' target='_blank'>SDL2</a> and <a href='http://portmedia.sourceforge.net/portmidi' target='_blank'>portmidi</a> as only dependecies.</p><figure><pre>#include &lt;stdio.h&gt;
#include &lt;SDL2/SDL.h&gt;
#include &lt;portmidi.h&gt;
#include &lt;porttime.h&gt;

/* 
Copyright (c) 2020 Devine Lu Linvega

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE.
*/

#define HOR 32
#define VER 16
#define PAD 2
#define VOICES 16
#define DEVICE 0

#define SZ (HOR * VER * 16)
#define CLIPSZ (HOR * VER) + VER + 1
#define MAXSZ (HOR * VER)

typedef unsigned char Uint8;

typedef struct Grid {
	int w, h, l, f, r;
	Uint8 var[36], data[MAXSZ], lock[MAXSZ], type[MAXSZ];
} Grid;

typedef struct {
	int unsaved;
	char name[256];
	Grid grid;
} Document;

typedef struct {
	int x, y, w, h;
} Rect2d;

typedef struct {
	int chn, val, vel, len;
} MidiNote;

Document doc;
char clip[CLIPSZ];
MidiNote voices[VOICES];
Rect2d cursor;

int WIDTH = 8 * HOR + PAD * 8 * 2;
int HEIGHT = 8 * (VER + 2) + PAD * 8 * 2;
int BPM = 128, DOWN = 0, ZOOM = 2, PAUSE = 0, GUIDES = 1, MODE = 0;

Uint32 theme[] = {
	0x000000,
	0xFFFFFF,
	0x72DEC2,
	0x666666,
	0xffb545};

Uint8 icons[][8] = {
	{0x00, 0x00, 0x10, 0x38, 0x7c, 0x38, 0x10, 0x00}, /* play */
	{0x00, 0x00, 0x48, 0x24, 0x12, 0x24, 0x48, 0x00}, /* next */
	{0x00, 0x00, 0x66, 0x42, 0x00, 0x42, 0x66, 0x00}, /* skip */
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00}, /* midi:1 */
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x3e, 0x00}, /* midi:2 */
	{0x00, 0x00, 0x00, 0x00, 0x3e, 0x3e, 0x3e, 0x00}, /* midi:3 */
	{0x00, 0x00, 0x00, 0x3e, 0x3e, 0x3e, 0x3e, 0x00}, /* midi:4 */
	{0x00, 0x00, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x00}, /* midi:5 */
	{0x00, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x00}, /* midi:6 */
	{0x00, 0x00, 0x00, 0x82, 0x44, 0x38, 0x00, 0x00}, /* eye open */
	{0x00, 0x38, 0x44, 0x92, 0x28, 0x10, 0x00, 0x00}, /* eye closed */
	{0x10, 0x54, 0x28, 0xc6, 0x28, 0x54, 0x10, 0x00}  /* unsaved */
};

Uint8 font[][8] = {
	{0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x00}, /* 0 */
	{0x00, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x00},
	{0x00, 0x00, 0x7c, 0x02, 0x3c, 0x40, 0x7e, 0x00},
	{0x00, 0x00, 0x7c, 0x02, 0x7c, 0x02, 0x7c, 0x00},
	{0x00, 0x00, 0x12, 0x22, 0x42, 0x7e, 0x02, 0x00},
	{0x00, 0x00, 0x7e, 0x40, 0x3c, 0x02, 0x7e, 0x00},
	{0x00, 0x00, 0x3e, 0x40, 0x7c, 0x42, 0x3c, 0x00},
	{0x00, 0x00, 0x7e, 0x02, 0x04, 0x08, 0x10, 0x00},
	{0x00, 0x00, 0x7e, 0x42, 0x3c, 0x42, 0x7e, 0x00},
	{0x00, 0x00, 0x7e, 0x42, 0x3e, 0x02, 0x02, 0x00}, /* 9 */
	{0x00, 0x00, 0x7c, 0x02, 0x3e, 0x42, 0x7a, 0x00}, /* a */
	{0x00, 0x00, 0x40, 0x40, 0x7c, 0x42, 0x7c, 0x00},
	{0x00, 0x00, 0x00, 0x3e, 0x40, 0x40, 0x3e, 0x00},
	{0x00, 0x00, 0x02, 0x02, 0x3e, 0x42, 0x3e, 0x00},
	{0x00, 0x00, 0x3c, 0x42, 0x7c, 0x40, 0x3e, 0x00},
	{0x00, 0x00, 0x3c, 0x42, 0x70, 0x40, 0x40, 0x00},
	{0x00, 0x00, 0x3e, 0x42, 0x3e, 0x02, 0x7c, 0x00},
	{0x00, 0x00, 0x40, 0x40, 0x7c, 0x42, 0x42, 0x00},
	{0x00, 0x00, 0x10, 0x00, 0x10, 0x10, 0x10, 0x00},
	{0x00, 0x00, 0x7e, 0x04, 0x04, 0x44, 0x38, 0x00},
	{0x00, 0x00, 0x42, 0x44, 0x78, 0x44, 0x42, 0x00},
	{0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x3e, 0x00},
	{0x00, 0x00, 0x6c, 0x52, 0x52, 0x52, 0x52, 0x00},
	{0x00, 0x00, 0x5c, 0x62, 0x42, 0x42, 0x42, 0x00},
	{0x00, 0x00, 0x1c, 0x22, 0x42, 0x44, 0x38, 0x00},
	{0x00, 0x00, 0x7c, 0x42, 0x7c, 0x40, 0x40, 0x00},
	{0x00, 0x00, 0x3e, 0x42, 0x3e, 0x02, 0x02, 0x00},
	{0x00, 0x00, 0x5c, 0x62, 0x40, 0x40, 0x40, 0x00},
	{0x00, 0x00, 0x3e, 0x40, 0x3c, 0x02, 0x7c, 0x00},
	{0x00, 0x00, 0x7e, 0x10, 0x10, 0x10, 0x08, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x24, 0x24, 0x18, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x52, 0x52, 0x6c, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x3c, 0x42, 0x42, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x3e, 0x02, 0x7c, 0x00},
	{0x00, 0x00, 0x7e, 0x04, 0x18, 0x20, 0x7e, 0x00}, /* z */
	{0x00, 0x00, 0x3c, 0x42, 0x7e, 0x42, 0x42, 0x00}, /* A */
	{0x00, 0x00, 0x7c, 0x42, 0x7c, 0x42, 0x7c, 0x00},
	{0x00, 0x00, 0x3e, 0x40, 0x40, 0x40, 0x3e, 0x00},
	{0x00, 0x00, 0x7c, 0x42, 0x42, 0x42, 0x7c, 0x00},
	{0x00, 0x00, 0x7e, 0x40, 0x7e, 0x40, 0x7e, 0x00},
	{0x00, 0x00, 0x7e, 0x40, 0x70, 0x40, 0x40, 0x00},
	{0x00, 0x00, 0x3e, 0x40, 0x5c, 0x42, 0x3e, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00},
	{0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00},
	{0x00, 0x00, 0x7e, 0x02, 0x02, 0x42, 0x3c, 0x00},
	{0x00, 0x00, 0x46, 0x48, 0x70, 0x48, 0x46, 0x00},
	{0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00},
	{0x00, 0x00, 0x6e, 0x52, 0x52, 0x52, 0x52, 0x00},
	{0x00, 0x00, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00},
	{0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x00},
	{0x00, 0x00, 0x7e, 0x42, 0x7c, 0x40, 0x40, 0x00},
	{0x00, 0x00, 0x3c, 0x42, 0x4a, 0x44, 0x3a, 0x00},
	{0x00, 0x00, 0x7e, 0x42, 0x7c, 0x42, 0x42, 0x00},
	{0x00, 0x00, 0x3e, 0x40, 0x7e, 0x02, 0x7c, 0x00},
	{0x00, 0x00, 0x7e, 0x10, 0x10, 0x10, 0x10, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00},
	{0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00},
	{0x00, 0x00, 0x52, 0x52, 0x52, 0x52, 0x6e, 0x00},
	{0x00, 0x00, 0x42, 0x24, 0x18, 0x24, 0x42, 0x00},
	{0x00, 0x00, 0x42, 0x24, 0x10, 0x10, 0x10, 0x00},
	{0x00, 0x00, 0x7e, 0x02, 0x3c, 0x40, 0x7e, 0x00}, /* Z */
	{0x00, 0x00, 0x5a, 0x24, 0x42, 0x24, 0x5a, 0x00}, /* * */
	{0x00, 0x00, 0x24, 0x7e, 0x24, 0x7e, 0x24, 0x00}, /* # */
	{0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00}, /* . */
	{0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00}, /* : */
	{0x00, 0x00, 0x66, 0x5a, 0x24, 0x5a, 0x66, 0x00}, /* @ */
	{0x00, 0x00, 0x00, 0x32, 0x42, 0x4c, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x28, 0x00, 0x28, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

SDL_Window *gWindow = NULL;
SDL_Renderer *gRenderer = NULL;
SDL_Texture *gTexture = NULL;
Uint32 *pixels;
PmStream *midi;

#pragma mark - HELPERS

int
clmp(int val, int min, int max)
{
	return (val &gt;= min) ? (val &lt;= max) ? val : max : min;
}

int
cisp(char c)
{
	return c == '.' || c == ':' || c == '#' || c == '*';
}

char
cchr(int v, char c)
{
	v = abs(v % 36);
	if(v &gt;= 0 &amp;&amp; v &lt;= 9)
		return '0' + v;
	return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' ? 'A' : 'a') + v - 10;
}

int
cb36(char c)
{
	if(c &gt;= '0' &amp;&amp; c &lt;= '9')
		return c - '0';
	if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
		return c - 'A' + 10;
	if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')
		return c - 'a' + 10;
	return 0;
}

char
cuca(char c)
{
	return c &gt;= 'a' &amp;&amp; c &lt;= 'z' ? 'A' + c - 'a' : c;
}

char
clca(char c)
{
	return c &gt;= 'A' &amp;&amp; c &lt;= 'Z' ? 'a' + c - 'A' : c;
}

char
cinc(char c)
{
	return !cisp(c) ? cchr(cb36(c) + 1, c) : c;
}

char
cdec(char c)
{
	return !cisp(c) ? cchr(cb36(c) - 1, c) : c;
}

int
validposition(Grid *g, int x, int y)
{
	return x &gt;= 0 &amp;&amp; x &lt;= g-&gt;w - 1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= g-&gt;h - 1;
}

int
validcharacter(char c)
{
	return cb36(c) || c == '0' || cisp(c);
}

int
ctbl(char c)
{
	int sharp, uc, deg, notes[] = {0, 2, 4, 5, 7, 9, 11};
	if(c &gt;= '0' &amp;&amp; c &lt;= '9')
		return c - '0';
	sharp = c &gt;= 'a' &amp;&amp; c &lt;= 'z';
	uc = sharp ? c - 'a' + 'A' : c;
	deg = uc &lt;= 'B' ? 'G' - 'B' + uc - 'A' : uc - 'C';
	return deg / 7 * 12 + notes[deg % 7] + sharp;
}

char *
scpy(char *src, char *dst, int len)
{
	int i = 0;
	while((dst[i] = src[i]) &amp;&amp; i &lt; len - 2)
		i++;
	dst[i + 1] = '\0';
	return dst;
}

#pragma mark - IO

char
getcell(Grid *g, int x, int y)
{
	if(validposition(g, x, y))
		return g-&gt;data[x + (y * g-&gt;w)];
	return '.';
}

void
setcell(Grid *g, int x, int y, char c)
{
	if(validposition(g, x, y) &amp;&amp; validcharacter(c))
		g-&gt;data[x + (y * g-&gt;w)] = c;
}

int
gettype(Grid *g, int x, int y)
{
	if(validposition(g, x, y))
		return g-&gt;type[x + (y * g-&gt;w)];
	return 0;
}

void
settype(Grid *g, int x, int y, int t)
{
	if(validposition(g, x, y))
		g-&gt;type[x + (y * g-&gt;w)] = t;
}

void
setlock(Grid *g, int x, int y)
{
	if(validposition(g, x, y)) {
		g-&gt;lock[x + (y * g-&gt;w)] = 1;
		if(!gettype(g, x, y))
			settype(g, x, y, 1);
	}
}

void
setport(Grid *g, int x, int y, char c)
{
	setlock(g, x, y);
	settype(g, x, y, 5);
	setcell(g, x, y, c);
}

int
getport(Grid *g, int x, int y, int l)
{
	if(l) {
		setlock(g, x, y);
		settype(g, x, y, 4);
	} else
		settype(g, x, y, 2);
	return getcell(g, x, y);
}

int
getbang(Grid *g, int x, int y)
{
	return getcell(g, x - 1, y) == '*' || getcell(g, x + 1, y) == '*' || getcell(g, x, y - 1) == '*' || getcell(g, x, y + 1) == '*';
}

#pragma mark - MIDI

MidiNote *
sendmidi(int chn, int val, int vel, int len)
{
	int i = 0;
	/* Detrigger */
	for(i = 0; i &lt; VOICES; ++i) {
		MidiNote *n = &amp;voices[i];
		if(!n-&gt;len || n-&gt;chn != chn || n-&gt;val != val)
			continue;
		Pm_WriteShort(midi,
			Pt_Time(),
			Pm_Message(0x90 + n-&gt;chn, n-&gt;val, 0));
		n-&gt;len = 0;
	}
	/* Trigger */
	for(i = 0; i &lt; VOICES; ++i) {
		MidiNote *n = &amp;voices[i];
		if(n-&gt;len &lt; 1) {
			n-&gt;chn = chn;
			n-&gt;val = val;
			n-&gt;vel = vel;
			n-&gt;len = len;
			Pm_WriteShort(midi,
				Pt_Time(),
				Pm_Message(0x90 + chn, val, vel * 3));
			return n;
		}
	}
	return NULL;
}

void
runmidi(void)
{
	int i;
	for(i = 0; i &lt; VOICES; ++i) {
		MidiNote *n = &amp;voices[i];
		if(n-&gt;len &gt; 0) {
			n-&gt;len--;
			if(n-&gt;len == 0)
				Pm_WriteShort(midi,
					Pt_Time(),
					Pm_Message(0x90 + n-&gt;chn, n-&gt;val, 0));
		}
	}
}

void
initmidi(void)
{
	int i;
	Pm_Initialize();
	for(i = 0; i &lt; Pm_CountDevices(); ++i)
		printf("Device #%d -&gt; %s%s\n",
			i,
			Pm_GetDeviceInfo(i)-&gt;name,
			i == DEVICE ? "[x]" : "[ ]");
	Pm_OpenOutput(&amp;midi, DEVICE, NULL, 128, 0, NULL, 1);
}

#pragma mark - LIBRARY

void
opa(Grid *g, int x, int y, char c)
{
	char a = getport(g, x - 1, y, 0);
	char b = getport(g, x + 1, y, 1);
	setport(g, x, y + 1, cchr(cb36(a) + cb36(b), b));
	(void)c;
}

void
opb(Grid *g, int x, int y, char c)
{
	char a = getport(g, x - 1, y, 0);
	char b = getport(g, x + 1, y, 1);
	setport(g, x, y + 1, cchr(cb36(a) - cb36(b), b));
	(void)c;
}

void
opc(Grid *g, int x, int y, char c)
{
	char rate = getport(g, x - 1, y, 0);
	char mod = getport(g, x + 1, y, 1);
	int mod_ = cb36(mod);
	int rate_ = cb36(rate);
	if(!rate_)
		rate_ = 1;
	if(!mod_)
		mod_ = 8;
	setport(g, x, y + 1, cchr(g-&gt;f / rate_ % mod_, mod));
	(void)c;
}

void
opd(Grid *g, int x, int y, char c)
{
	char rate = getport(g, x - 1, y, 0);
	char mod = getport(g, x + 1, y, 1);
	int rate_ = cb36(rate);
	int mod_ = cb36(mod);
	if(!rate_)
		rate_ = 1;
	if(!mod_)
		mod_ = 8;
	setport(g, x, y + 1, g-&gt;f % (rate_ * mod_) == 0 ? '*' : '.');
	(void)c;
}

void
ope(Grid *g, int x, int y, char c)
{
	if(x &gt;= g-&gt;w - 1 || getcell(g, x + 1, y) != '.')
		setcell(g, x, y, '*');
	else {
		setcell(g, x, y, '.');
		setport(g, x + 1, y, c);
		settype(g, x + 1, y, 0);
	}
	settype(g, x, y, 0);
}

void
opf(Grid *g, int x, int y, char c)
{
	char a = getport(g, x - 1, y, 0);
	char b = getport(g, x + 1, y, 1);
	setport(g, x, y + 1, a == b ? '*' : '.');
	(void)c;
}

void
opg(Grid *g, int x, int y, char c)
{
	char px = getport(g, x - 3, y, 0);
	char py = getport(g, x - 2, y, 0);
	char len = getport(g, x - 1, y, 0);
	int i, len_ = cb36(len);
	if(!len_)
		len_ = 1;
	for(i = 0; i &lt; len_; ++i)
		setport(g, x + i + cb36(px), y + 1 + cb36(py), getport(g, x + 1 + i, y, 1));
	(void)c;
}

void
oph(Grid *g, int x, int y, char c)
{
	getport(g, x, y + 1, 1);
	(void)c;
}

void
opi(Grid *g, int x, int y, char c)
{
	char rate = getport(g, x - 1, y, 0);
	char mod = getport(g, x + 1, y, 1);
	char val = getport(g, x, y + 1, 1);
	int rate_ = cb36(rate);
	int mod_ = cb36(mod);
	if(!rate_)
		rate_ = 1;
	if(!mod_)
		mod_ = 36;
	setport(g, x, y + 1, cchr((cb36(val) + rate_) % mod_, mod));
	(void)c;
}

void
opj(Grid *g, int x, int y, char c)
{
	char link = getport(g, x, y - 1, 0);
	int i;
	if(link != c) {
		for(i = 1; y + i &lt; 256; ++i)
			if(getcell(g, x, y + i) != c)
				break;
		setport(g, x, y + i, link);
	}
}

void
opk(Grid *g, int x, int y, char c)
{
	char len = getport(g, x - 1, y, 0);
	int i, len_ = cb36(len);
	if(!len_)
		len_ = 1;
	for(i = 0; i &lt; len_; ++i) {
		char key = getport(g, x + 1 + i, y, 1);
		if(key != '.')
			setport(g, x + 1 + i, y + 1, g-&gt;var[cb36(key)]);
	}
	(void)c;
}

void
opl(Grid *g, int x, int y, char c)
{
	char a = getport(g, x - 1, y, 0);
	char b = getport(g, x + 1, y, 1);
	setport(g, x, y + 1, cb36(a) &lt; cb36(b) ? a : b);
	(void)c;
}

void
opm(Grid *g, int x, int y, char c)
{
	char a = getport(g, x - 1, y, 0);
	char b = getport(g, x + 1, y, 1);
	setport(g, x, y + 1, cchr(cb36(a) * cb36(b), b));
	(void)c;
}

void
opn(Grid *g, int x, int y, char c)
{
	if(y &lt;= 0 || getcell(g, x, y - 1) != '.')
		setcell(g, x, y, '*');
	else {
		setcell(g, x, y, '.');
		setport(g, x, y - 1, c);
		settype(g, x, y - 1, 0);
	}
	settype(g, x, y, 0);
}

void
opo(Grid *g, int x, int y, char c)
{
	char px = getport(g, x - 2, y, 0);
	char py = getport(g, x - 1, y, 0);
	setport(g, x, y + 1, getport(g, x + 1 + cb36(px), y + cb36(py), 1));
	(void)c;
}

void
opp(Grid *g, int x, int y, char c)
{
	char key = getport(g, x - 2, y, 0);
	char len = getport(g, x - 1, y, 0);
	char val = getport(g, x + 1, y, 1);
	int i, len_ = cb36(len);
	if(!len_)
		len_ = 1;
	for(i = 0; i &lt; len_; ++i)
		setlock(g, x + i, y + 1);
	setport(g, x + (cb36(key) % len_), y + 1, val);
	(void)c;
}

void
opq(Grid *g, int x, int y, char c)
{
	char px = getport(g, x - 3, y, 0);
	char py = getport(g, x - 2, y, 0);
	char len = getport(g, x - 1, y, 0);
	int i, len_ = cb36(len);
	if(!len_)
		len_ = 1;
	for(i = 0; i &lt; len_; ++i)
		setport(g, x + 1 - len_ + i, y + 1, getport(g, x + 1 + cb36(px) + i, y + cb36(py), 1));
	(void)c;
}

void
opr(Grid *g, int x, int y, char c)
{
	char min = getport(g, x - 1, y, 0);
	char max = getport(g, x + 1, y, 1);
	int min_ = cb36(min);
	int max_ = cb36(max);
	unsigned int key = (g-&gt;r + y * g-&gt;w + x) ^ (g-&gt;f &lt;&lt; 16);
	if(!max_)
		max_ = 36;
	if(min_ == max_)
		min_ = max_ - 1;
	key = (key ^ 61U) ^ (key &gt;&gt; 16);
	key = key + (key &lt;&lt; 3);
	key = key ^ (key &gt;&gt; 4);
	key = key * 0x27d4eb2d;
	key = key ^ (key &gt;&gt; 15);
	setport(g, x, y + 1, cchr(key % (max_ - min_) + min_, max));
	(void)c;
}

void
ops(Grid *g, int x, int y, char c)
{
	if(y &gt;= g-&gt;h - 1 || getcell(g, x, y + 1) != '.')
		setcell(g, x, y, '*');
	else {
		setcell(g, x, y, '.');
		setport(g, x, y + 1, c);
		settype(g, x, y + 1, 0);
	}
	settype(g, x, y, 0);
}

void
opt(Grid *g, int x, int y, char c)
{
	char key = getport(g, x - 2, y, 0);
	char len = getport(g, x - 1, y, 0);
	int i, len_ = cb36(len);
	if(!len_)
		len_ = 1;
	for(i = 0; i &lt; len_; ++i)
		setlock(g, x + 1 + i, y);
	setport(g, x, y + 1, getport(g, x + 1 + (cb36(key) % len_), y, 1));
	(void)c;
}

void
opu(Grid *g, int x, int y, char c)
{
	char step = getport(g, x - 1, y, 1);
	char max = getport(g, x + 1, y, 1);
	int step_ = cb36(step);
	int max_ = cb36(max);
	int bucket;
	if(!step_)
		step_ = 1;
	if(!max_)
		max_ = 8;
	bucket = (step_ * (g-&gt;f + max_ - 1)) % max_ + step_;
	setport(g, x, y + 1, bucket &gt;= max_ ? '*' : '.');
	(void)c;
}

void
opv(Grid *g, int x, int y, char c)
{
	char w = getport(g, x - 1, y, 0);
	char r = getport(g, x + 1, y, 1);
	if(w != '.')
		g-&gt;var[cb36(w)] = r;
	else if(w == '.' &amp;&amp; r != '.')
		setport(g, x, y + 1, g-&gt;var[cb36(r)]);
	(void)c;
}

void
opw(Grid *g, int x, int y, char c)
{
	if(x &lt;= 0 || getcell(g, x - 1, y) != '.')
		setcell(g, x, y, '*');
	else {
		setcell(g, x, y, '.');
		setport(g, x - 1, y, c);
		settype(g, x - 1, y, 0);
	}
	settype(g, x, y, 0);
}

void
opx(Grid *g, int x, int y, char c)
{
	char px = getport(g, x - 2, y, 0);
	char py = getport(g, x - 1, y, 0);
	char val = getport(g, x + 1, y, 1);
	setport(g, x + cb36(px), y + cb36(py) + 1, val);
	(void)c;
}

void
opy(Grid *g, int x, int y, char c)
{
	char link = getport(g, x - 1, y, 0);
	int i;
	if(link != c) {
		for(i = 1; x + i &lt; 256; ++i)
			if(getcell(g, x + i, y) != c)
				break;
		setport(g, x + i, y, link);
	}
}

void
opz(Grid *g, int x, int y, char c)
{
	char rate = getport(g, x - 1, y, 0);
	char target = getport(g, x + 1, y, 1);
	char val = getport(g, x, y + 1, 1);
	int rate_ = cb36(rate);
	int target_ = cb36(target);
	int val_ = cb36(val);
	int mod;
	if(!rate_)
		rate_ = 1;
	mod = val_ &lt;= target_ - rate_ ? rate_ : val_ &gt;= target_ + rate_ ? -rate_
																	: target_ - val_;
	setport(g, x, y + 1, cchr(val_ + mod, target));
	(void)c;
}

void
opcomment(Grid *g, int x, int y)
{
	int i;
	for(i = 1; x + i &lt; 256; ++i) {
		setlock(g, x + i, y);
		if(getcell(g, x + i, y) == '#')
			break;
	}
	settype(g, x, y, 1);
}

void
opmidi(Grid *g, int x, int y)
{
	int chn, oct, nte, vel, len;
	chn = cb36(getport(g, x + 1, y, 1));
	if(chn == '.')
		return;
	oct = cb36(getport(g, x + 2, y, 1));
	if(oct == '.')
		return;
	nte = getport(g, x + 3, y, 1);
	if(cisp(nte))
		return;
	vel = getport(g, x + 4, y, 1);
	if(vel == '.')
		vel = 'z';
	len = getport(g, x + 5, y, 1);
	if(getbang(g, x, y)) {
		sendmidi(
			clmp(chn, 0, 16),
			12 * oct + ctbl(nte),
			clmp(cb36(vel), 0, 36),
			clmp(cb36(len), 1, 36));
		settype(g, x, y, 3);
	} else
		settype(g, x, y, 2);
}

void
operate(Grid *g, int x, int y, char c)
{
	settype(g, x, y, 3);
	switch(clca(c)) {
	case 'a': opa(g, x, y, c); break;
	case 'b': opb(g, x, y, c); break;
	case 'c': opc(g, x, y, c); break;
	case 'd': opd(g, x, y, c); break;
	case 'e': ope(g, x, y, c); break;
	case 'f': opf(g, x, y, c); break;
	case 'g': opg(g, x, y, c); break;
	case 'h': oph(g, x, y, c); break;
	case 'i': opi(g, x, y, c); break;
	case 'k': opk(g, x, y, c); break;
	case 'j': opj(g, x, y, c); break;
	case 'l': opl(g, x, y, c); break;
	case 'm': opm(g, x, y, c); break;
	case 'n': opn(g, x, y, c); break;
	case 'o': opo(g, x, y, c); break;
	case 'p': opp(g, x, y, c); break;
	case 'q': opq(g, x, y, c); break;
	case 'r': opr(g, x, y, c); break;
	case 's': ops(g, x, y, c); break;
	case 't': opt(g, x, y, c); break;
	case 'u': opu(g, x, y, c); break;
	case 'v': opv(g, x, y, c); break;
	case 'w': opw(g, x, y, c); break;
	case 'x': opx(g, x, y, c); break;
	case 'y': opy(g, x, y, c); break;
	case 'z': opz(g, x, y, c); break;
	case '*': setcell(g, x, y, '.'); break;
	case '#': opcomment(g, x, y); break;
	case ':': opmidi(g, x, y); break;
	default: printf("Unknown operator[%d,%d]: %c\n", x, y, c);
	}
}

#pragma mark - GRID

void
initgridframe(Grid *g)
{
	int i;
	for(i = 0; i &lt; g-&gt;l; ++i) {
		g-&gt;lock[i] = 0;
		g-&gt;type[i] = 0;
	}
	for(i = 0; i &lt; 36; ++i)
		g-&gt;var[i] = '.';
}

int
rungrid(Grid *g)
{
	int i, x, y;
	initgridframe(g);
	for(i = 0; i &lt; g-&gt;l; ++i) {
		char c = g-&gt;data[i];
		x = i % g-&gt;w;
		y = i / g-&gt;w;
		if(c == '.' || g-&gt;lock[i])
			continue;
		if(c &gt;= '0' &amp;&amp; c &lt;= '9')
			continue;
		if(c &gt;= 'a' &amp;&amp; c &lt;= 'z' &amp;&amp; !getbang(g, x, y))
			continue;
		operate(g, x, y, c);
	}
	g-&gt;f++;
	return 1;
}

void
initgrid(Grid *g, int w, int h)
{
	int i;
	g-&gt;w = w;
	g-&gt;h = h;
	g-&gt;l = w * h;
	g-&gt;f = 0;
	g-&gt;r = 1;
	for(i = 0; i &lt; g-&gt;l; ++i)
		setcell(g, i % g-&gt;w, i / g-&gt;w, '.');
	initgridframe(g);
}

#pragma mark - DRAW

int
getfont(int x, int y, char c, int type, int sel)
{
	if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
		return c - 'A' + 36;
	if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')
		return c - 'a' + 10;
	if(c &gt;= '0' &amp;&amp; c &lt;= '9')
		return c - '0';
	if(c == '*')
		return 62;
	if(c == '#')
		return 63;
	if(c == ':')
		return 65;
	if(cursor.x == x &amp;&amp; cursor.y == y)
		return 66;
	if(GUIDES) {
		if(x % 8 == 0 &amp;&amp; y % 8 == 0)
			return 68;
		if(sel || type || (x % 2 == 0 &amp;&amp; y % 2 == 0))
			return 64;
	}
	return 70;
}

void
setpixel(Uint32 *dst, int x, int y, int color)
{
	if(x &gt;= 0 &amp;&amp; x &lt; WIDTH - 8 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; HEIGHT - 8)
		dst[(y + PAD * 8) * WIDTH + (x + PAD * 8)] = theme[color];
}

void
drawicon(Uint32 *dst, int x, int y, Uint8 *icon, int fg, int bg)
{
	int v, h;
	for(v = 0; v &lt; 8; v++)
		for(h = 0; h &lt; 8; h++) {
			int clr = (icon[v] &gt;&gt; (7 - h)) &amp; 0x1;
			setpixel(dst, x + h, y + v, clr == 1 ? fg : bg);
		}
}

void
drawui(Uint32 *dst)
{
	int i, n = 0, bottom = VER * 8 + 8;
	/* cursor */
	drawicon(dst, 0 * 8, bottom, font[cursor.x % 36], 1, 0);
	drawicon(dst, 1 * 8, bottom, font[68], 1, 0);
	drawicon(dst, 2 * 8, bottom, font[cursor.y % 36], 1, 0);
	drawicon(dst, 3 * 8, bottom, icons[2], cursor.w &gt; 1 || cursor.h &gt; 1 ? 4 : 3, 0);
	/* frame */
	drawicon(dst, 5 * 8, bottom, font[(doc.grid.f / 1296) % 36], 1, 0);
	drawicon(dst, 6 * 8, bottom, font[(doc.grid.f / 36) % 36], 1, 0);
	drawicon(dst, 7 * 8, bottom, font[doc.grid.f % 36], 1, 0);
	drawicon(dst, 8 * 8, bottom, icons[PAUSE ? 1 : 0], (doc.grid.f - 1) % 8 == 0 ? 2 : 3, 0);
	/* speed */
	drawicon(dst, 10 * 8, bottom, font[(BPM / 100) % 10], 1, 0);
	drawicon(dst, 11 * 8, bottom, font[(BPM / 10) % 10], 1, 0);
	drawicon(dst, 12 * 8, bottom, font[BPM % 10], 1, 0);
	/* io */
	for(i = 0; i &lt; VOICES; ++i)
		if(voices[i].len)
			n++;
	drawicon(dst, 13 * 8, bottom, n &gt; 0 ? icons[2 + clmp(n, 0, 6)] : font[70], 2, 0);
	/* generics */
	drawicon(dst, 15 * 8, bottom, icons[GUIDES ? 10 : 9], GUIDES ? 1 : 2, 0);
	drawicon(dst, (HOR - 1) * 8, bottom, icons[11], doc.unsaved ? 2 : 3, 0);
}

void
redraw(Uint32 *dst)
{
	int x, y;
	Rect2d *r = &amp;cursor;
	for(y = 0; y &lt; VER; ++y) {
		for(x = 0; x &lt; HOR; ++x) {
			int sel = x &lt; r-&gt;x + r-&gt;w &amp;&amp; x &gt;= r-&gt;x &amp;&amp; y &lt; r-&gt;y + r-&gt;h &amp;&amp; y &gt;= r-&gt;y;
			int t = gettype(&amp;doc.grid, x, y);
			Uint8 *letter = font[getfont(x, y, getcell(&amp;doc.grid, x, y), t, sel)];
			int fg = 0, bg = 0;
			if((sel &amp;&amp; !MODE) || (sel &amp;&amp; MODE &amp;&amp; doc.grid.f % 2)) {
				fg = 0;
				bg = 4;
			} else {
				switch(t) {
				case 1: fg = 3; break;
				case 2: fg = 1; break;
				case 3: bg = 1; break;
				case 4: fg = 2; break;
				case 5: bg = 2; break;
				default:
					fg = 3;
				}
			}
			drawicon(dst, x * 8, y * 8, letter, fg, bg);
		}
	}
	drawui(dst);
	SDL_UpdateTexture(gTexture, NULL, dst, WIDTH * sizeof(Uint32));
	SDL_RenderClear(gRenderer);
	SDL_RenderCopy(gRenderer, gTexture, NULL, NULL);
	SDL_RenderPresent(gRenderer);
}

#pragma mark - OPTIONS

int
error(char *msg, const char *err)
{
	printf("Error %s: %s\n", msg, err);
	return 0;
}

void
makedoc(Document *d, char *name)
{
	initgrid(&amp;d-&gt;grid, HOR, VER);
	d-&gt;unsaved = 0;
	scpy(name, d-&gt;name, 256);
	redraw(pixels);
	printf("Made: %s\n", name);
}

int
opendoc(Document *d, char *name)
{
	int x = 0, y = 0;
	char c;
	FILE *f = fopen(name, "r");
	if(!f)
		return error("Load", "Invalid input file");
	initgrid(&amp;d-&gt;grid, HOR, VER);
	while((c = fgetc(f)) != EOF &amp;&amp; d-&gt;grid.l &lt;= MAXSZ) {
		if(c == '\n') {
			x = 0;
			y++;
		} else {
			setcell(&amp;d-&gt;grid, x, y, c);
			x++;
		}
	}
	d-&gt;unsaved = 0;
	scpy(name, d-&gt;name, 256);
	redraw(pixels);
	printf("Opened: %s\n", name);
	return 1;
}

void
savedoc(Document *d, char *name)
{
	int x, y;
	FILE *f = fopen(name, "w");
	for(y = 0; y &lt; d-&gt;grid.h; ++y) {
		for(x = 0; x &lt; d-&gt;grid.w; ++x)
			fputc(getcell(&amp;d-&gt;grid, x, y), f);
		fputc('\n', f);
	}
	fclose(f);
	d-&gt;unsaved = 0;
	scpy(name, d-&gt;name, 256);
	redraw(pixels);
	printf("Saved: %s\n", name);
}

void
transform(Rect2d *r, char (*fn)(char))
{
	int x, y;
	for(y = 0; y &lt; r-&gt;h; ++y)
		for(x = 0; x &lt; r-&gt;w; ++x)
			setcell(&amp;doc.grid, r-&gt;x + x, r-&gt;y + y, fn(getcell(&amp;doc.grid, r-&gt;x + x, r-&gt;y + y)));
	redraw(pixels);
}

void
setoption(int *i, int v)
{
	*i = v;
	redraw(pixels);
}

void
select(int x, int y, int w, int h)
{
	Rect2d r;
	r.x = clmp(x, 0, HOR - 1);
	r.y = clmp(y, 0, VER - 1);
	r.w = clmp(w, 1, HOR - x);
	r.h = clmp(h, 1, VER - y);
	if(r.x != cursor.x || r.y != cursor.y || r.w != cursor.w || r.h != cursor.h) {
		cursor = r;
		redraw(pixels);
	}
}

void
scale(int w, int h, int skip)
{
	select(cursor.x, cursor.y, cursor.w + (w * (skip ? 4 : 1)), cursor.h + (h * (skip ? 4 : 1)));
}

void
move(int x, int y, int skip)
{
	select(cursor.x + (x * (skip ? 4 : 1)), cursor.y + (y * (skip ? 4 : 1)), cursor.w, cursor.h);
}

void
reset(void)
{
	MODE = 0;
	GUIDES = 1;
	select(cursor.x, cursor.y, 1, 1);
}

void
comment(Rect2d *r)
{
	int y;
	char c = getcell(&amp;doc.grid, r-&gt;x, r-&gt;y) == '#' ? '.' : '#';
	for(y = 0; y &lt; r-&gt;h; ++y) {
		setcell(&amp;doc.grid, r-&gt;x, r-&gt;y + y, c);
		setcell(&amp;doc.grid, r-&gt;x + r-&gt;w - 1, r-&gt;y + y, c);
	}
	doc.unsaved = 1;
	redraw(pixels);
}

void
insert(char c)
{
	int x, y;
	for(x = 0; x &lt; cursor.w; ++x)
		for(y = 0; y &lt; cursor.h; ++y)
			setcell(&amp;doc.grid, cursor.x + x, cursor.y + y, c);
	if(MODE)
		move(1, 0, 0);
	doc.unsaved = 1;
	redraw(pixels);
}

void
frame(void)
{
	rungrid(&amp;doc.grid);
	redraw(pixels);
	runmidi();
}

void
selectoption(int option)
{
	switch(option) {
	case 3: select(cursor.x, cursor.y, 1, 1); break;
	case 8:
		PAUSE = 1;
		frame();
		break;
	case 15: setoption(&amp;GUIDES, !GUIDES); break;
	case HOR - 1: savedoc(&amp;doc, doc.name); break;
	}
}

void
quit(void)
{
	free(pixels);
	SDL_DestroyTexture(gTexture);
	gTexture = NULL;
	SDL_DestroyRenderer(gRenderer);
	gRenderer = NULL;
	SDL_DestroyWindow(gWindow);
	gWindow = NULL;
	SDL_Quit();
	exit(0);
}

#pragma mark - CLIP

void
copyclip(Rect2d *r, char *c)
{
	int x, y, i = 0;
	for(y = 0; y &lt; r-&gt;h; ++y) {
		for(x = 0; x &lt; r-&gt;w; ++x)
			c[i++] = getcell(&amp;doc.grid, r-&gt;x + x, r-&gt;y + y);
		c[i++] = '\n';
	}
	c[i] = '\0';
	redraw(pixels);
}

void
cutclip(Rect2d *r, char *c)
{
	copyclip(r, c);
	insert('.');
}

void
pasteclip(Rect2d *r, char *c, int insert)
{
	int i = 0, x = r-&gt;x, y = r-&gt;y;
	char ch;
	while((ch = c[i++])) {
		if(ch == '\n') {
			x = r-&gt;x;
			y++;
		} else {
			setcell(&amp;doc.grid, x, y, insert &amp;&amp; ch == '.' ? getcell(&amp;doc.grid, x, y) : ch);
			x++;
		}
	}
	doc.unsaved = 1;
	redraw(pixels);
}

void
moveclip(Rect2d *r, char *c, int x, int y, int skip)
{
	copyclip(r, c);
	insert('.');
	move(x, y, skip);
	pasteclip(r, c, 0);
}

#pragma mark - TRIGGERS

void
domouse(SDL_Event *event)
{
	int cx = event-&gt;motion.x / ZOOM / 8 - PAD;
	int cy = event-&gt;motion.y / ZOOM / 8 - PAD;
	switch(event-&gt;type) {
	case SDL_MOUSEBUTTONUP:
		DOWN = 0;
		break;
	case SDL_MOUSEBUTTONDOWN:
		if(cy == VER + 1)
			selectoption(cx);
		else {
			select(cx, cy, 1, 1);
			DOWN = 1;
		}
		break;
	case SDL_MOUSEMOTION:
		if(DOWN)
			select(cursor.x, cursor.y, cx + 1 - cursor.x, cy + 1 - cursor.y);
		break;
	}
}

void
dokey(SDL_Event *event)
{
	int shift = SDL_GetModState() &amp; KMOD_LSHIFT || SDL_GetModState() &amp; KMOD_RSHIFT;
	int ctrl = SDL_GetModState() &amp; KMOD_LCTRL || SDL_GetModState() &amp; KMOD_RCTRL;
	int alt = SDL_GetModState() &amp; KMOD_LALT || SDL_GetModState() &amp; KMOD_RALT;
	if(ctrl) {
		switch(event-&gt;key.keysym.sym) {
		/* Generic */
		case SDLK_n: makedoc(&amp;doc, "untitled.orca"); break;
		case SDLK_r: opendoc(&amp;doc, doc.name); break;
		case SDLK_s: savedoc(&amp;doc, doc.name); break;
		case SDLK_h: setoption(&amp;GUIDES, !GUIDES); break;
		/* Edit */
		case SDLK_i: setoption(&amp;MODE, !MODE); break;
		case SDLK_a: select(0, 0, doc.grid.w, doc.grid.h); break;
		case SDLK_x: cutclip(&amp;cursor, clip); break;
		case SDLK_c: copyclip(&amp;cursor, clip); break;
		case SDLK_v: pasteclip(&amp;cursor, clip, shift); break;
		case SDLK_u: transform(&amp;cursor, cuca); break;
		case SDLK_l: transform(&amp;cursor, clca); break;
		case SDLK_LEFTBRACKET: transform(&amp;cursor, cinc); break;
		case SDLK_RIGHTBRACKET: transform(&amp;cursor, cdec); break;
		case SDLK_UP: moveclip(&amp;cursor, clip, 0, -1, alt); break;
		case SDLK_DOWN: moveclip(&amp;cursor, clip, 0, 1, alt); break;
		case SDLK_LEFT: moveclip(&amp;cursor, clip, -1, 0, alt); break;
		case SDLK_RIGHT: moveclip(&amp;cursor, clip, 1, 0, alt); break;
		case SDLK_SLASH: comment(&amp;cursor); break;
		}
	} else {
		switch(event-&gt;key.keysym.sym) {
		case SDLK_ESCAPE: reset(); break;
		case SDLK_PAGEUP: setoption(&amp;BPM, BPM + 1); break;
		case SDLK_PAGEDOWN: setoption(&amp;BPM, BPM - 1); break;
		case SDLK_UP: shift ? scale(0, -1, alt) : move(0, -1, alt); break;
		case SDLK_DOWN: shift ? scale(0, 1, alt) : move(0, 1, alt); break;
		case SDLK_LEFT: shift ? scale(-1, 0, alt) : move(-1, 0, alt); break;
		case SDLK_RIGHT: shift ? scale(1, 0, alt) : move(1, 0, alt); break;
		case SDLK_SPACE:
			if(!MODE)
				setoption(&amp;PAUSE, !PAUSE);
			break;
		case SDLK_BACKSPACE:
			insert('.');
			if(MODE)
				move(-2, 0, alt);
			break;
		}
	}
}

void
dotext(SDL_Event *event)
{
	int i;
	for(i = 0; i &lt; SDL_TEXTINPUTEVENT_TEXT_SIZE; ++i) {
		char c = event-&gt;text.text[i];
		if(c &lt; ' ' || c &gt; '~')
			break;
		insert(c);
	}
}

int
init(void)
{
	int i, j;
	if(SDL_Init(SDL_INIT_VIDEO) &lt; 0)
		return error("Init", SDL_GetError());
	gWindow = SDL_CreateWindow("Orca",
		SDL_WINDOWPOS_UNDEFINED,
		SDL_WINDOWPOS_UNDEFINED,
		WIDTH * ZOOM,
		HEIGHT * ZOOM,
		SDL_WINDOW_SHOWN);
	if(gWindow == NULL)
		return error("Window", SDL_GetError());
	gRenderer = SDL_CreateRenderer(gWindow, -1, 0);
	if(gRenderer == NULL)
		return error("Renderer", SDL_GetError());
	gTexture = SDL_CreateTexture(gRenderer,
		SDL_PIXELFORMAT_ARGB8888,
		SDL_TEXTUREACCESS_STATIC,
		WIDTH,
		HEIGHT);
	if(gTexture == NULL)
		return error("Texture", SDL_GetError());
	pixels = (Uint32 *)malloc(WIDTH * HEIGHT * sizeof(Uint32));
	if(pixels == NULL)
		return error("Pixels", "Failed to allocate memory");
	for(i = 0; i &lt; HEIGHT; i++)
		for(j = 0; j &lt; WIDTH; j++)
			pixels[i * WIDTH + j] = theme[0];
	initmidi();
	return 1;
}

int
main(int argc, char *argv[])
{
	Uint8 tick = 0;
	if(!init())
		return error("Init", "Failure");
	if(argc &gt; 1) {
		if(!opendoc(&amp;doc, argv[1]))
			makedoc(&amp;doc, argv[1]);
	} else
		makedoc(&amp;doc, "untitled.orca");
	while(1) {
		SDL_Event event;
		if(!PAUSE) {
			if(tick &gt; 3) {
				frame();
				tick = 0;
			} else
				tick++;
		}
		SDL_Delay(60000 / BPM / 16);
		while(SDL_PollEvent(&amp;event) != 0) {
			switch(event.type) {
			case SDL_QUIT: quit(); break;
			case SDL_MOUSEBUTTONUP:
			case SDL_MOUSEBUTTONDOWN:
			case SDL_MOUSEMOTION: domouse(&amp;event); break;
			case SDL_KEYDOWN: dokey(&amp;event); break;
			case SDL_TEXTINPUT: dotext(&amp;event); break;
			case SDL_WINDOWEVENT:
				if(event.window.event == SDL_WINDOWEVENT_EXPOSED)
					redraw(pixels);
				break;
			}
		}
	}
	quit();
	return 0;
}
</pre><figcaption>&mdash; Submit an <a href='https://github.com/XXIIVV/oscean/blob/master/src/inc/text/orca.c.txt' target='_blank'>edit</a> to <a href='../src/inc/text/orca.c.txt'>orca.c.txt</a>(1337 lines)</figcaption>
</figure><figure><img src='../media/diary/140.jpg' alt='Orca Type picture' width='900'/><figcaption>12X03 &mdash; Orca Type</figcaption></figure><figure><img src='../media/diary/4.jpg' alt='Orca Glyphs picture' width='900'/><figcaption>09Z11 &mdash; Orca Glyphs</figcaption></figure><figure><img src='../media/diary/356.jpg' alt='Orca Machine picture' width='900'/><figcaption>07R11 &mdash; Orca Machine</figcaption></figure><ul><li><a href='https://git.sr.ht/~rabbits/orca-toy' target='_blank'>desktop version</a></li><li><a href='https://git.sr.ht/~rabbits/orca' target='_blank'>terminal version</a></li><li><a href='https://hundredrabbits.github.io/Orca' target='_blank'>browser version</a></li><li><a href='https://llllllll.co/t/orca/22492' target='_blank'>norns version</a></li></ul><p><i>incoming(11)</i>: <a href='alicef.html'>alicef</a> <a href='azolla.html'>azolla</a> <a href='themes.html'>themes</a> <a href='yajnev_studies.html'>yajnev studies</a> <a href='pilot.html'>pilot</a> <a href='enfer.html'>enfer</a> <a href='nasu.html'>nasu</a> <a href='exed.html'>exed</a> <a href='norns.html'>norns</a> <a href='computer.html'>computer</a> <a href='juni.html'>juni</a> </p><p><i>Last update on <a href='tracker.html'>15B04</a>, edited 124 times. +561/736fh <b></b></i> <code style='float:right; font-size:80%'>-|||||</code></p><ul><li>14C11 &mdash; Orca Workshop Mila, Montreal</li><li>13V03 &mdash; Orca Workshop Foolab, Montreal</li><li>13J12 &mdash; Orca Workshop Algomech, Sheffield</li><li>12W13 &mdash; Orca Release</li></ul></main><footer><a href='https://creativecommons.org/licenses/by-nc-sa/4.0'><img src='../media/icon/cc.svg' width='30'/></a><a href='http://webring.xxiivv.com/'><img src='../media/icon/rotonde.svg' width='30'/></a><a href='https://merveilles.town/@neauoire'><img src='../media/icon/merveilles.svg' width='30'/></a><a href='https://github.com/neauoire'><img src='../media/icon/github.png' alt='github' width='30'/></a><span><a href='devine_lu_linvega.html'>Devine Lu Linvega</a> &copy; 2021 &mdash; <a href='about.html'>BY-NC-SA 4.0</a></span></footer></body></html>