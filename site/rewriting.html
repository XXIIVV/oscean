<!DOCTYPE html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../links/main.css" type="text/css" rel="stylesheet"><link href="../media/services/icon.png" type="image/png" rel="shortcut icon">
<title>XXIIVV &mdash; rewriting</title></head><body>
<header><a href="home.html"><img alt="XXIIVV" src="../media/icon/logo.svg"></a></header>

<nav><ul><li><a href="programming_languages.html" class="parent">programming languages</a></li><li><a href="operating_systems.html">operating systems</a></li><li><a href="graphical_input.html">graphical input</a></li><li><a href="file_formats.html">file formats</a></li><li><a href="data_encoding.html">data encoding</a></li><li><a href="type_systems.html">type systems</a></li><li><a href="versioning.html">versioning</a></li></ul><ul><li><a href="assembly.html">assembly</a></li><li><a href="two_dimensional.html">two dimensional</a></li><li><a href="concatenative.html">concatenative</a></li><li><a href="functional.html">functional</a></li><li><a href="imperative.html">imperative</a></li><li><a href="rewriting.html" class="self">rewriting</a></li></ul><ul><li><a href="fractran.html">fractran</a></li><li><a href="interaction_nets.html">interaction nets</a></li><li><a href="thue.html">thue</a></li><li><a href="modal.html">modal</a></li></ul></nav>
<main><h2>Rewriting languages are typically made of rules and a starting state.</h2>

<p>These languages often have two phases; the first gives <b>a set of rules</b>, and the second provides <b>an input</b> objects on which those rules are to be applied, sometimes called the <i>Accumulator</i>. For example, a program for a string rewriting system with wildcards begins with a series of rules which define strings to match, a relation(>), and the resulting transformation.</p>

<pre>
<i>rule</i>    swap ?x ?y > ?y ?x
<i>input</i>   swap foo bar
<i>output</i>  bar foo
</pre>

<img src='../media/refs/grue.png' style='width:300px' title='Bivotar & Juranda, Zork'/>
<h2>Fractran is a computer architecture based entirely on the multiplication of fractions.</h2>

<p>A <b>prime</b> is a number that can only be divided by itself one, since these
numbers can't be divided, they can considered the DNA of other numbers. The
factoring of a number into <a href='primes.html'>prime numbers</a>, for example: 18 = 2 × 3<sup>2</sup>,
exposes values which Fractran utilizes as <i>registers</i>. There are two parts to a Fractran program:</p>

<ol>
	<li><a href='#acc'>The Accumulator</a></li>
	<li><a href='#rules'>The Fractions</a></li>
</ol>

<figure>
	<img src='../media/refs/vogue-fractran.jpg' width='300' alt='流行通信'/>
	<figcaption>Typical Fractran Programmer</figcaption>
</figure>

<h3 id='acc'>The Accumulator</h3>

<table border='1' style='float: right;margin-left: 30px;'>
	<tr><th rowspan='2'>Accumulator</th><th colspan='4'>Registers</th></tr>
	<tr><th>r2</th><th>r3</th><th>r5</th><th>r7</th></tr>
	<tr><th>6</th><td>1</td><td>1</td><td></td><td></td></tr>
	<tr><th>18</th><td>1</td><td>2</td><td></td><td></td></tr>
	<tr><th>1008</th><td>4</td><td>2</td><td></td><td>1</td></tr>
	<tr><th>5402250</th><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</table>

<p>The <b>Accumulator</b> is a single number whose prime factorization holds the
value of registers(2, 3, 5, 7, 11, 13, 17, ..). For example, if the state of
the accumulator is 1008(2⁴ × 3² × 7), r2 has the value 4, r3 has the value
2, r7 has the value 1, and all other registers are unassigned.</p>

<h3>The Fraction</h3>

<img src='../media/refs/fractran.adder1.png' width='140px' style='float:right;margin-left:30px'/>

<p>A <b>Fraction</b> represents an instruction that tests one or more
registers by the prime factors of its numerator and denominator. To evaluate
the result of a rule we take the the accumulator, if multiplying it by this
<a href='fractions.html'>fraction</a> will give us an integer, we will update the accumulator with the
result.</p>

<table border='1'>
	<tr>
		<th>2/3</th>
		<th>15/256</th>
		<th>21/20</th>
	</tr>
	<tr>
		<td>(<span class='numreg'>2</span><sup class='numval'>1</sup>)/(<span class='denreg'>3</span><sup class='denval'>1</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>5</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>6</sup>)</td>
		<td>(<span class='numreg'>3</span><sup class='numval'>1</sup> × <span class='numreg'>7</span><sup class='numval'>1</sup>)/(<span class='denreg'>2</span><sup class='denval'>2</sup> × <span class='denreg'>5</span><sup class='denval'>1</sup>)</td>
	</tr>
	<tr>
		<td>
<pre>
if(<span class='denreg'>r3</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r3</span> -= <span class='denval'>1</span>;
	<span class='numreg'>r2</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>6</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>6</span>;
	<span class='numreg'>r3</span> += <span class='numval'>1</span>;
	<span class='numreg'>r5</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>
if(<span class='denreg'>r2</span> >= <span class='denval'>2</span> && <span class='denreg'>r5</span> >= <span class='denval'>1</span>){ 
	<span class='denreg'>r2</span> -= <span class='denval'>2</span>; 
	<span class='denreg'>r5</span> -= <span class='denval'>1</span>; 
	<span class='numreg'>r3</span> += <span class='numval'>1</span>; 
	<span class='numreg'>r7</span> += <span class='numval'>1</span>;
	return;
}</pre>
		</td>
	</tr>
</table>

<p>Operations become more readable when broken down into their primes. We can
think of every prime number as having a register which can take on non-negative
integer values. Each fraction is an instruction that operates on some of the
registers.</p>

<h3 id='notation'>A Notation</h3>

<p>While Fractran is commonly reduced to just another opaque esoteric language,
portraying it as such is doing a disservice to the relatively simple idea at
its core and to the researchers who might otherwise benefit by venturing deeper
into a relatively unexplored field of computation.</p>

<p><a href='https://wryl.tech' target='_blank'>Wryl</a>, who created <a href='modal.html'>Modal</a>, demonstrated to me an interesting connection between Fractran and <a href='rewriting.html'>rewriting languages</a>. We need only to compile our rules and point the prime registers to symbols in a dictionary to see this relationship more clearly.</p>

<pre style='clear:both'>
:: left side > right side  <i>15/6 left.2 side.3 > side.3 right.5</i>

AC 6 left side  <i>accumulator</i>
00 6 × 15/6 = 15, side right  <i>result</i>
</pre>

<p>This documentation will represent registers with names(x, y, foo-bar, baz, ..). Fractions will be
written as rewrite rules starting with <code>::</code>, a left-side, a
spacer(>) and a right-side. The notation indicates which registers to replace
on the left-side, and what to replace them with on the right-side.</p>

<img src='../media/refs/fractran.multiply.png' width='220px'/>

<h3>Programming In Fractran</h3>

<p>In a rule definition, which is a fraction where prime factorization is written as symbols, we find symbols to the left-side of the spacer(>) to be rewritten by symbols found on the right-side. Each new symbol is added to the dictionary and represented internally as a prime number.</p>

<pre>
:: flour sugar apples > apple-cake
:: apples oranges cherries > fruit-salad
:: fruit-salad apple-cake > fruit-cake

sugar oranges apples cherries flour apples
</pre>

<p>Rules are tested in a sequence from the first to the last, when a valid rewrite rule is encountered, the accumulator is updated by the product of the multiplication of the accumulator with the fraction, and search for the next rule starts back again from the beginning.</p>

<pre>
:: 7/30 flour.2 sugar.3 apples.5 > apple-cake.7 
:: 17/715 apples.5 oranges.11 cherries.13 > fruit-salad.17 
:: 19/119 apple-cake.7 fruit-salad.17 > fruit-cake.19 

AC 21450 flour sugar apples apples oranges cherries 
00 21450 × 7/30 = 5005, apples apple-cake oranges cherries 
01 5005 × 17/715 = 119, apple-cake fruit-salad 
02 119 × 19/119 = 19, fruit-cake 
</pre>

<p>In other words, it helps to visualize the fractions in a program as a list of rewrite rules that tests the accumulator against its left-side, and starts back at the top of the list after updating the accumulator when it is a match, or keep going when it does not.</p>

<q>Fractran has a single operation, and can be explained in 10 seconds.</q>

<ul>
    <li>For each fraction in a list for which the multiplication of the accumulator and the fraction is an integer, replace the accumulator by the result of that multiplication.</li>
    <li>Repeat this rule until no fraction in the list produces an integer when multiplied by the accumulator, then halt.</li>
</ul>

<p>That's all!</p>

<figure>
	<img src='../media/refs/fractran.png' width='340'/>
	<figcaption>The Book of Numbers, <a href='https://en.wikipedia.org/wiki/John_Horton_Conway' target='_blank'>John Conway</a></figcaption>
</figure>

<h3>Logic & Arithmetic</h3>

<p>Logic in rewrite rules is typically implemented as multiple rules, where each one is a potential location in the <a href='logic.html'>truth table</a>, here is <b>logical and</b> between two registers(x&y) as example:</p>

<pre>
:: x y and > true
:: x and > false
:: y and > false

AC 30 x y and 
00 30 × 7/30 = 7, true
</pre>

<p>The <b>sum</b> of two registers(x+y) can be reached by moving the value of one register into the other. The <i>naming</i> of the x register in advance ensures that the highest number will be stored in the lowest register:</p>

<pre>
:: x
:: y > x

AC 144 x^4 y^2
00 144 × 2/3 = 96, x^5 y
00 96 × 2/3 = 64, x^6
</pre>

<p>The <b>difference</b> between two registers(x-y) can be reached by consuming the value of two registers at once, and moving the remains to the first:</p>

<pre>
:: x y >
:: y > x

AC 576 x^6 y^2
00 576 × 1/6 = 96, x^5 y 
00 96 × 1/6 = 16, x^4
</pre>

<p>The <b>doubling</b> of a register(x*2) can be reached by keeping an operator register <i>double</i> and a temporary accumulator(A):</p>

<pre>
:: x double > A A double
:: double > 
:: A A > x x

AC 48, x^4 double 
00 48 × 75/6 = 600, x^3 double A^2 
00 600 × 75/6 = 7500, x^2 double A^4 
00 7500 × 75/6 = 93750, x double A^6 
00 93750 × 75/6 = 1171875, double A^8 
01 1171875 × 1/3 = 390625, A^8 
02 390625 × 4/25 = 62500, x^2 A^6 
02 62500 × 4/25 = 10000, x^4 A^4 
02 10000 × 4/25 = 1600, x^6 A^2 
02 1600 × 4/25 = 256, x^8
</pre>

<p>The <b>halving</b> of a register(x/2) can be reached by keeping an operator register <i>half</i> and a temporary accumulator(A)</p>

<pre>
:: half x x > A half
:: half > 
:: A > x

AC 1458, half x^6 
00 1458 × 10/18 = 810, half x^4 A 
00 810 × 10/18 = 450, half x^2 A^2 
00 450 × 10/18 = 250, half A^3 
01 250 × 1/2 = 125, A^3 
02 125 × 3/5 = 75, x A^2 
02 75 × 3/5 = 45, x^2 A 
02 45 × 3/5 = 27, x^3 

x^3 
</pre>


<h3>Example: Tic-Tac-Toe</h3>

<p>Fractran's <b>output</b> capability is limited to the resulting accumulator at the end of an evaluation. The advantage of symbolic rewriting is that registers are already assigned names, so we shall print those instead. As for <b>input</b>, we can type in new symbol tokens and appending their value to the accumulator between evaluations. We can implement a <i>tic-tac-toe</i> in a mere 16 rules:</p>

<pre>
<i>Reserve the first registers for the player moves:</i>

:: x#a o#a x#b o#b x#c o#c
:: x#d o#d x#e o#e x#f o#f
:: x#g o#g x#h o#h x#i o#i

<i>This register remains active until the game ends:</i>

game

<i>A symbol to draw the value of registers in a grid:</i>

"

  Set move in the format x#a, o#b, x#c, etc:

  a b c  |  {x#a o#a .} {x#b o#b .} {x#c o#c .}
  d e f  |  {x#d o#d .} {x#e o#e .} {x#f o#f .}
  g h i  |  {x#g o#g .} {x#h o#h .} {x#i o#i .}

 "

<i>Rules for each possible victory states:</i>

:: game x#a x#b x#c > x#a x#b x#c "Player X wins!" 
:: game o#a o#b o#c > o#a o#b o#c "Player O wins!"
:: game x#d x#e x#f > x#d x#e x#f "Player X wins!" 
:: game o#d o#e o#f > o#d o#e o#f "Player O wins!"
:: game x#g x#h x#i > x#g x#h x#i "Player X wins!" 
:: game o#g o#h o#i > o#g o#h o#i "Player O wins!"
:: game x#a x#e x#i > x#a x#e x#i "Player X wins!" 
:: game o#a o#e o#i > o#a o#e o#i "Player O wins!"
:: game x#g x#e x#c > x#g x#e x#c "Player X wins!" 
:: game o#g o#e o#c > o#g o#e o#c "Player O wins!"
:: game x#a x#d x#g > x#a x#d x#g "Player X wins!" 
:: game o#a o#d o#g > o#a o#d o#g "Player O wins!"
:: game x#b x#e x#h > x#b x#e x#h "Player X wins!" 
:: game o#b o#e o#h > o#b o#e o#h "Player O wins!"
:: game x#c x#f x#i > x#c x#f x#i "Player X wins!" 
:: game o#c o#f o#i > o#c o#f o#i "Player O wins!"
</pre>

<p>Program don't need to specify anything other than these 16 rules, as players can already input their moves in the format of its register names: x#a, o#b, x#c, etc.</p>

<pre>
  Set move in the format x#a, o#b, x#c, etc:

  a b c  |  x o o
  d e f  |  . x .
  g h i  |  . . x

  Player X wins!
</pre>

<p>A Fractran program specifies the wiring and logic of an interactive application, registers point to symbols in memory and so the bytecode itself is never localized as these strings reside in the application's front-end far from its logic.</p>

<h3>Example: Fizzbuzz</h3>

<p>Alternatively to getting the resulting program state at the end of an evaluation, we can emit the accumulator at a specific rate during the evaluation by checking if a register is active or not.</p>

<pre>
<i>Reserve the first registers for the increments and base-10:</i>

:: +5 +3
:: 1# 2# 3# 4# 5# 6# 7# 8# 9# 0
:: 1  2  3  4  5  6  7  8  9

<i>Leave the printing register for no more than one rewrite:</i>

:: print: fizz >
:: print: buzz >
:: print: fizzbuzz >
:: print: "{1# 2# 3# 4# 5# 6# 7# 8# 9# 0}{1 2 3 4 5 6 7 8 9}" > 

<i>Fizzbuzz logic:</i>

:: eval +3 +3 +3 +5 +5 +5 +5 +5 > print: fizzbuzz
:: eval +3 +3 +3 > print: fizz
:: eval +5 +5 +5 +5 +5 > print: buzz
:: eval > print: "{1# 2# 3# 4# 5# 6# 7# 8# 9# 0}{1 2 3 4 5 6 7 8 9}"

<i>Base-10 numbers:</i>

:: 1# 9 > 2# 0 +3 +5 eval
:: 2# 9 > 3# 0 +3 +5 eval
:: 3# 9 > 4# 0 +3 +5 eval
:: 4# 9 > 5# 0 +3 +5 eval
:: 5# 9 > 6# 0 +3 +5 eval
:: 6# 9 > 7# 0 +3 +5 eval
:: 7# 9 > 8# 0 +3 +5 eval
:: 8# 9 > 9# 0 +3 +5 eval
:: 9# 9 > 

:: 0 > 1 +3 +5 eval
:: 1 > 2 +3 +5 eval
:: 2 > 3 +3 +5 eval
:: 3 > 4 +3 +5 eval
:: 4 > 5 +3 +5 eval
:: 5 > 6 +3 +5 eval
:: 6 > 7 +3 +5 eval
:: 7 > 8 +3 +5 eval
:: 8 > 9 +3 +5 eval
:: 9 > 1# 0 +3 +5 eval

<i>The initial state:</i>

0
</pre>

<p>During the evaluation, these 27 fractions will toggle <code>r79(print:)</code> giving us a trigger when the accumulator state might be read. This is demonstrated here as an alternative approach for emitting programs and debugging where the runtime is masking lower registers to the printing register.</p>

<pre>
07 25338 × 7979/103 = 1962834      01 
07 159444 × 7979/103 = 12351492    02 
05 1045656 × 6557/2781 = 2465432   fizz 
07 262032 × 7979/103 = 20298576    04 
06 1750176 × 7031/3296 = 3733461   buzz 
05 339282 × 6557/2781 = 799954     fizz 
07 82812 × 7979/103 = 6415116      07 
07 526536 × 7979/103 = 40788648    08 
05 3248208 × 6557/2781 = 7658576   fizz 
06 1829280 × 7031/3296 = 3902205   buzz 
07 380070 × 7979/103 = 29442510    11 
05 2391660 × 6557/2781 = 5639020   fizz 
07 580920 × 7979/103 = 45001560    13 
07 3930480 × 7979/103 = 304478640  14 
04 26252640 × 7663/88992 = 2260585 fizzbuzz 
07 188490 × 7979/103 = 14601570    16 
07 1242180 × 7979/103 = 96226740   17 
05 7898040 × 6557/2781 = 18621880  fizz
..
</pre>

<p>To explore further, try running these <a href='https://git.sr.ht/~rabbits/fractran/tree/main/item/examples' target='_blank'>examples</a> yourself:</p>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/life.fra' target='_blank'>Conway's Game Of Life in Conway's Fractran</a>(<a href='https://www.youtube.com/watch?v=KcL1qriy5Ho' target='_blank'>video</a>)</li>
	<li><a href='https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/mul.fra' target='_blank'>Multiply</a></li>
	<li><a href='https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/div.fra' target='_blank'>Divide</a></li>
</ul>

<h3 id='stack'>Hard Mode: Stacking Machines</h3>

<p>A <a href='concatenative.html'>stack-machine</a> can be implemented, but it's <i>not for the faint of heart</i>, considering that Fractran is a computation model where the program state is kept in a single number, and allocate a whole stack into a single of its prime encoded register. The theory is that we can keep a stack of zeros and ones in a single register using a <a href='binary.html#stack'>binary encoding</a> for that number.</p>

<ul>
	<li>Pushing a <kbd>0</kbd> onto the stack is equivalent to doubling the number.</li>
	<li>Pushing a <kbd>1</kbd> is equivalent to doubling and adding 1.</li>
	<li>Popping is equivalent to dividing by 2, where the remainder is the number.</li>
</ul>

<p>If we begin with <b>push</b>, we can see that we are doubling the x register, same as demonstrated above. After the evaluation, our LIFO stack has a value of 30, and is equal to <kbd>1</kbd> <kbd>1</kbd> <kbd>1</kbd> <kbd>0</kbd>, where the right-most one is the item on top. Now, for <b>pop</b>, we can halve the x register, again, same as demonstrated above, and keeping the result of the value in a register for 0, and a register for 1.</p>

<pre>
:: push 1 x > A A push 1
:: push 1 > x
:: push 0 x > A A push 0
:: push 0 >

:: pop x x > A pop
:: pop x   > 1
:: pop     > 0

:: A A > x x
:: A > x
<i>
x    push 1 = x^3
x^3  push 1 = x^7
x^7  push 1 = x^15
x^13 push 0 = x^30

x^30 pop : 0 x^15
x^15 pop : 1 x^7
x^7  pop : 1 x^3
x^3  pop : 1 x</i>
</pre>

<p>In the rest of the program, we can define two temporary register to keep the result of popping, the extra stack primitives such as <b>dup</b> and <b>swap</b>, and little state machine with the stack operations:</p>

<pre>
:: ?#a 0 > 0#a :: ?#a 1 > 1#a
:: ?#b 0 > 0#b :: ?#b 1 > 1#b

:: dup > pop ?#a dup-next
:: dup-next 0#a > 0#a 0#a push-a push-a 
:: dup-next 1#a > 1#a 1#a push-a push-a 

:: swap > swap-next pop ?#a 
:: swap-next > swap-last pop ?#b push-a
:: swap-last > push-b

:: push-a 0#a > push 0
:: push-a 1#a > push 1
:: push-b 0#b > push 0
:: push-b 1#b > push 1

:: 1) > push 1 2) <i>1</i>
:: 2) > push 1 3) <i>1 1</i>
:: 3) > push 1 4) <i>1 1 1</i>
:: 4) > push 0 5) <i>1 1 1 0</i>
:: 5) > swap   6) <i>1 1 0 1</i>
:: 6) > dup       <i>1 1 0 1 1</i>

1) x 
</pre>

<h3>Implementation</h3>

<p>The rewriting implementation of the runtime can be implemented in about <a href='ansi_c.html'>300
lines</a>.</p>

<div class='codeview'>
	<iframe src='../etc/fractran.c.txt'></iframe>
	<pre>cc fractran.c -o fractran <a href='../etc/fractran.c.txt' target='_blank'>view raw</a></pre>
</div>

<!--
<h3>Notes</h3>

<p>Fractran operators are <a href='reversible_computing.html'>reversible</a>, meaning that some programs can be run backward, back to its original state. To undo an operation, evaluation is undone by inverting the numerator and denumerator:</p>

<pre>
AC 19, fruit-cake
02 19 × 119/19 = 119, apple-cake fruit-salad
01 119 × 715/17 = 5005, apples apple-cake oranges cherries
00 5005 × 30/7 = 21450, apples apples flour sugar oranges cherries
</pre>

-->

<q>The wise marvels at the commonplace.</q>
<cite>Confucius</cite>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/fractran' target='_blank'>Fractran Interpreter(C89)</a>, used for this documentation.</li>
	<li><a href='https://tjwei.github.io/Fractran' target='_blank'>Fractran Interpreter(Web)</a></li>
	<li><a href='https://esoteric.codes/blog/an-intro-to-fractran' target='_blank'>Intro to Fractran</a></li>
	<li><a href='https://raganwald.com/2020/05/03/fractran.html' target='_blank'>Remembering John Conway</a></li>
	<li><a href='https://esolangs.org/wiki/Fractran' target='_blank'>On Esolang</a></li>
</ul>

<style>
	.numreg { background:#72dec2; color: black; padding: 0 2px; border-radius: 3px; }
	.numval { background:#b3f2c6; color: black; padding: 0 2px; border-radius: 3px; }
	.denreg { background:#f78f84; color: black; padding: 0 2px; border-radius: 3px; }
	.denval { background:#ffd18c; color: black; padding: 0 2px; border-radius: 3px; }
</style>
<h2>Interaction nets are a graphical model of computation.</h2>

<p><b>Interaction nets</b> can capture all computable functions with <a href='rewriting.html'>rewriting rules</a>, no external machinery such as copying a chunk of memory, or a garbage collector, is needed. Unlike models such as Turing machines, Lambda calculus, cellular automata, or <a href='logic.html'>combinators</a>, an interaction net computational step can be defined as a constant time operation, and the model allows for <a href='parallel_computing.html'>parallelism</a> in which many steps can take place at the same time.</p>

<h3 id='agents'>1. Agents</h3>

<p>An <b>agent</b>(<i>a</i>) is a cell that has one <i>principal port</i> and a number of <b>auxiliary ports</b>(<i>n</i>). A pair of agents connected together on their principal ports is called an <i>active pair</i>. Graphically, principal ports are distinguished by arrows(triangles).</p>

<img src='../media/refs/in_cell.png' width='350'/>

<p>The examples on this page will make use of four agents: <b>Successor</b>(increments a natural number), <b>Zero</b>, <b>Add</b> & <b>Mul</b>.</p>

<img src='../media/refs/in_ari.png' width='475'/>

<h3 id='nets'>2. Interaction Nets</h3>

<p>A <b>net</b> is an undirected graph of agents where each port is connected to another one by means of a <b>wire</b>. The following net has three free ports, <i>x</i>, <i>y</i>, and <i>z</i>. Note that a wire may connect two ports of the same agent. A rewriting of a net is performed only on an active pair according to an <a href='#rules'>interaction rule</a>.</p>

<img src='../media/refs/in_net.png' width='300'/>

<h3 id='rules'>3. Rewriting Rules</h3>

<p>Here, <i>rewriting</i> is just a convenient word to express a very concrete notion of <a href='https://www.youtube.com/watch?v=_uIGQ1biCXY' target='_blank'>interaction</a>, which we shall make precise by requiring some properties of rules:</p>

<ul>
	<li>Agents interact only through their principal port.</li>
	<li>Each variable in a rule occurs exactly twice, once on each side.</li>
	<li>There is at most one rule for each pair of distinct symbols.</li>
</ul>

<p>In an agent definition, the first port is the principal port,  the rest of the ports are listed in the order obtained by moving anticlockwise round the agent. The following definition follows the interaction net at the left side of the <a href='../media/refs/in_add_rule2.png'>rule 2 figure</a>.</p>

<pre>
<b>Net:</b>
	Add(u,y,z), S(u,x)
</pre>

<table border='1'>
	<tr>
		<th>Rule 1</th>
		<th>Rule 2</th>
	</tr>
	<tr>
		<td><img src='../media/refs/in_add_rule1.png' width='350'/></td>
		<td><img src='../media/refs/in_add_rule2.png' width='350'/></td>
	</tr>
</table>

<p>In the following notation, an interaction rule consists of a pair of net descriptions separated by an arrow. Agents are capitalized, and free ports are lowercase.</p>

<pre>
<b>Rules:</b>
	Add(u,y,z), Z(u)   --> z-y
	Add(u,y,z), S(u,x) --> S(z,w), Add(x,y,w)
</pre>

<p>An interaction net to compute the result of 1 + 1 with the rules defined above, is shown below, where one active pair has been generated. We then show two reductions, which use the previous two rules. The final net, on the right-hand side, is of course the representation of 2, which is the expected answer.</p>

<img src='../media/refs/in_add_res.png' width='550'/>

<h3>Programming</h3>

<p>From now on, we will use <a href='https://github.com/inpla/inpla' target='_blank'>Inpla</a>'s notation for rules in which the principal ports are taken out of the brackets and their equivalent connection written as <kbd>&gt;&lt;</kbd>. When an agent has an arity of 0, the brackets are removed altogether. Thus, we can write the entire addition program as:</p>

<pre>
<b>Rules:</b>
	add(y, z) >< Z => y~z;
	add(y, z) >< S(x) => add(y, S(z))~x;
<b>Exec:</b>
	add(res,S(Z))~S(S(Z)); <span style='color:#777'>1 + 2</span>
	res; 
<b>Result:</b>
	<span style='color:#777'>S(S(S(Z))), or 3</span>
</pre>

<p>When defining multiplication, note that the argument <i>y</i> is used twice in the first equation, and it is not used at all in the second one. For that reason, two extra symbols are needed <i>duplicate</i> and <i>erase</i>. </p>

<pre>
sx * y = (x + y) + y               0 * y = 0
</pre>
<img src='../media/refs/in_mul.png' width='450'/>

<p>The idea is that a net representing a natural number should be duplicated when it is connected to the principal port of a <i>duplicate</i>, and it should be erased when it is connected to the principal port of an <i>erase</i>.</p>

<img src='../media/refs/in_dupera.png' width='450'/>

<p>The system of interaction combinators consists of three symbols, called combinators: <i>y</i>(constructor), <i>d</i>(duplicator), and <i>e</i>(eraser). The six interaction rules below are of two kinds: commutation when the two cells carry different symbols (<i>yd</i>, <i>ye</i>, <i>de</i>) and annihilation when they carry the same symbol (<i>yy</i>, <i>dd</i>, <i>ee</i>).</p>

<img src='../media/refs/in_comb.png' width='800' style='max-width:800px'/>

<p>Note that the annihilations for <i>y</i> and <i>d</i> are not the same. Furthermore, if one numbers the auxiliary ports, one realizes that it is <i>yy</i>, not <i>dd</i>, which exchanges the ports:</p>

<img src='../media/refs/in_swp.png' width='450'/>

<q>The fundamental laws of computation are <b>commutation</b> and <b>annihilation</b>.</q>

<img src='../media/refs/oiseau_det.png' style='float:right'/>

<ul>
	<li><a href='https://dl.acm.org/doi/pdf/10.1145/96709.96718' target='_blank'>Interaction Nets</a></li>
	<li><a href='https://raw.githubusercontent.com/cicada-lang/inet/master/docs/papers/interaction-combinators.pdf' target='_blank'>Interaction Combinators</a></li>
	<li><a href='http://sro.sussex.ac.uk/id/eprint/54469/1/Sato%2C_Shinya.pdf' target='_blank'>Implementation of a low-level language for interaction nets</a>, Shinya Sato</li>
	<li><a href='https://github.com/inpla/inpla' target='_blank'>Inpla</a>, Interaction Nets as Programming Language</li>
	<li><a href='https://www.sciencedirect.com/sdfe/reader/pii/S1571066105050176/pdf' target='_blank'>Towards a Programming Language for Interaction Nets</a>, Ian Mackie</li>
	<li><a href='https://arxiv.org/pdf/1505.07164.pdf' target='_blank'>An Implementation Model for Interaction Nets</a></li>
	<li><a href='https://github.com/cicada-lang/inet' target='_blank'>Interaction Nets Playground</a></li>
	<li><a href='https://github.com/asperti/BOHM1.1' target='_blank'>Bologna Optimal Higher-Order Machine</a></li>
</ul>

<h2>Thue is a minimal string-rewriting language.</h2>

<p>A Thue program consists of two parts: a list of <a
href='rewriting.html'>substitution rules</a>, which is terminated with a line
having both sides of the operator empty, followed by a string representing the
initial program state:</p>

<pre>
#::=<span style='color:#777'>Unused rules are comments</span>
a::=~Hello Thue!
::=
[a] <span style='color:#777; float:right'>[]</span>
</pre>

<p>Execution consists of picking, from the list of rules, an arbitrary rule whose original string exists as a substring somewhere in the program state, and replacing that substring by the rule's replacement string. This process repeats until there are no rules that can be applied, at which point, the program ends. </p>

<pre>
#::=<span style='color:#777'>Increment binary number</span>
1_::=1++
0_::=1
01++::=10
11++::=1++0
_0::=_
_1++::=10
::=
_10010011_ <span style='color:#777; float:right'>_10010100</span>
</pre>

<img src='../media/refs/bthennota.png' width='100'/>

<h3>I/O</h3>

<p>Added to this system are two strings which are used to permit Thue to communicate with the outside world. The first of these is the <b>input</b> symbol(:::) which is actually the left-side of an implicit rule of which the user input is a component. The input symbol, therefore, is replaced by a line of text received from the "input stream."</p>

<p>As a counterpart of input, the <b>output</b> symbol(~) is supplied. Like the input symbol, the output symbol triggers an implicit rule which, in this case, encompasses the "output stream."  The specific effect is that all text to the right of the output symbol in the rhs of a production is sent to the output stream.</p>

<p>Note that either (or both) of these implicit rules may be overridden by providing explicit rules that perform some other task.</p>

<pre>
#::=<span style='color:#777'>Sierpinski's triangle, backticks are linebreaks</span>
X::=~_
Y::=~*
Z::=~`
_.::=._X
_*::=*_Y
._|::=.Z-|
*_|::=Z
..-::=.-.
**-::=*-.
*.-::=*-*
.*-::=.-*
@.-::=@_.
@*-::=@_*
::=
@_*...............................|
</pre>

<q>It is pitch black. You are likely to be eaten by a Thue.</q>

<ul>
	<li><a href='https://esolangs.org/wiki/Thue' target='_blank'>On Esolangs</a></li>
	<li><a href='https://git.sr.ht/~rabbits/uxn-games/tree/main/item/thue' target='_blank'>Interpreter</a>, written in Uxntal. <a href='https://www.youtube.com/watch?v=A8f7IsQ8ENQ' target='_blank'>Video</a></li>
	<li><a href='https://git.catseye.tc/Wanda/' target='_blank'>Wanda</a>, concatenative language meets string rewriting.</li>
</ul>
<h2>Modal is a programming language based on string rewriting.</h2>

<img src='../media/refs/soulages.png' style='float:right;width:200px' title='Pierre Soulages | Lithographie n°30 (1972)'/>

<p>Modal programs are represented as a series of substitution rules, applied to a given tree which gets
continually modified until no rules match any given part of the tree. The principale elements of modal are:</p>

<ul>
	<li><a href='#rules'>Rules</a>: &lt;&gt; left right</li>
	<li><a href='#registers'>Registers</a>: ?x, ?y, ?z</li>
	<li><a href='#trees'>Trees</a>: word, (a tuple), a (nested (list))</li>
</ul>

<p>The documentation below displays the examples as a series of rules, followed
by the rewriting steps in the following format:</p>

<pre>
&lt;&gt; A rule

.. The input program
04 The result of applying rule #4
-1 The result of applying a lambda</pre>

<p>Modal's evaluation model is based on scanning from left-to-right across a string that represents a serialized tree. We only match from the start of the string, and if we can't find a rule that matches, we move one token or subtree forward. All rules match against the start of the string, and if one matches, the matched pattern is erased, and the right-hand side of the rule is written to the end of the string.</p>

<h3 id='rules'>Rules</h3>

<p>To define a new rule, start with <kbd>&lt;&gt;</kbd>, followed by a
<i>left</i> and a <i>right</i> statement, which is either a word, or a <a
href='#tree'>tree</a>. The program evaluation starts at the first character of
the string and walks through to the end trying to match a transformation rule
from that location:</p>

<pre>&lt;&gt; hello (good bye)  <i>This is a rule</i>

.. hello world       <i>This is program data</i>
00 good bye world    <i>This is the result</i></pre>

<p>Rules can be also be undefined using the <kbd>&gt;&lt;</kbd> operation that will try matching a previously declared rule's <i>left</i> statement:</p>

<pre>
<> cat owl
<> owl bat
<> owl rat
>< owl

.. cat 
00 owl 
02 rat
</pre>

<p>Modal is homoiconic, meaning that any string is a potential program and new rules can be
composed directly during the evaluation. For instance, here is a rule that defines
a new rules definition <a href='notation.html'>infix syntax</a>:</p>

<pre>
<> (?x -> ?y) (<> ?x ?y)
fruit_a -> apple
fruit_b -> banana
(apple banana) -> fruit-salad

.. fruit_a fruit_b
01 apple fruit_b
02 apple banana
03 fruit-salad</pre>

<h3 id='registers'>Registers</h3>

<p>Registers are single-character identifiers bound to an address in a pattern
used in rewriting:</p>

<pre>&lt;&gt; (copy ?a) (?a ?a)

.. copy cat
00 cat cat</pre>

<p>When a register is used in a pattern, and when we try
to match a given tree with a pattern, each register is bound to a
corresponding an address to the left of a rule, and referenced to the right:</p>

<pre>&lt;&gt; (swap ?x ?y) (?y ?x)

.. (swap fox rat)
00 (rat fox)</pre>

<p>When a register appears more than once in a rule, each instance is bound to
the first address, but differently named registers can still match on the same pattern:</p>

<pre>
&lt;&gt; ((?x ?x ?x)) match3
&lt;&gt; ((?x ?y)) match2

.. (fox fox fox) (bat bat) (bat cat)
00 match3 (bat bat) (bat cat)
01 match3 match2 (bat cat)
01 match3 match2 match2
</pre>

<h3 id='trees'>Trees</h3>

<p>Trees can be found in rules and program data, they include words, registers
and nested trees. Rules can match specific trees and rewrite their content in a
new sequence.</p>

<pre>
&lt;&gt; (rotate ?x (?y) ?z) (?y (?z) ?x)

.. rotate foo (bar) baz
00 bar (baz) foo
</pre>

<p>An efficient way to represent an array is to store information in
nested lists, it allows for rules to target specific segments of the list,
similarly to Lisp's car and cdr primitives. To print each element of such a
structure, we can use the following recursive rules:</p>

<pre>
&lt;&gt; (putrec (?: ?x)) (putrec ?: ?x)
&lt;&gt; ((putrec (?:))) (?:)

.. (putrec (a (b (c (d (e))))))
00 (putrec (b (c (d (e)))))
00 (putrec (c (d (e))))
00 (putrec (d (e)))
00 (putrec (e))
01 

<b>> abcde</b>
</pre>

<h3>Logic</h3>

<p>Let us build a logic system, starting by comparing two registers:</p>

<pre>
&lt;&gt; (eq ?x ?x) (#t)
&lt;&gt; (eq ?x ?y) (#f)

.. (eq fox bat)
01 (#f)
</pre>

<p>We can implement the truth tables by defining each case:</p>

<pre>
&lt;&gt; (and #t #t) #t &lt;&gt; (or #t #t) #t 
&lt;&gt; (and #t #f) #f &lt;&gt; (or #t #f) #t
&lt;&gt; (and #f #t) #f &lt;&gt; (or #f #t) #t 
&lt;&gt; (and #f #f) #f &lt;&gt; (or #f #f) #f
&lt;&gt; (not #t) #f    &lt;&gt; (not #f) #t

.. (or #f #t)
08 (#t)
</pre>

<p>Building on the comparison rule above, we can write conditionals with a ternary statement: </p>
<pre>
&lt;&gt; (ife #t ?t ?f) (?t)
&lt;&gt; (ife #f ?t ?f) (?f)
&lt;&gt; (print ?:) (?:)

.. ife #f (print True!) (print False!)
13 (print False!)
14 ()
</pre>

<h3 id='types'>Types</h3>

<p>Understanding how to use <i>typeguard</i> to reach a specific evaluation order is
important to become proficient with Modal. Creating a type system is merely a
matter of creating stricter rules expecting a specific grammar. Notice in the example below, how join-strings expects to match two String
typed words. Without typed inputs, the rule is not matched.</p>

<pre>
&lt;&gt; (join-strings (String ?x) (String ?y)) (?x?y)

.. join-strings (String foo) (String bar)
00 foobar
</pre>

<h3 id='lambda'>Lambdas</h3>

<p>A <b>lambda</b> is created by using the <kbd>?(body)</kbd>
special register. Rules created that way exist only for the length of one
rewrite and must match what is found immediately after: </p>

<pre>
.. ?((?x ?y) (?y ?x)) foo bar
-1 bar foo
</pre>

<h3>Outgoing Events</h3>

<p>Sending a message is done with the <kbd>?:</kbd> special register, it sends a word or a tree to be handled by a device:</p>

<pre>
&lt;&gt; (print ?:) (?:)

.. print (hello world\n)

<b>hello world</b>
</pre>

<h3>Incoming Events</h3>

<p>Similarly, listening to incoming messages is done with the <kbd>?~</kbd> special register:</p>

<pre>
&lt;&gt; (?: print) (?:)
&lt;&gt; (READ ?~) ((You said: ?~ \n) print)

.. (READ stdin)

<b>You said: </b>
</pre>

<img src='../media/refs/soulages2.png' style='margin:30px auto; display:block' title='Pierre Soulages | Lithographie n°19 (1968)'/>

<q><b>modal</b>(adj.): of, or relating to structure as opposed to substance.</q>

<h3>Special Registers Reference</h3>

<table border='1' class='registers'>
	<tr><th colspan='3'>IO</th></tr>
	<tr><td>Read</td><td>?~</td><td>Read from devices</td></tr>
	<tr><td>Send</td><td>?:</td><td>Send to devices</td></tr>
	<tr><th colspan='3'>Substrings</th></tr>
	<tr><td>Explode token</td><td>?(?* ?*) abc</td><td>a (b (c ()))</td></tr>
	<tr><td>Explode tuple</td><td>?(?* ?*) (abc def ghi)</td><td>abc (def (ghi ()))</td></tr>
	<tr><td>Unpack</td><td>?(?. ?.) (abc def)</td><td>abc def</td></tr>
	<tr><td>Join</td><td>?(?^ ?^) (abc def ghi)</td><td>abcdefghi</td></tr>
</table>

<p>The <kbd>?*</kbd> special
register explodes a token or tuple into a nested list, and the <kbd>?^</kbd> register to join it back into a single word. Notice how the following program makes use the <a href='#types'>List
type</a> to ensure a specific evaluation order:</p>

<pre>
&lt;&gt; (reverse List () ?^) (?^)
&lt;&gt; (reverse (?*)) (reverse List (?*) ())
&lt;&gt; (reverse List (?x ?y) ?z) (reverse List ?y (?x ?z))

.. (reverse (modal))
01 (reverse List (m (o (d (a (l ()))))) ())
02 (reverse List (o (d (a (l ())))) (m ()))
02 (reverse List (d (a (l ()))) (o (m ())))
02 (reverse List (a (l ())) (d (o (m ()))))
02 (reverse List (l ()) (a (d (o (m ())))))
02 (reverse List () (l (a (d (o (m ()))))))
00 (ladom)
</pre>

<h3>sierpiński.modal</h3>

<p>To review everything documented above, here is a small program that prints the Sierpiński triangle fractal:</p>

<pre>
?(?-) (Rules)

&lt;&gt; (* (. > (. ?x))) (* (. (. > ?x))) 
&lt;&gt; (. (. > (* ?x))) (* (. (* > ?x))) 

?(?-) (Physics)

&lt;&gt; (Tri > (?x ?y)) (Tri (?x > ?y))
&lt;&gt; (Tri (?x > (?y ?z))) (Tri (?x (?y > ?z)))
&lt;&gt; (?x (?y > (?z ?n))) (. (?y (?z > ?n)))
&lt;&gt; ((?x > ())) (< ())
&lt;&gt; (Tri < (* ?^)) (?(?: ?:) (*?^ \n))
&lt;&gt; ((?x < ?y)) (< (?x ?y))

?(?-) (Print)

&lt;&gt; (Tri.join ?x ?:) (Tri > ?x ?:)
&lt;&gt; (Tri.dup ?x ?^) (Tri.join ?x ?^)
&lt;&gt; (Tri < ?x) (Tri.dup (. ?x) (?x \n))

?(?* (Tri < (?*))) ...............*...............</pre>

<h3>Implementation</h3>

<p>The language runtime can be implemented in about <a href='ansi_c.html'>300 lines</a>.</p>

<div class='codeview'>
	<iframe src='../etc/modal.c.txt'></iframe>
	<pre>cc modal.c -o modal <a href='../etc/modal.c.txt' target='_blank'>view raw</a></pre>
</div>

<ul>
	<li><a href='https://git.sr.ht/~rabbits/modal' target='_blank'>view sources</a>, ANSI C.</li>
	<li><a href='https://discord.gg/9e7vaVTSVs' target='_blank'>discord channel</a>, in the concatenative server.</li>
	<li><a href='https://www.sheeeeeeeep.art/types-of-modal.html'>Levels of Dynamic behavior in Modal</a></li>
	<li>This language is an original creation of <a href='https://wryl.tech/' target='_blank'>wryl</a> from 2018, who has courteously spent countless hours to help me progress with the language, much of the code above is derived from their research and merely made available here as to give this fantastic system a home on the internet.</li>
</ul>

<style>
	.registers tr * { font-family:mono;font-size:smaller }
</style><ul></ul><p class="incoming"><b>incoming</b> <a href="parade.html">parade</a> <a href="logic.html">logic</a> <a href="two_dimensional.html">two dimensional</a> <a href="fractran.html">fractran</a> <a href="interaction_nets.html">interaction nets</a> <a href="thue.html">thue</a> </p></main>
<footer><a href="https://webring.xxiivv.com/" target="_blank"><img src="../media/icon/webring.svg" alt="Webring"/></a><a href="https://merveilles.town/@neauoire" rel="me" target="_blank"><img src="../media/icon/merveilles.svg" alt="Merveilles"/></a><a href="ethics.html"><img src="../media/icon/dreipfeile.svg" alt="NoNazis!"/></a><a href="uxn.html"><img src="../media/icon/uxn.svg" alt="UxnPowered"/></a><span> <a href="devine_lu_linvega.html">Devine Lu Linvega</a> &copy; 2008-2024</span><div class="right"><a href="about.html#license">BY-NC-SA 4.0</a><a href="https://creativecommons.org/licenses/by-nc-sa/4.0" target="_blank"><img src="../media/icon/cc.svg" alt="CreativeCommons"/></a></div><hr/></footer>
</body></html>