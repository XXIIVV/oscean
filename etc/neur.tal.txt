( hey kirie! )

|00 @System/vector $2 &expansion $2 &wst $1 &rst $1 &metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1
|10 @Console/vector $2 &read $1 &pad $4 &type $1 &write $1 &error $1
|a0 @File/vector $2 &success $1 &success-lb $1 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|000

	@token/buf $40
	@rule/depth $1
	@rule/inhibitor $1

|100

@on-reset ( -> )
	;meta #06 DEO2
	;token/on-console .Console/vector DEO2
	BRK

@meta $1
	( name ) "Neur 0a
	( desc ) "Neural 20 "Nets 20 "Language 0a
	( auth ) "By 20 "Devine 20 "Lu 20 "Linvega 0a
	( date ) "31 20 "May 20 "2025 $2

@token/on-console ( -> )
	.Console/read DEI
	( ) DUP #21 LTH ?/<clear>
	( ) DUP [ LIT "* ] EQU ?/neur
	( ) DUP [ LIT ": ] EQU ?/exci
	( ) DUP [ LIT "; ] EQU ?/inhi
	( ) DUP [ LIT ". ] EQU ?/done
	[ LIT2 00 &ptr -&buf ] INCk ,&ptr STR
	STZ2
	BRK

	&neur ( c -> )
	;&buf neurons/find-alloc rule/<push-neuron> !/<clear>

	&exci ( c -> )
	#00 rule/<bind-inhi> !/<clear>

	&inhi ( c -> )
	#01 rule/<bind-inhi> !/<clear>

	&done ( c -> )
	rule/<bind-auto>
	rule/<init>
	( >> )

@token/<clear> ( c -> )
	[ LIT2 -&buf _&ptr ] STR
	[ LIT2 00 -&buf ] STZ
	POP BRK

(
@|Compiler )

%+Neuron/state ( neuron* -- /state* ) {
	;Neuron/state ADD2 }

%+Neuron/size ( neuron* -- /size* ) {
	;Neuron/size ADD2 }

%+Neuron/threshold ( neuron* -- /threshold* ) {
	;Neuron/threshold ADD2 }

%+Neuron/saturation ( neuron* -- /saturation* ) {
	;Neuron/saturation ADD2 }

@rule/<init> ( -- )
	[ LIT2 00 -rule/depth ] STZ
	[ LIT2 00 -rule/inhibitor ] STZ
	lhs/<init>
	rhs/<init>
	JMP2r

@rule/is-odd ( -- even/odd )
	[ LIT2 01 -&depth ] LDZ AND JMP2r

@rule/<push-neuron> ( n* -- )
	/is-odd ?rhs/<push-neuron>
	!lhs/<push-neuron>

@rule/<bind-inhi> ( inhi -- )
	.&inhibitor STZ
	/<bind>
	.&depth LDZk INC SWP STZ
	JMP2r

@rule/<bind-auto> ( -- )
	.&depth LDZ ?{ lhs/get-range ;neuron/do-wake arr2/<foreach> !live/<eval> }
	( >> )

@rule/<bind> ( -- )
	/get-from-range
	( | infer threshold )
	[ SUB2k #01 SFT2 ,&threshold STR POP ]
	( | connect each )
	;&do-connect arr2/<foreach>
	/is-odd ?lhs/<init>
	!rhs/<init>

@rule/do-connect ( n* -- n* )
	LDA2k STH2
	/get-to-range
	&>lb
		EQU2k ?{
			( | set alive & threshold )
			LDA2k +Neuron/state LDAk .State/alive AND ?{
				[ LIT2 -State/alive &threshold $1 ] OVR2 STA2 }
			POP2
			( | bind )
			LDA2k STH2kr /<push-connection>
			INC2 INC2 !&>lb }
	POP2 POP2 POP2r JMP2r

@rule/<push-connection> ( b* a* -- )
	( array ) ;Neuron/inhi ;Neuron/exci .&inhibitor LDZ [ JMP SWP2 POP2 ] ADD2
	( put neuron ) STH2k LDA2k DUP2 ADD2 INC2 INC2 ADD2 STA2
	( inc length ) STH2r LDA2k INC2 SWP2 STA2
	JMP2r

@rule/get-from-range ( -- to* from* )
	/is-odd ?lhs/get-range
	!rhs/get-range

@rule/get-to-range ( -- to* from* )
	/is-odd ?rhs/get-range
	!lhs/get-range

@lhs/<init> ( -- )
	;&buf ,&ptr STR2
	JMP2r

@lhs/get-range ( -- to* from* )
	,&ptr LDR2 ;&buf JMP2r

@lhs/<push-neuron> ( n* -- )
	[ LIT2 &ptr =&buf ] INC2k INC2 ,&ptr STR2
	STA2
	JMP2r

@rhs/<init> ( -- )
	;&buf ,&ptr STR2
	JMP2r

@rhs/get-range ( -- to* from* )
	,&ptr LDR2 ;&buf JMP2r

@rhs/<push-neuron> ( n* -- )
	[ LIT2 &ptr =&buf ] INC2k INC2 ,&ptr STR2
	STA2
	JMP2r

(
@|Runtime )

@live/<push-neuron> ( n* -- )
	STH2
	( | find neuron )
	,&ptr LDR2 ;&buf
	&>lf
		EQU2k ?{
			LDA2k STH2kr NEQ2 ?{ POP2 POP2 POP2r JMP2r }
			INC2 INC2 !&>lf }
	POP2 POP2 STH2r
	( | push neuron )
	[ LIT2 &ptr =&buf ] INC2k INC2 ,&ptr STR2
	STA2
	JMP2r

@live/<eval> ( -- )
	neurons/<fire>
	[ LIT2 00 _&step ] STR
	&>w
		,&ptr LDR2 ;&buf EQU2 ?{
			[ LIT2 80 &step $1 ] INCk ,&step STR
			/<step>
			NEQ ?&>w }
	JMP2r

@live/<step> ( -- )
	excited/<init>
	dirty/<init>
	,&ptr LDR2 ;&buf ;neuron/do-step arr2/<foreach>
	#0a19 DEO
	( | reset )
	;&buf ,&ptr STR2
	excited/<preserve> !dirty/<clean>

@excited/<init> ( -- )
	;&buf ,&ptr STR2
	JMP2r

@excited/<push-neuron> ( n* -- )
	[ LIT2 &ptr =&buf ] INC2k INC2 ,&ptr STR2
	STA2
	JMP2r

@excited/<preserve> ( -- )
	,&ptr LDR2 ;&buf ;neuron/do-preserve !arr2/<foreach>

@dirty/<init> ( -- )
	;&buf ,&ptr STR2
	JMP2r

@dirty/<push-neuron> ( n* -- n* )
	DUP2 [ LIT2 &ptr =&buf ] INC2k INC2 ,&ptr STR2
	STA2
	JMP2r

@dirty/<clean> ( -- )
	,&ptr LDR2 ;&buf ;neuron/do-clean !arr2/<foreach>

(
@|Neuron )

@neuron/get-bounds ( neuron* array* -- to* from* )
	ADD2 LDA2k DUP2 ADD2 SWP2 INC2 INC2 STH2k ADD2 STH2r JMP2r

@neuron/<print-name> ( neuron* -- )
	LDA2k str/<print>
	[ LIT2 "/ 19 ] DEO
	+Neuron/threshold LDA #0f AND [ LIT "0 ] ADD #19 DEO
	#2019 DEO
	JMP2r

@neuron/do-clean ( n* -- n* )
	LDA2k DUP2 +Neuron/state .State/alive ROT ROT STA
	+Neuron/saturation #00 ROT ROT STA
	JMP2r

@neuron/do-preserve ( n* -- n* )
	LDA2k +Neuron/state LDA .State/inhibited AND ?{
		( live ) LDA2k !live/<push-neuron> }
	JMP2r

@neuron/do-wake ( n* -- n* )
	LDA2k +Neuron/state [ LIT2 -State/alive-fire 01 ] SWP2 STA2
	JMP2r

@neuron/do-step ( n* -- n* )
	LDA2k DUP2 /<print-name>
	( | no threshold are always excited )
	DUP2 +Neuron/threshold LDA ?{ DUP2 excited/<push-neuron> }
	( | send to connections )
	DUP2 ;Neuron/inhi /get-bounds ;&do-send-inhi arr2/<foreach>
	;Neuron/exci /get-bounds ;&do-send-exci !arr2/<foreach>

@neuron/do-send-exci ( n* -- n* )
	LDA2k dirty/<push-neuron>
	DUP2 +Neuron/saturation LDAk INC ROT ROT STA
	DUP2 +Neuron/threshold LDA2 GTH ?{ DUP2 excited/<push-neuron> }
	POP2 JMP2r

@neuron/do-send-inhi ( n* -- n* )
	LDA2k dirty/<push-neuron>
	+Neuron/state .State/alive-inhibited ROT ROT STA
	JMP2r

(
@|Storage )

@neurons/find-alloc ( name* -- neuron* )
	LDZk ?{ POP2 ;anon-name !/<push-name> }
	( | find neuron )
	STH2
	,&ptr LDR2 ;&buf
	&>lf
		EQU2k ?{
			LDA2k STH2kr SWP2 str/compare ?{ POP2r NIP2 JMP2r }
			+Neuron/size !&>lf }
	POP2 POP2
	( | allocate neuron )
	STH2r dict/push-word
	( | set threshold )
	LDAk [ LIT "/ ] NEQ ?{
		( get value ) INC2k LDA [ LIT "0 ] SUB .State/alive SWP
		( set value ) ,&ptr LDR2 +Neuron/state STA2 }
	POP2
	( >> )

@neurons/<push-name> ( name* -- neuron* )
	[ LIT2 &ptr =&buf ] DUP2 +Neuron/size ,&ptr STR2
	STA2k NIP2 JMP2r

@neurons/<fire> ( -- )
	,&ptr LDR2 ;&buf
	&>lk
		EQU2k ?{
			DUP2 +Neuron/state LDA2
			( not zero ) #00 NEQ SWP
			( not fire ) .State/alive-fire NEQ AND ?{
				( push ) DUP2 live/<push-neuron> }
			+Neuron/size !&>lk }
	POP2 POP2 JMP2r

@dict/push-word ( str* -- ptr* cap* )
	,&ptr LDR2 SWP2
	&>w
		LDAk [ LIT "* ] EQU ?&end
		LDAk [ LIT "/ ] EQU ?&end
		LDAk /<push-byte>
		INC2 LDAk ?&>w
	&end ( -- )
	#00
	( >> )

@dict/<push-byte> ( c -- )
	[ LIT2 &ptr =&buf ] INC2k ,&ptr STR2
	STA
	JMP2r

(
@|etc )

@str/compare ( s* n* -- false )
	STH2
	&>w
		LDAk LDAkr STHr NEQ ?{ INC2 INC2r LDAk ?&>w }
	LDA LDAr STHr ?{
		( ) DUP #00 NEQ
		( ) SWP [ LIT "/ ] NEQ AND JMP2r }
	POP #01 JMP2r

@str/<print> ( str* -- )
	LDAk #19 DEO
	INC2 LDAk ?/<print>
	POP2 JMP2r

@arr2/<foreach> ( to* from* fn* -- )
	STH2
	&>l
		EQU2k ?{
			STH2kr JSR2 INC2 INC2 !&>l }
	POP2 POP2 POP2r JMP2r

@<phex> ( short* -: )
	SWP /b
	&b ( byte -: )
	DUP #04 SFT /c
	&c ( byte -: )
	#0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO
	JMP2r

(
@|assets )

@anon-name "* $1

@lhs/buf $40

@rhs/buf $40

@excited/buf $40

@dirty/buf $40

@live/buf $40

@dict/buf $4000

(
@|State
	| State Bits: 0 . 0 . 0 . 0 . 0 . fire . inhibited . alive )

@neurons/buf
|00 @Neuron/name $2 &state $1 &threshold $1 &saturation $1
	( len, [n*,n*..] ) &inhi &inhi/len $2 &inhi/buf $1e
	( len, [n*,n*..] ) &exci &exci/len $2 &exci/buf $1e &size
|01 @State/alive
|02 @State/inhibited
|03 @State/alive-inhibited
|05 @State/alive-fire

