( usage: drifblim.rom input.tal output.rom )

|00 @System/vector $2 &expansion $2 &wst $1 &rst $1 &metadata $2 &r $2 &g $2 &b $2 &debug $1 &state $1
|10 @Console/vector $2 &read $1 &pad $4 &type $1 &write $1 &error $1
|a0 @File/vector $2 &success $1 &success-lb $1 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2
|00 @RefType &ab $1 &as $1 &rb $1 &rs $1
|00 @SymType $40 &used $40 &declared

|000

	@src/buf $2f &cap $1
	@dst/buf $2f &cap $1
	@token/buf $2f &cap $1
	@scope/buf $2f &cap $1

|100

@on-reset ( -> )
	;meta #06 DEO2
	assembly/<start>
	;src/on-console
	( >> )

@bind ( vector* -> )
	.Console/vector DEO2
	[ LIT2 03 -Console/type ] DEI AND ?{
		;dict/usage <pstr>
		[ LIT2 01 -System/state ] DEO }
	BRK

@src/on-console ( -> )
	[ LIT2 02 -Console/type ] DEI LTH ?{
		.Console/read DEI [ LIT2 -&cap &ptr -&buf ] INCk ,&ptr STR
		NEQk ?{ ;dict/exceeded ;&buf ;dict/Path <set-error> }
		NIP STZ
		BRK }
	( | src -> dst )
	;dst/on-console !bind

@dst/on-console ( -> )
	[ LIT2 02 -Console/type ] DEI LTH ?{
		.Console/read DEI [ LIT2 -&cap &ptr -&buf ] INCk ,&ptr STR
		NEQk ?{ ;dict/exceeded ;&buf ;dict/Path <set-error> }
		NIP STZ
		BRK }
	( | assemble )
	;src/buf <handle-file>
	assembly/<resolve>
	BRK

@lib/inctal INC2
	( >> )

@<handle-file> ( f* -- )
	.File/name DEO2
	#0001 .File/length DEO2
	token/<new>
	#0000
	&>s ( len* -- )
		.System/state DEI ?&end
		;&c .File/read DEO2
		.File/success-lb DEI ?{
			ORAk ?{ ;dict/invalid ;src/buf ;dict/File <set-error> }
			&end ( i* -- )
			POP2 JMP2r }
		INC2 [ LIT &c $1 ] token/<push-byte> !&>s

@rom/<emit> ( -- )
	;dst/buf DUP2 assembly/<finish>
	.File/name DEO2
	#0100 SUB2 .File/length DEO2
	;&output .File/write DEO2
	JMP2r

@runes/lut [
	"| =lib/padabs "$ =lib/padrel "@ =lib/toplab "& =lib/sublab
	"% =lib/macros "( =lib/coment ", =lib/litrel "_ =lib/rawrel
	". =lib/litzep "- =lib/rawzep "; =lib/litabs "= =lib/rawabs
	"? =lib/litjci "! =lib/litjmi "# =lib/lithex "" =lib/rawstr
	"} =lib/lambda "~ =lib/inctal 5b =lib/ignore 5d =lib/ignore ] $1

@dict/usage "usage: 20 "drifblim.rom 20 "in.tal 20 "out.rom 0a $1
@dict/-in &in 20 "in 20 $1
@dict/Path "Path $1
@dict/File "File $1

@meta $1
	( name ) "Drifblim 0a
	( desc ) "Uxntal 20 "Assembler 0a
	( auth ) "By 20 "Devine 20 "Lu 20 "Linvega 0a
	( date ) "12 20 "Mar 20 "2025 $2



( @|Core )

@assembly/<start> ( -- )
	;dict/reset !scope/<set>

@assembly/<resolve> ( -- )
	;token/mode LDA2 ;asm-comment NEQ2 ?{
		( open cmt ) ;dict/open ;dict/trail ;dict/Comment !<set-error> }
	;token/mode LDA2 ;asm-macro NEQ2 ?{
		( open mac ) ;dict/open ;dict/trail ;dict/Macro !<set-error> }
	.System/state DEI ?{
		refs/<resolve-all>
		.System/state DEI ?{ rom/<emit> } }
	JMP2r

@assembly/<finish> ( name* -- length* )
	syms/<summary>
	[ LIT2 80 -System/state ] DEO
	;dict/assembled <pstr>
	<pstr>
	;dict/in <pstr>
	[ LIT2 &length 0100 ] DUP2 #0100 SUB2 <pdec>
	;dict/bytes !<pstr>

@token/<new> ( -- )
	[ LIT2 -&buf _&ptr ] STR
	[ LIT2 00 -&buf ] STZ
	JMP2r

@token/<push-byte> ( c -- )
	DUP #20 GTH ?{
		POP ;&buf LDZk ?{ POP2 JMP2r }
		[ LIT2 &mode =asm-default ] JSR2 !/<new> }
	( | append )
	[ LIT2 00 &ptr -&buf ]
	( overflow ) DUP .&cap EQU ?{ INCk ,&ptr STR }
	STZ2
	JMP2r

@token/<error> ( adj* -- )
	;&buf SWP2 !<set-error>

@scope/<push-byte> ( c -- )
	[ LIT2 00 &ptr -&buf ] INCk ,&ptr STR
	( overflow ) DUP .&cap LTH ?{ ;dict/exceeded ;&buf ;dict/Symbol <set-error> }
	STZ2
	JMP2r

@scope/<set> ( name* -- )
	[ LIT2 -&buf _&ptr ] STR
	&>w ( -- )
		LDAk [ LIT "/ ] EQU ?{
			LDAk /<push-byte>
			INC2 LDAk ?&>w }
	POP2 ,&ptr LDR ,&anchor STR
	JMP2r

@scope/make-name ( name* -- scope/label* )
	[ LIT2 &anchor $1 _&ptr ] STR
	[ LIT "/ ] /<push-byte>
	&>wl ( -- )
		LDAk /<push-byte>
		INC2 LDAk ?&>wl
	POP2 ;&buf JMP2r

(
@|Assembly )

@<set-default> ( -- )
	;asm-default ;token/mode STA2
	JMP2r

@asm-default ( t* -- )
	LDZk runes/find INC2k ORA ?{
		POP2
		( hex ) is-hex ?rom/<write-rawhex>
		( mac ) DUP2 macros/find-name INC2k ORA ?rom/<write-macro>
		( opc ) POP2 opcodes/find INCk ?rom/<write-opcode>
		( imm ) POP !lib/litjsi }
	INC2 LDA2 JMP2

@<set-comment> ( -- )
	;asm-comment ;token/mode STA2
	[ LIT2 01 _asm-comment/depth ] STR
	JMP2r

@asm-comment ( t* -- )
	[ LITr &depth $1 ] LDA2 DUP2
	( | nested comments )
	[ LIT2 ") 00 ] NEQ2 ?{ LITr 01 SUBr }
	[ LIT2 "( 00 ] NEQ2 ?{ INCr }
	STHkr [ LITr _&depth ] STRr
	?{ !<set-default> }
	JMP2r

@<set-macro> ( -- )
	;asm-macro ;token/mode STA2
	[ LIT2 00 _asm-macro/depth ] STR
	JMP2r

@asm-macro ( t* -- )
	[ LITr &depth $1 ] LDAk
	( | nested lambdas )
	[ LIT "} ] NEQ ?{
		[ LITr 01 ] SUBr STHkr ?{
			#00 macros/<push-byte>
			POP2 POPr !<set-default> } }
	STHkr #00 EQU ?{ ;token/buf macros/<push-word> }
	LDA [ LIT "{ ] NEQ ?{ INCr }
	[ LITr _&depth ] STRr
	JMP2r

@lib/ignore POP2 JMP2r
	&padabs req-name refs/get-any !rom/<set-head>
	&padrel req-name refs/get-any !rom/<set-head-rel>
	&toplab req-name DUP2 scope/<set> !syms/<new>
	&sublab INC2 scope/make-name !syms/<new>
	&litrel #80 rom/<write-byte> &rawrel req-name refs/get-rb !rom/<write-byte>
	&litzep #80 rom/<write-byte> &rawzep req-name refs/get-ab !rom/<write-byte>
	&litabs #a0 rom/<write-byte> &rawabs req-name refs/get-as !rom/<write-short>
	&litjci req-name #20 !rom/<write-call>
	&litjmi req-name #40 !rom/<write-call>
	&litjsi #60 !rom/<write-call>
	&lithex req-name !rom/<write-lithex>
	&rawstr req-name !rom/<write-str>
	&lambda POP2 !lambda/pop
	&coment POP2 !<set-comment>
	&macros req-name !macros/<new>

@req-name ( str* -- str1* )
	INC2 LDAk #20 GTH ?{ ;dict/invalid ;dict/Token !token/<error> }
	JMP2r

(
@|Lambda )

@lambda/make-name ( -- name* )
	[ LIT &count $1 ] INCk ,&count STR
	DUP [ LIT2 &ptr =&mem ] INC2k ,&ptr STR2
	STA
	( >> )

@lambda/name ( id -- str* )
	hexs ,&id STR2
	;&sym JMP2r

@lambda/pop ( -- )
	;&ptr LDA2k #0001 SUB2 LDAk /name syms/<new>
	SWP2 STA2
	JMP2r
	&sym cebb &id 0000 $1

(
@|Macros )

@macros/<new> ( name* -- name* )
	DUP2 /find-name INC2 ORA ?{
		DUP2 syms/find-name INC2 ORA ?{ macros/<push-word> !<set-macro> } }
	POP2 ;dict/duplicate ;dict/Macro !token/<error>

@macros/find-name ( name* -- <addr>* )
	STH2
	,&ptr LDR2 ;&mem
	&>l ( -- )
		DUP2 STH2kr wcmp ?{
			scap/ GTH2k ?&>l
		POP2 #ffff }
	NIP2 POP2r JMP2r

@macros/<push-word> ( t* -- )
	LDAk /<push-byte>
	INC2 LDAk ?&<push-word>
	POP2 #20
	( >> )

@macros/<push-byte> ( byte -- )
	[ LIT2 &ptr =&mem ] INC2k ,&ptr STR2
	STA
	( | check overflow )
	,&ptr LDR2 ;&mem-end LTH2 ?{
		( ! ) ;dict/exceeded ;dict/Macros !token/<error> }
	JMP2r

(
@|Syms )

@syms/<new> ( name* -- )
	DUP2 macros/find-name INC2 ORA ?&duplicate
	DUP2 /find-name INC2k ORA ?{
		( alloc ) POP2 .SymType/declared rom/get-head !/<push> }
	( | name* sym* -- )
	INC2k INC2 LDA .SymType/declared AND ?{
		( addr* ) rom/get-head OVR2 STA2
		( type ) INC2 INC2 LDAk .SymType/declared ORA ROT ROT STA
		( name* ) POP2 JMP2r }
	POP2
	&duplicate ( name* -- )
	POP2
	( ! ) ;dict/duplicate ;dict/Symbol !token/<error>

@syms/find-name ( name* -- <sym>* )
	STH2
	;&ptr LDA2 ;&mem
	&>lfn ( -- )
		DUP2 #0003 ADD2 STH2kr wcmp ?{
			#0003 ADD2 scap/ GTH2k ?&>lfn
		POP2 #ffff }
	NIP2 POP2r JMP2r

@syms/find-addr ( addr* -- sym* )
	LDA2 STH2
	;&ptr LDA2 ;&mem
	&>lfa ( -- )
		DUP2 #0003 ADD2 scap/ LDA2 STH2kr SWP2 LTH2 ?{
			#0003 ADD2 scap/ GTH2k ?&>lfa }
	NIP2 POP2r JMP2r

@syms/find-alloc ( name* -- <addr>* )
	DUP2 /find-name INC2k ORA ?{
		( null* -> ptr* ) POP2 ,&ptr LDR2
		( alloc ) OVR2 .SymType/used #ffff /<push> }
	NIP2 JMP2r

@syms/<push> ( name* type addr* -- )
	( hb ) SWP /<push-byte>
	( lb ) /<push-byte>
	( type ) /<push-byte>
	is-hex ?&invalid
	( is runic ) LDAk runes/find INC2 ORA ?&invalid
	( is opcode ) opcodes/find INC ?&invalid
	( >> )

@syms/<push-string> ( word* -- )
	LDAk /<push-byte>
	INC2 LDAk ?&<push-string>
	LDA
	( >> )

@syms/<push-byte> ( byte -- )
	[ LIT2 &ptr =&mem ] INC2k ,&ptr STR2
	STA
	( | check overflow )
	,&ptr LDR2 ;&mem-end LTH2 ?{
		( ! ) ;dict/exceeded ;dict/Symbols !token/<error> }
	JMP2r

@syms/invalid ( name* -- )
	/<push-string>
	( ! ) ;dict/invalid ;dict/Symbol !token/<error>

@syms/<summary> ( -- )
	;&ptr LDA2 ;&mem
	&>ls ( -- )
		( used ) INC2k INC2 LDA .SymType/used AND ?{
			( upper ) DUP2 #0003 ADD2 LDAk [ LIT "A ] SUB #1a LTH ?{
				;dict/unused <pstr>
				DUP2 <pstr>/
				#0a19 DEO }
			POP2 }
		#0003 ADD2 scap/ GTH2k ?&>ls
	POP2 POP2 JMP2r

(
@|References )

@refs/get-any ( str* -- value* )
	is-hex ?shex
	!/get-ref

@refs/get-type ( token* type -- addr* )
	,&type STR
	( >> )

@refs/get-ref ( token* -- addr* )
	LDA2k [ LIT2 "{ 00 ] NEQ2 ?{ POP2 lambda/make-name }
	LDAk [ LIT "/ ] NEQ ?{ INC2 scope/make-name }
	LDAk [ LIT "& ] NEQ ?{ INC2 scope/make-name }
	( | find symbol or create it )
	syms/find-alloc
	( | check if declared )
	INC2k INC2 STH2k LDA .SymType/declared AND ?{
		STH2k [ LIT &type $1 ] STH2r rom/get-head
		( addr* ) refs/<push-short>
		( value* ) refs/<push-short>
		( type ) refs/<push-byte> }
	( | mark as used )
	LDAkr STHr .SymType/used ORA STH2r STA
	LDA2 JMP2r

@refs/<push-short> ( -- )
	SWP /<push-byte>
	( >> )

@refs/<push-byte> ( byte -- )
	[ LIT2 &ptr =&mem ] INC2k ,&ptr STR2
	DUP2 ;&mem-end LTH2 ?{
		( ! ) ;dict/exceeded ;dict/References !token/<error> }
	STA
	JMP2r

@refs/<resolve-all> ( -- )
	,&ptr LDR2 ;&mem
	&>l ( -- )
		/<resolve>
		#0005 ADD2 GTH2k ?&>l
	POP2 POP2 JMP2r

@refs/<resolve> ( addr* -- addr* )
	DUP2 ;&err STA2
	DUP2k #0004 ADD2 LDA
	( | handlers )
	DUP .RefType/ab EQU ?/<set-ab>
	DUP .RefType/as EQU ?/<set-as>
	DUP .RefType/rb EQU ?/<set-rb>
	DUP .RefType/rs EQU ?/<set-rs>
	POP JMP2r

@refs/<set-ab> ( ref* type -- )
	POP /resolve-abs STA
	POP JMP2r

@refs/<set-as> ( ref* type -- )
	POP /resolve-abs STA2
	JMP2r

@refs/<set-rs> ( ref* type -- )
	POP /resolve-rel STA2
	JMP2r

@refs/<set-rb> ( ref* type -- )
	POP /resolve-rel
	( | validate distance )
	OVR2 #0080 ADD2 POP #00 EQU ?{
		( ! ) ;dict/too-far /<error> }
	STA
	POP JMP2r

@refs/resolve-sym ( ref* -- ref* addr* )
	( sym* ) INC2k INC2 LDA2
	( sym/addr* ) LDA2k INC2k ORA ?{
		( ! ) ;dict/invalid /<error> }
	( | sym* addr* )
	NIP2 JMP2r

@refs/resolve-abs ( ref* -- value* addr* )
	( value* ) /resolve-sym !/resolve

@refs/resolve-rel ( ref* -- value* addr* )
	( value* ) /resolve-sym OVR2 LDA2 /get-distance
	( >> )

@refs/resolve ( addr* ref* -- value* addr* )
	SWP2 LDA2 ;rom/mem ADD2 JMP2r

@refs/get-ab ( label* -- addr )
	.RefType/ab /get-type NIP JMP2r

@refs/get-as ( label* -- addr* )
	.RefType/as !/get-type

@refs/get-rb ( label* -- distance )
	.RefType/rb /get-type INC2k ORA ?{
		( undefined ) POP2 #00 JMP2r }
	rom/get-head /get-distance
	( | check distance )
	DUP2 #0080 ADD2 POP ?{ NIP JMP2r }
	NIP
	( ! ) ;dict/too-far ;token/buf INC2 ;dict/Reference !<set-error>

@refs/get-rs ( label* -- distance* )
	.RefType/rs /get-type rom/get-head
	( >> )

@refs/get-distance ( addr* -- distance* )
	( ) INC2 INC2 SUB2 JMP2r

@refs/<error> ( adj* -- )
	[ LIT2 &err $2 ] DUP2 syms/find-addr #0003 ADD2 scope/<set>
	INC2 INC2 LDA2 #0003 ADD2 ;dict/Reference !<set-error>

(
@|Rom )

@rom/get-head ( -- addr* )
	[ LIT2 &head 0100 ] JMP2r

@rom/<set-head-rel> ( addr* -- )
	rom/get-head ADD2
	( >> )

@rom/<set-head> ( addr* -- )
	,&head STR2
	JMP2r

@rom/<write-macro> ( t* macro* -- )
	token/<new>
	&>wcap ( name* -- body* )
		INC2 LDAk #20 GTH ?&>wcap
	INC2
	&>body ( body* -- cap* )
		LDAk token/<push-byte>
		INC2 LDAk ?&>body
	NIP2 LDA !token/<push-byte>

@rom/<write-str> ( str* -- )
	LDAk /<write-byte>
	INC2 LDAk ?&<write-str>
	POP2 JMP2r

@rom/<write-opcode> ( str* opc -- )
	#1f AND STH
	LDA2k [ LIT2 "LI ] EQU2 #70 SFT STH
	ORAr #0003 ADD2
	&>w ( -- )
		LDAk #21 LTH ?{
			LDAk [ LIT "k ] NEQ ?{ LITr 80 ORAr !&r }
			LDAk [ LIT "r ] NEQ ?{ LITr 40 ORAr !&r }
			LDAk [ LIT "2 ] NEQ ?{ LITr 20 ORAr !&r }
			( ! ) ;dict/invalid ;dict/Opcode token/<error> &r INC2 !&>w }
	POP2 STHr !/<write-byte>

@rom/<write-lithex> ( str* -- )
	INC2k INC LDZ NEQ #50 SFT #80 ORA /<write-byte>
	is-hex ?{ ;dict/invalid ;dict/Number token/<error> }
	( >> )

@rom/<write-rawhex> ( str* -- )
	INCk INC LDZk ?{ POP shex NIP !/<write-byte> }
	INC INC LDZ ?{ shex !/<write-short> }
	POP2 ;dict/invalid ;dict/Number !token/<error>

@rom/<write-call> ( str* opc -- )
	/<write-byte>
	refs/get-rs
	( >> )

@rom/<write-short> ( short* -- )
	SWP /<write-byte>
	( >> )

@rom/<write-byte> ( byte -- )
	DUP /get-head INC2k /<set-head>
	;&mem ADD2 STA
	( not zero ) ?{ JMP2r }
	/get-head
	( ) OVR ?{
		( ! ) ;dict/zero-page ;dict/Writing token/<error> }
	;assembly/length STA2
	JMP2r

(
@|Stdlib )

@is-hex ( str* -- str* f )
	DUP2
	&>w ( -- )
		chex INC ?{ POP2 #00 JMP2r }
		INC2 LDAk ?&>w
	POP2 #01 JMP2r

@shex ( str* -- value* )
	[ LIT2r 0000 ]
	&>w ( `i* -- )
		( acc ) [ LITr 40 ] SFT2r
		( res ) chex [ LITr 00 ] STH
		ADD2r INC2 LDAk ?&>w
	POP2 STH2r JMP2r

@hexs ( hex -- char char )
	DUP #04 SFT hexc SWP
	( >> )

@hexc ( hex -- char )
	#0f AND #0a LTHk ?{
		SUB [ LIT "a ] ADD JMP2r }
	POP [ LIT "0 ] ADD JMP2r

@chex ( str* c -- str* <val> )
	LDAk [ LIT "0 ] SUB DUP #0a LTH ?{
		#27 SUB DUP #10 LTH ?{ POP #ff } }
	JMP2r

@scap ( str* -- end* )
	INC2 & LDAk ?scap
	INC2 JMP2r

@wcmp ( a* b* -- f )
	STH2
	&>l ( a* `b* -- f )
		LDAk #21 LTH ?{
			LDAk LDAkr STHr NEQ ?{ INC2 INC2r !&>l } }
	LDA #21 LTH LDAr STHr #21 LTH AND JMP2r

@scmp3 ( a* b* -- f )
	LDA2k ROT2 LDA2k ROT2 EQU2 STH
	INC2 LDA2 SWP2 INC2 LDA2 EQU2 STHr AND JMP2r

@<pstr> ( str* -- )
	LDAk #19 DEO
	INC2 & LDAk ?<pstr>
	POP2 JMP2r

@<pdec> ( short* -- )
	[ LIT2r ff00 ]
	&>read ( -- )
		#000a DIV2k STH2k MUL2 SUB2 STH2r INCr ORAk ?&>read
	POP2
	&>write ( -- )
		NIP #30 ADD #19 DEO
		OVRr ADDr STHkr ?&>write
	POP2r JMP2r

(
@|Assets )

@runes/find ( char -- <addr>* )
	STH
	;&lut
	&>l ( -- )
		LDAk STHkr EQU ?{
			#0003 ADD2 LDAk ?&>l
		POP2 #ffff }
	POPr JMP2r

@opcodes/find ( str* -- str* <opc> )
	[ LITr 00 ] ;&lut
	&>l ( -- )
		SWP2k scmp3 ?{
			INCr #0003 ADD2 LDAk ?&>l
		POPr [ LITr ff ] }
	POP2 STHr JMP2r

@<set-error> ( adj* keyword* topic* -- )
	.System/state DEI ?{
		<pstr>
		#2019 DEO
		SWP2 <pstr>
		[ LIT2 ": 19 ] DEO
		#2019 DEO
		<pstr>
		;dict/-in <pstr>/
		;scope/buf <pstr>/
		#0a19 DEO
		[ LIT2 01 -System/state ] DEO
		JMP2r }
	POP2 POP2 POP2 JMP2r

@opcodes/lut [
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	"BRK ] $1

@dict/assembled "Assembled 20 $1 &bytes 20 "bytes. 0a $1
	&unused "-- 20 "Unused: 20 $1
	&References "References $1
	&Reference "Reference $1
	&Writing "Writing $1
	&Comment "Comment $1
	&Symbols "Symbols $1
	&Symbol "Symbol $1
	&Opcode "Opcode $1
	&Number "Number $1
	&Macros "Macros $1
	&Token "Token $1
	&Macro "Macro $1
	&exceeded "exceeded $1
	&invalid "invalid $1
	&zero-page "in 20 "zero-page $1
	&duplicate "duplicate $1
	&too-far "too 20 "far $1
	&open "open $1
	&trail ".. $1
	&reset "RESET $1

(
@|Buffers )

@lambda/mem $100

@refs/mem ( addr*, symbol*, RefType )
	$1800 &mem-end

@syms/mem ( addr*, SymType, body..00 )
	$4800 &mem-end

@macros/mem ( name..20, value..00 )
	$1000 &mem-end

@rom/mem ( zeropage )
	$100 &output

